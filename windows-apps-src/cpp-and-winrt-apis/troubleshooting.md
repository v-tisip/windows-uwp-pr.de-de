---
description: Die Tabelle mit den Symptomen und Problembehandlungen in diesem Thema kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren.
title: Problembehandlung bei C++/WinRT-Problemen
ms.date: 05/07/2018
ms.topic: article
keywords: windows 10, uwp, standard, c++, cpp, winrt, projizierung, problembehandlung, HRESULT, fehler
ms.localizationpriority: medium
ms.openlocfilehash: 120d5c8014ce9ac3cab9b2dfb1d778173f2434c4
ms.sourcegitcommit: a3dc929858415b933943bba5aa7487ffa721899f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/07/2018
ms.locfileid: "8795671"
---
# <a name="troubleshooting-cwinrt-issues"></a><span data-ttu-id="70fa7-104">Problembehandlung bei C++/WinRT-Problemen</span><span class="sxs-lookup"><span data-stu-id="70fa7-104">Troubleshooting C++/WinRT issues</span></span>

> [!NOTE]
> <span data-ttu-id="70fa7-105">Informationen zur Installation und Verwendung der [C++ / WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (bietet projektvorlagenunterstützung sowie C++ / WinRT MSBuild-Eigenschaften und-Ziele) finden Sie unter [Visual Studio-Unterstützung für C++ / WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span><span class="sxs-lookup"><span data-stu-id="70fa7-105">For info about installing and using the [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt) Visual Studio Extension (VSIX) (which provides project template support, as well as C++/WinRT MSBuild properties and targets) see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

<span data-ttu-id="70fa7-106">Dieses Thema stellt vorsorgliche Informationen bereit. Sie sollten diese kennen, auch wenn Sie sie noch nicht sofort brauchen.</span><span class="sxs-lookup"><span data-stu-id="70fa7-106">This topic is up front so that you're aware of it right away; even if you don't need it yet.</span></span> <span data-ttu-id="70fa7-107">Die Tabelle mit den Symptomen und Problembehandlungen in unten kann für Sie hilfreich sein, egal ob Sie neuen Code schreiben oder eine bestehende App portieren.</span><span class="sxs-lookup"><span data-stu-id="70fa7-107">The table of troubleshooting symptoms and remedies below may be helpful to you whether you're cutting new code or porting an existing app.</span></span> <span data-ttu-id="70fa7-108">Wenn Sie beim Portieren vorankommen möchten, und zu einem Punkt gelangen, an dem Ihr Projekt erstellt und ausgeführt werden kann, dann können Sie temporäre Fortschritte machen, indem Sie jeden nicht essentiellen Code mit Problemen auskommentieren oder streichen. Später können Sie den korrigierten Code wieder einfügen.</span><span class="sxs-lookup"><span data-stu-id="70fa7-108">If you're porting, and you're eager to forge ahead and get to the stage where your project builds and runs, then you can make temporary progress by commenting or stubbing out any non-essential code that's causing issues, and then returning to pay off that debt later.</span></span>

<span data-ttu-id="70fa7-109">Eine Liste mit häufig gestellten Fragen finden Sie [häufig gestellte Fragen](faq.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-109">For a list of frequently-asked questions, see [Frequently-asked questions](faq.md).</span></span>

## <a name="tracking-down-xaml-issues"></a><span data-ttu-id="70fa7-110">Nachverfolgen von XAML-Problemen</span><span class="sxs-lookup"><span data-stu-id="70fa7-110">Tracking down XAML issues</span></span>
<span data-ttu-id="70fa7-111">XAML-Analyseausnahmen sind u.U. schwierig zu diagnostizieren, insbesondere wenn keine sinnvollen Fehlermeldungen innerhalb der Ausnahme vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="70fa7-111">XAML parse exceptions can be difficult to diagnose&mdash;particularly if there are no meaningful error messages within the exception.</span></span> <span data-ttu-id="70fa7-112">Stellen Sie sicher, dass der Debugger für die Erfassung von Ausnahmen (erste Chance) konfiguriert ist (um die Analyseausnahme möglichst früh zu erfassen).</span><span class="sxs-lookup"><span data-stu-id="70fa7-112">Make sure that the debugger is configured to catch first-chance exceptions (to try and catch the parsing exception early on).</span></span> <span data-ttu-id="70fa7-113">Möglicherweise können Sie die Ausnahmevariable im Debugger überprüfen, um zu ermitteln, ob das HRESULT oder die Meldung hilfreiche Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="70fa7-113">You may be able to inspect the exception variable in the debugger to determine whether the HRESULT or message has any useful information.</span></span> <span data-ttu-id="70fa7-114">Überprüfen Sie auch das Visual Studio-Ausgabefenster auf Fehlermeldungen des XAML-Parsers.</span><span class="sxs-lookup"><span data-stu-id="70fa7-114">Also, check Visual Studio's output window for error messages output by the XAML parser.</span></span>

<span data-ttu-id="70fa7-115">Wenn Ihre App beendet wird und Sie nur wissen, dass beim XAML-Markup-Parsing eine unbehandelte Ausnahme ausgelöst wurde, dann könnte das das Ergebnis einer Referenz (per Schlüssel) auf eine fehlende Ressource sein.</span><span class="sxs-lookup"><span data-stu-id="70fa7-115">If your app terminates and all you know is that an unhandled exception was thrown during XAML markup parsing, then that could be the result of a reference (by key) to a missing resource.</span></span> <span data-ttu-id="70fa7-116">Es kann sich auch um eine Ausnahme handeln, die innerhalb eines UserControl-Elements, eines benutzerdefinierten Steuerelements oder eines benutzerdefinierten Layoutpanels ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="70fa7-116">Or, it could be an exception thrown inside a UserControl, a custom control, or a custom layout panel.</span></span> <span data-ttu-id="70fa7-117">Als letzte Möglichkeit kann eine Binärdatei aufgeteilt werden.</span><span class="sxs-lookup"><span data-stu-id="70fa7-117">A last resort is a binary split.</span></span> <span data-ttu-id="70fa7-118">Entfernen Sie etwa die Hälfte des Markups von einer XAML-Seite, und führen Sie die App erneut aus.</span><span class="sxs-lookup"><span data-stu-id="70fa7-118">Remove about half of the markup from a XAML Page and re-run the app.</span></span> <span data-ttu-id="70fa7-119">So können Sie feststellen, ob sich der Fehler in der entfernten Hälfte (die Sie jetzt in jedem Fall wiederherstellen sollten) oder in der nicht entfernten Hälfte befindet.</span><span class="sxs-lookup"><span data-stu-id="70fa7-119">You will then know whether the error is somewhere inside the half you removed (which you should now restore in any case) or in the half you did not remove.</span></span> <span data-ttu-id="70fa7-120">Wiederholen Sie den Vorgang durch Teilen der Hälfte mit den Fehler solange, Sie das Problem eingegrenzt haben.</span><span class="sxs-lookup"><span data-stu-id="70fa7-120">Repeat the process by splitting the half that contains the error, and so on, until you've zeroed in on the issue.</span></span>

## <a name="symptoms-and-remedies"></a><span data-ttu-id="70fa7-121">Symptome und Möglichkeiten zur Abhilfe</span><span class="sxs-lookup"><span data-stu-id="70fa7-121">Symptoms and remedies</span></span>
| <span data-ttu-id="70fa7-122">Symptom</span><span class="sxs-lookup"><span data-stu-id="70fa7-122">Symptom</span></span> | <span data-ttu-id="70fa7-123">Abhilfe</span><span class="sxs-lookup"><span data-stu-id="70fa7-123">Remedy</span></span> |
|---------|--------|
| <span data-ttu-id="70fa7-124">Zur Laufzeit wird eine Ausnahme mit einem HRESULT-Wert von REGDB_E_CLASSNOTREGISTERED ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="70fa7-124">An exception is thrown at runtime with a HRESULT value of REGDB_E_CLASSNOTREGISTERED.</span></span> | <span data-ttu-id="70fa7-125">Eine Ursache für diesen Fehler ist, dass Ihre Komponente für Windows-Runtime nicht geladen werden kann.</span><span class="sxs-lookup"><span data-stu-id="70fa7-125">One cause of this error is that your Windows Runtime Component can't be loaded.</span></span> <span data-ttu-id="70fa7-126">Stellen Sie sicher, dass die Windows-Runtime-Metadaten-Datei (`.winmd`) der Komponente den gleichen Namen wie die Komponenten-Binärdatei (`.dll`) hat, die auch der Name des Projekts und der Name des Root-Namespaces ist.</span><span class="sxs-lookup"><span data-stu-id="70fa7-126">Make sure that the component's Windows Runtime metadata file (`.winmd`) has the same name as the component binary (the `.dll`), which is also the name of the project and the name of the root namespace.</span></span> <span data-ttu-id="70fa7-127">Stellen Sie außerdem sicher, dass die Windows-Runtime-Metadaten und die Binärdatei vom Build-Prozess korrekt in den `Appx`-Ordner der nutzenden App kopiert wurden.</span><span class="sxs-lookup"><span data-stu-id="70fa7-127">Also make sure that the Windows Runtime metadata and the binary have been corectly copied by the build process to the consuming app's `Appx` folder.</span></span> <span data-ttu-id="70fa7-128">Und stellen Sie sicher, dass die `AppxManifest.xml` der nutzenden App (auch im `Appx`-Ordner) ein **&lt;InProcessServer&gt;**-Element enthält, das die aktivierbare Klasse und den Binärnamen korrekt deklariert.</span><span class="sxs-lookup"><span data-stu-id="70fa7-128">And confirm that the consuming app's `AppxManifest.xml` (also in the `Appx` folder) contains an **&lt;InProcessServer&gt;** element correctly declaring the activatable class and the binary name.</span></span> <span data-ttu-id="70fa7-129">Dieser Fehler kann auch auftreten, wenn Sie den Fehler machen, eine lokal implementierte Laufzeitklasse über den Standardkonstruktor des projizierten Typs zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="70fa7-129">This error can also happen if you make the mistake of instantiating a locally-implemented runtime class via the projected type's default constructor.</span></span> <span data-ttu-id="70fa7-130">Siehe [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md) für weitere Informationen über die korrekte Verwendung des projizierten Typs in diesem Fall.</span><span class="sxs-lookup"><span data-stu-id="70fa7-130">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more information about how to correctly use the projected type in that case.</span></span> |
| <span data-ttu-id="70fa7-131">Der C++ Compiler erzeugt den Fehler „*'implements_type': ist kein Mitglied einer direkten oder indirekten Basisklasse von '&lt;projizierter Typ&gt;'*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-131">The C++ compiler produces the error "*'implements_type': is not a member of any direct or indirect base class of '&lt;projected type&gt;'*".</span></span> | <span data-ttu-id="70fa7-132">Dies kann passieren, wenn Sie **make** mit dem nicht im Namespace qualifizierten Namen Ihres Implementierungstyps (z. B. **MyRuntimeClass**) aufrufen und den Header dieses Typs nicht eingebunden haben.</span><span class="sxs-lookup"><span data-stu-id="70fa7-132">This can happen when you call **make** with the namespace-unqualified name of your implementation type (**MyRuntimeClass**, for example), and you haven't included that type's header.</span></span> <span data-ttu-id="70fa7-133">Der Compiler interpretiert **MyRuntimeClass** als den projizierten Typ.</span><span class="sxs-lookup"><span data-stu-id="70fa7-133">The compiler interprets **MyRuntimeClass** as the projected type.</span></span> <span data-ttu-id="70fa7-134">Die Lösung besteht darin, den Header für Ihren Implementierungstyp (z. B. `MyRuntimeClass.h`) einzubinden.</span><span class="sxs-lookup"><span data-stu-id="70fa7-134">The solution is to include the header for your implementation type (`MyRuntimeClass.h`, for example).</span></span> |
| <span data-ttu-id="70fa7-135">Der C++ Compiler erzeugt den Fehler „*Versuch, eine gelöschte Funktion zu referenzieren*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-135">The C++ compiler produces the error "*attempting to reference a deleted function*".</span></span> | <span data-ttu-id="70fa7-136">Dies kann passieren, wenn Sie **make** aufrufen und der Implementierungstyp, den Sie als Template-Parameter übergeben, einen `= delete`-Standardkonstruktor hat.</span><span class="sxs-lookup"><span data-stu-id="70fa7-136">This can happen when you call **make** and the implementation type that you pass as the template parameter has an `= delete` default constructor.</span></span> <span data-ttu-id="70fa7-137">Bearbeiten Sie die Header-Datei des Implementierungstyps und ändern Sie `= delete` zu `= default`.</span><span class="sxs-lookup"><span data-stu-id="70fa7-137">Edit the implementation type's header file and change `= delete` to `= default`.</span></span> <span data-ttu-id="70fa7-138">Sie können auch einen Konstruktor in die IDL der Laufzeitklasse einfügen.</span><span class="sxs-lookup"><span data-stu-id="70fa7-138">You can also add a constructor into the IDL for the runtime class.</span></span> |
| <span data-ttu-id="70fa7-139">Sie haben [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged) implementiert, aber Ihre XAML-Bindungen werden nicht aktualisiert (und die Benutzeroberfläche registriert sich nicht für [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)).</span><span class="sxs-lookup"><span data-stu-id="70fa7-139">You've implemented [**INotifyPropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged), but your XAML bindings are not updating (and the UI is not subscribing to [**PropertyChanged**](/uwp/api/windows.ui.xaml.data.inotifypropertychanged.PropertyChanged)).</span></span> | <span data-ttu-id="70fa7-140">Denken Sie daran, `Mode=OneWay` (oder TwoWay) für Ihren Bindungsausdruck im XAML-Markup festzulegen.</span><span class="sxs-lookup"><span data-stu-id="70fa7-140">Remember to set `Mode=OneWay` (or TwoWay) on your binding expression in XAML markup.</span></span> <span data-ttu-id="70fa7-141">Weitere Informationen unter [XAML-Steuerelemente; Binden an eine C++/WinRT-Eigenschaft](binding-property.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-141">See [XAML controls; bind to a C++/WinRT property](binding-property.md).</span></span> |
| <span data-ttu-id="70fa7-142">Sie binden ein XAML-Items-Steuerelement an eine Observable-Collection, und zur Laufzeit wird eine Ausnahme mit der Meldung „Der Parameter ist falsch” ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="70fa7-142">You're binding a XAML items control to an observable collection, and an exception is thrown at runtime with the message "The parameter is incorrect".</span></span> | <span data-ttu-id="70fa7-143">Deklarieren Sie in Ihrer IDL und Ihrer Implementierung jede Observable-Collection als den Typ **Windows.Foundation.Collections.IVector<IInspectable>**.</span><span class="sxs-lookup"><span data-stu-id="70fa7-143">In your IDL and your implementation, declare any observable collection as the type **Windows.Foundation.Collections.IVector<IInspectable>**.</span></span> <span data-ttu-id="70fa7-144">Geben Sie jedoch ein Objekt zurück, das **Windows.Foundation.Collections.IObservableVector<T>** implementiert, wobei T Ihr Elementtyp ist.</span><span class="sxs-lookup"><span data-stu-id="70fa7-144">But return an object that implements **Windows.Foundation.Collections.IObservableVector<T>**, where T is your element type.</span></span> <span data-ttu-id="70fa7-145">Weitere Informationen unter [XAML-Items-Steuerelemente; Binden an eine C++/WinRT-Collection](binding-collection.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-145">See [XAML items controls; bind to a C++/WinRT collection](binding-collection.md).</span></span>  |
| <span data-ttu-id="70fa7-146">Der C++ Compiler erzeugt einen Fehler der Form „*'MyImplementationType_base&lt;MyImplementationType&gt;': kein passender Standardkonstruktor verfügbar*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-146">The C++ compiler produces an error of the form "*'MyImplementationType_base&lt;MyImplementationType&gt;': no appropriate default constructor available*".</span></span>|<span data-ttu-id="70fa7-147">Dies kann passieren, wenn Sie von einem Typ ableiten, der einen nicht-trivialen Konstruktor hat.</span><span class="sxs-lookup"><span data-stu-id="70fa7-147">This can happen when you have derived from a type that has a non-trivial constructor.</span></span> <span data-ttu-id="70fa7-148">Der Konstruktor Ihres abgeleiteten Typs muss die Parameter übergeben, die der Konstruktor des Basistyps benötigt.</span><span class="sxs-lookup"><span data-stu-id="70fa7-148">Your derived type's constructor needs to pass along the parameters that the base type's constructor needs.</span></span> <span data-ttu-id="70fa7-149">Ein funktionierendes Beispiel finden Sie unter [Abgeleitet von einem Typ, der einen nicht-trivialen Konstruktor hat.](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor)</span><span class="sxs-lookup"><span data-stu-id="70fa7-149">For a worked example, see [Deriving from a type that has a non-trivial constructor](author-apis.md#deriving-from-a-type-that-has-a-non-default-constructor).</span></span>|
| <span data-ttu-id="70fa7-150">Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-150">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;std::wstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="70fa7-151">Dies kann passieren, wenn Sie eine Std:: Vector des Std::wstring an eine Windows-Runtime-API übergeben, die eine Collection erwartet.</span><span class="sxs-lookup"><span data-stu-id="70fa7-151">This can happen when you pass a std::vector of std::wstring to a Windows Runtime API that expects a collection.</span></span> <span data-ttu-id="70fa7-152">Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-152">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="70fa7-153">Der C++ Compiler erzeugt den Fehler „*Konvertierung von 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' zu 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'* nicht möglich”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-153">The C++ compiler produces the error "*cannot convert from 'const std::vector&lt;winrt::hstring,std::allocator&lt;_Ty&gt;&gt;' to 'const winrt::param::async_iterable&lt;winrt::hstring&gt; &'*".</span></span>|<span data-ttu-id="70fa7-154">Dies kann passieren, wenn Sie ein std::vector von winrt::hstring an eine asynchrone Windows-Runtime-API übergeben, die eine Collection erwartet, und Sie den Vektor weder kopiert noch in den asynchronen Aufrufer verschoben haben.</span><span class="sxs-lookup"><span data-stu-id="70fa7-154">This can happen when you pass a std::vector of winrt::hstring to an asynchronous Windows Runtime API that expects a collection, and you've neither copied nor moved the vector to the async callee.</span></span> <span data-ttu-id="70fa7-155">Weitere Informationen finden Sie unter [Standard C++ Datentypen und C++/WinRT](std-cpp-data-types.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-155">For more info, see [Standard C++ data types and C++/WinRT](std-cpp-data-types.md).</span></span>|
| <span data-ttu-id="70fa7-156">Beim Öffnen eines Projekts erzeugt Visual Studio den Fehler „*Die Anwendung für das Projekt ist nicht installiert.*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-156">When opening a project, Visual Studio produces the error "*The application for the project is not installed*".</span></span>|<span data-ttu-id="70fa7-157">Falls noch nicht geschehen, müssen Sie **Windows Universal-Tools für die C++ Entwicklung** im Dialogfeld **Neues Projekt** von Visual Studio installieren.</span><span class="sxs-lookup"><span data-stu-id="70fa7-157">If you haven't already, you need to install **Windows Universal tools for C++ development** from within Visual Studio's **New Project** dialog.</span></span> <span data-ttu-id="70fa7-158">Wenn das Problem dadurch nicht behoben wird, hängt das Projekt möglicherweise von der C++/WinRT Visual Studio Extension (VSIX) ab (siehe [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).</span><span class="sxs-lookup"><span data-stu-id="70fa7-158">If that doesn't resolve the issue, then the project may depend on the C++/WinRT Visual Studio Extension (VSIX) (see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix)).</span></span>|
| <span data-ttu-id="70fa7-159">Die Tests des Zertifizierungskit für Windows-Apps erzeugen einen Fehler wie „*Eine Ihrer Laufzeitklassen ist nicht von einer Windows-Basisklasse abgeleitet ist. Alle zusammensetzbaren Klassen müssen letztlich von einem Typ im Windows-Namespace abgeleitet werden”*.</span><span class="sxs-lookup"><span data-stu-id="70fa7-159">The Windows App Certification Kit tests produce an error that one of your runtime classes "*does not derive from a Windows base class. All composable classes must ultimately derive from a type in the Windows namespace*".</span></span>|<span data-ttu-id="70fa7-160">Beliebigen Laufzeitklasse (, die Sie in Ihrer Anwendung deklarieren), die von einer Basisklasse abgeleitet wird, wird als bezeichnet ein *zusammensetzbaren* Klasse.</span><span class="sxs-lookup"><span data-stu-id="70fa7-160">Any runtime class (that you declare in your application) that derives from a base class is known as a *composable* class.</span></span> <span data-ttu-id="70fa7-161">Die letztendliche Basisklasse einer zusammensetzbaren Klasse muss ein Typ sein, in einem Windows-Namespace sein. Beispiel: [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject).</span><span class="sxs-lookup"><span data-stu-id="70fa7-161">The ultimate base class of a composable class must be a type originating in a Windows.\* namespace; for example, [**Windows.UI.Xaml.DependencyObject**](/uwp/api/windows.ui.xaml.dependencyobject).</span></span> <span data-ttu-id="70fa7-162">Finden Sie unter [XAML-Steuerelemente; binden an eine C++ / WinRT-Eigenschaft](binding-property.md) für Weitere Informationen.</span><span class="sxs-lookup"><span data-stu-id="70fa7-162">See [XAML controls; bind to a C++/WinRT property](binding-property.md) for more details.</span></span>|
| <span data-ttu-id="70fa7-163">Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für eine EventHandler- oder TypedEventHandler-Delegat-Spezialisierung.</span><span class="sxs-lookup"><span data-stu-id="70fa7-163">The C++ compiler produces a "*must be WinRT type*" error for an EventHandler or TypedEventHandler delegate specialization.</span></span>|<span data-ttu-id="70fa7-164">Verwenden Sie stattdessen **winrt::delegate&lt;...T&gt;**.</span><span class="sxs-lookup"><span data-stu-id="70fa7-164">Consider using **winrt::delegate&lt;...T&gt;** instead.</span></span> <span data-ttu-id="70fa7-165">Siehe [Erstellen von Ereignissen mit C++/WinRT](author-events.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-165">See [Author events in C++/WinRT](author-events.md).</span></span>|
| <span data-ttu-id="70fa7-166">Der C++ Compiler erzeugt einen „*WinRT-Typ erforderlich*”-Fehler für einen asynchron Windows-Runtime-Vorgang-Spezialisierung.</span><span class="sxs-lookup"><span data-stu-id="70fa7-166">The C++ compiler produces a "*must be WinRT type*" error for a Windows Runtime asynchronous operation specialization.</span></span>|<span data-ttu-id="70fa7-167">Erwägen Sie stattdessen, einen PPL-[**Task**](https://msdn.microsoft.com/library/hh750113) (Parallel Patterns Library) zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="70fa7-167">Consider returning a Parallel Patterns Library (PPL) [**task**](https://msdn.microsoft.com/library/hh750113) instead.</span></span> <span data-ttu-id="70fa7-168">Siehe [Parallelität und asynchrone Vorgänge](concurrency.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-168">See [Concurrency and asynchronous operations](concurrency.md).</span></span>|
| <span data-ttu-id="70fa7-169">Der C++ Compiler erzeugt „*Fehler C2220: Warnung als Fehler behandelt – keine'Object'-Datei generiert*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-169">The C++ compiler produces "*error C2220: warning treated as error - no 'object' file generated*".</span></span>|<span data-ttu-id="70fa7-170">Korrigieren Sie entweder die Warnung oder Festlegen der **C/C++-**>**Allgemeine**>**Warnungen als Fehler behandeln** , **Nein (/ WX-)**.</span><span class="sxs-lookup"><span data-stu-id="70fa7-170">Either correct the warning, or set **C/C++**>**General**>**Treat Warnings As Errors** to **No (/WX-)**.</span></span>|
| <span data-ttu-id="70fa7-171">Ihre App stürzt ab, weil ein Ereignis-Handler in Ihrem C++/WinRT-Objekt aufgerufen wird, nachdem das Objekt zerstört wurde.</span><span class="sxs-lookup"><span data-stu-id="70fa7-171">Your app crashes because an event handler in your C++/WinRT object is called after the object has been destroyed.</span></span>|<span data-ttu-id="70fa7-172">Finden Sie [problemlos den Zugriff auf die *dieser* Zeiger mit einem Delegaten Ereignisbehandlung](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span><span class="sxs-lookup"><span data-stu-id="70fa7-172">See [Safely accessing the *this* pointer with an event-handling delegate](weak-references.md#safely-accessing-the-this-pointer-with-an-event-handling-delegate).</span></span>|
| <span data-ttu-id="70fa7-173">Der C++ Compiler generiert „*Fehler C2338: Dies wird nur für schwache Referenzen unterstützt.*”.</span><span class="sxs-lookup"><span data-stu-id="70fa7-173">The C++ compiler produces "*error C2338: This is only for weak ref support*".</span></span>|<span data-ttu-id="70fa7-174">Sie fordern eine schwache Referenz für einen Typ an, der die **winrt::no_weak_ref**-Marker-Struktur als Template-Argument an seine Basisklasse übergeben hat.</span><span class="sxs-lookup"><span data-stu-id="70fa7-174">You're requesting a weak reference for a type that passed the **winrt::no_weak_ref** marker struct as a template argument to its base class.</span></span> <span data-ttu-id="70fa7-175">Finden Sie unter [Opt-Out der Unterstützung von schwachen Referenzen](weak-references.md#opting-out-of-weak-reference-support).</span><span class="sxs-lookup"><span data-stu-id="70fa7-175">See [Opting out of weak reference support](weak-references.md#opting-out-of-weak-reference-support).</span></span>|
| <span data-ttu-id="70fa7-176">Der C++ Linker erzeugt "*Fehler LNK2019: nicht aufgelöstes externes Symbol*"</span><span class="sxs-lookup"><span data-stu-id="70fa7-176">The C++ linker produces "*error LNK2019: Unresolved external symbol*"</span></span>|<span data-ttu-id="70fa7-177">Finden Sie unter [Warum ist der Linker und mir ein "LNK2019: nicht aufgelöstes externes Symbol" Fehler?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).</span><span class="sxs-lookup"><span data-stu-id="70fa7-177">See [Why is the linker giving me a "LNK2019: Unresolved external symbol" error?](faq.md#why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error).</span></span>|
| <span data-ttu-id="70fa7-178">Die toolkette LLVM und Clang erzeugt den Fehler, wenn Sie mit C++ / WinRT.</span><span class="sxs-lookup"><span data-stu-id="70fa7-178">The LLVM and Clang toolchain produces errors when used with C++/WinRT.</span></span>|<span data-ttu-id="70fa7-179">Wir unterstützen nicht die toolkette LLVM und Clang für C++ / WinRT, aber wenn Sie emulieren möchten, wie wir sie intern verwenden und Sie können versuchen ein Experiment wie das beschrieben [können ich LLVM/Clang zum Kompilieren mit C++ / WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).</span><span class="sxs-lookup"><span data-stu-id="70fa7-179">We don't support the LLVM and Clang toolchain for C++/WinRT, but if you wanted to emulate how we use it internally, then you could try an experiment such as the one described in [Can I use LLVM/Clang to compile with C++/WinRT?](faq.md#can-i-use-llvmclang-to-compile-with-cwinrt).</span></span>|
| <span data-ttu-id="70fa7-180">Der C++ Compiler erzeugt "*kein passender Standardkonstruktor verfügbar*" für einen projizierten Typ.</span><span class="sxs-lookup"><span data-stu-id="70fa7-180">The C++ compiler produces "*no appropriate default constructor available*" for a projected type.</span></span> | <span data-ttu-id="70fa7-181">Wenn Sie versuchen, die Initialisierung einer Runtime-Klassenobjekt, verzögern zu nutzen, und implementieren eine Laufzeitklasse im selben Projekt, müssen Sie rufen Sie die `nullptr_t` Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="70fa7-181">If you're trying to delay the initialization of a runtime class object, or to consume and implement a runtime class in the same project, then you'll need to call the `nullptr_t` constructor.</span></span> <span data-ttu-id="70fa7-182">Weitere Informationen finden Sie unter [Nutzen von APIs mit C++/WinRT](consume-apis.md).</span><span class="sxs-lookup"><span data-stu-id="70fa7-182">For more info, see [Consume APIs with C++/WinRT](consume-apis.md).</span></span> |
| <span data-ttu-id="70fa7-183">Der C++ Compiler erzeugt "*Fehler C3861: 'From_abi': Bezeichner wurde nicht gefunden*", und andere Fehler *base.h*aus.</span><span class="sxs-lookup"><span data-stu-id="70fa7-183">The C++ compiler produces "*error C3861: 'from_abi': identifier not found*", and other errors originating in *base.h*.</span></span> <span data-ttu-id="70fa7-184">Dieser Fehler kann angezeigt werden, wenn Sie Visual Studio 2017 verwenden (Version 15.8.0 oder höher), und für das Windows SDK-Version 10.0.17134.0 (Windows 10, Version 1803).</span><span class="sxs-lookup"><span data-stu-id="70fa7-184">You may see this error if you are using Visual Studio 2017 (version 15.8.0 or higher), and targeting the Windows SDK version 10.0.17134.0 (Windows 10, version 1803).</span></span> | <span data-ttu-id="70fa7-185">Entweder als Ziel höher (größere Übereinstimmung) Version des Windows SDK oder der Set-Projekteigenschaft **C/C++-** > **Sprache** > **Konformitätsmodus: Nein** (auch, wenn **/ PERMISSIVE--** wird im Projekteigenschaft **C/C++-**  >  **Sprache** > **Befehlszeile** unter **Zusätzliche Optionen**, löschen Sie es).</span><span class="sxs-lookup"><span data-stu-id="70fa7-185">Either target a later (more conformant) version of the Windows SDK, or set project property **C/C++** > **Language** > **Conformance mode: No** (also, if **/permissive-** appears in project property **C/C++** > **Language** > **Command Line** under **Additional Options**, then delete it).</span></span> |
| <span data-ttu-id="70fa7-186">Der C++ Compiler erzeugt "*Fehler C2039: 'IUnknown': ist kein Mitglied des" \'global-Namespace "*".</span><span class="sxs-lookup"><span data-stu-id="70fa7-186">The C++ compiler produces "*error C2039: 'IUnknown': is not a member of '\`global namespace''*".</span></span> | <span data-ttu-id="70fa7-187">Finden Sie unter [wie neu zuweisen, Ihre C++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span><span class="sxs-lookup"><span data-stu-id="70fa7-187">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span></span> |
| <span data-ttu-id="70fa7-188">Der C++ Linker erzeugt "\*Fehler LNK2019: nicht aufgelöstes externes Symbol _WINRT_CanUnloadNow@0 verwiesen in Funktion _VSDesignerCanUnloadNow@0 \*"</span><span class="sxs-lookup"><span data-stu-id="70fa7-188">The C++ linker produces "*error LNK2019: unresolved external symbol _WINRT_CanUnloadNow@0 referenced in function _VSDesignerCanUnloadNow@0*"</span></span> | <span data-ttu-id="70fa7-189">Finden Sie unter [wie neu zuweisen, Ihre C++ / WinRT-Projekt auf eine neuere Version des Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span><span class="sxs-lookup"><span data-stu-id="70fa7-189">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span></span> |

> [!NOTE]
> <span data-ttu-id="70fa7-190">Wenn Ihre Frage in diesem Thema nicht beantwortet, und klicken Sie dann unter Hilfe Umständen finden Sie auf der [Visual Studio C++-Entwicklercommunity](https://developercommunity.visualstudio.com/spaces/62/index.html)oder mithilfe der [ `c++-winrt` -Tag auf Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span><span class="sxs-lookup"><span data-stu-id="70fa7-190">If this topic didn't answer your question, then you might find help by visiting the [Visual Studio C++ developer community](https://developercommunity.visualstudio.com/spaces/62/index.html), or by using the [`c++-winrt` tag on Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span></span>
