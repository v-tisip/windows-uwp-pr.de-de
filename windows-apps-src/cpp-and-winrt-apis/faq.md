---
author: stevewhims
description: Antworten auf Fragen zur Erstellung und Nutzung von Windows-Runtime-APIs mit C++/WinRT.
title: Häufig gestellte Fragen zu C++/WinRT
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, standard, c++, cpp, winrt, projektion, häufig, gestellte, fragen, faq
ms.localizationpriority: medium
ms.openlocfilehash: 5fe355c4ee4ee2dcc9d2e48130773e5632eb4a90
ms.sourcegitcommit: c4d3115348c8b54fcc92aae8e18fdabc3deb301d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/22/2018
ms.locfileid: "5409481"
---
# <a name="frequently-asked-questions-about-cwinrt"></a><span data-ttu-id="b13b7-104">Häufig gestellte Fragen zu C++/WinRT</span><span class="sxs-lookup"><span data-stu-id="b13b7-104">Frequently-asked questions about C++/WinRT</span></span>
<span data-ttu-id="b13b7-105">Antworten auf Fragen, die Sie wahrscheinlich zur Erstellung und Nutzung von Windows-Runtime-APIs mit werden [C++ / WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt).</span><span class="sxs-lookup"><span data-stu-id="b13b7-105">Answers to questions that you're likely to have about authoring and consuming Windows Runtime APIs with [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt).</span></span>

> [!NOTE]
> <span data-ttu-id="b13b7-106">Wenn Ihre Frage eine Fehlermeldung betrifft, die Sie gesehen haben, lesen Sie auch das Thema [Problembehandlung bei C++/WinRT](troubleshooting.md).</span><span class="sxs-lookup"><span data-stu-id="b13b7-106">If your question is about an error message that you've seen, then also see the [Troubleshooting C++/WinRT](troubleshooting.md) topic.</span></span>

## <a name="how-do-i-retarget-my-cwinrt-project-to-a-later-version-of-the-windows-sdk"></a><span data-ttu-id="b13b7-107">Wie I umgestellt Meine C++ / WinRT-Projekt auf eine neuere Version des Windows SDK?</span><span class="sxs-lookup"><span data-stu-id="b13b7-107">How do I retarget my C++/WinRT project to a later version of the Windows SDK?</span></span>

<span data-ttu-id="b13b7-108">Finden Sie unter [wie neu zuweisen, Ihre C++ / WinRT-Projekt auf eine neuere Version des Windows SDKS](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span><span class="sxs-lookup"><span data-stu-id="b13b7-108">See [How to retarget your C++/WinRT project to a later version of the Windows SDK](news.md#how-to-retarget-your-cwinrt-project-to-a-later-version-of-the-windows-sdk).</span></span>

## <a name="why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134"></a><span data-ttu-id="b13b7-109">Warum kompiliert nicht Mein neue Projekt?</span><span class="sxs-lookup"><span data-stu-id="b13b7-109">Why won't my new project compile?</span></span> <span data-ttu-id="b13b7-110">Ich verwende Visual Studio 2017 (Version 15.8.0 oder höher), und SDK-Version 17134</span><span class="sxs-lookup"><span data-stu-id="b13b7-110">I'm using Visual Studio 2017 (version 15.8.0 or higher), and SDK version 17134</span></span>

<span data-ttu-id="b13b7-111">Wenn Sie Visual Studio 2017 verwenden (Version 15.8.0 oder höher), und für das Windows SDK Version 10.0.17134.0 (Windows 10, Version 1803), klicken Sie dann eine neu erstellte C++ / WinRT-Projekt wird möglicherweise mit dem Fehler kompilieren "*Fehler C3861: 'From_abi': Bezeichner nicht gefunden*", und mit anderen Fehlern mit Ursprung in *base.h*.</span><span class="sxs-lookup"><span data-stu-id="b13b7-111">If you're using Visual Studio 2017 (version 15.8.0 or higher), and targeting the Windows SDK version 10.0.17134.0 (Windows 10, version 1803), then a newly created C++/WinRT project may fail to compile with the error "*error C3861: 'from_abi': identifier not found*", and with other errors originating in *base.h*.</span></span> <span data-ttu-id="b13b7-112">Die Lösung besteht darin, entweder Ziel höher (Weitere konform) Version des Windows SDK oder der Set-Projekteigenschaft **C/C++-** > **Sprache** > **Konformitätsmodus: Nein** (auch, wenn **/ PERMISSIVE--** erscheint in Projekteigenschaft \*\* C/C++\*\* > **Befehlszeile** unter **Zusätzliche Optionen**, löschen Sie ihn).</span><span class="sxs-lookup"><span data-stu-id="b13b7-112">The solution is to either target a later (more conformant) version of the Windows SDK, or set project property **C/C++** > **Language** > **Conformance mode: No** (also, if **/permissive-** appears in project property **C/C++** > **Command Line** under **Additional Options**, then delete it).</span></span>

## <a name="what-are-the-requirements-for-the-cwinrt-visual-studio-extension-vsixhttpsakamscppwinrtvsix"></a><span data-ttu-id="b13b7-113">Was sind die Voraussetzungen für die [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)?</span><span class="sxs-lookup"><span data-stu-id="b13b7-113">What are the requirements for the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)?</span></span>
<span data-ttu-id="b13b7-114">Das [VSIX](https://aka.ms/cppwinrt/vsix) erzwingt eine minimale Windows SDK-Zielversion von 10.0.17134.0 (Windows 10, Version 1803).</span><span class="sxs-lookup"><span data-stu-id="b13b7-114">The [VSIX](https://aka.ms/cppwinrt/vsix) enforces a minimum Windows SDK target version of 10.0.17134.0 (Windows 10, version 1803).</span></span> <span data-ttu-id="b13b7-115">Sie benötigen außerdem Visual Studio2017 (mindestens Version 15.6– wir empfehlen mindestens 15.7).</span><span class="sxs-lookup"><span data-stu-id="b13b7-115">You'll also need Visual Studio 2017 (at least version 15.6; we recommend at least 15.7).</span></span> <span data-ttu-id="b13b7-116">Sie können ein Projekt, das VSIX verwendet, durch das Vorhandensein von `<CppWinRTEnabled>true</CppWinRTEnabled>` in `<PropertyGroup Label="Globals">` in der Datei `.vcxproj` erkennen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-116">You can identify a project that uses the VSIX by the presence of `<CppWinRTEnabled>true</CppWinRTEnabled>` in `<PropertyGroup Label="Globals">` in the `.vcxproj` file.</span></span> <span data-ttu-id="b13b7-117">Weitere Informationen finden Sie unter [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span><span class="sxs-lookup"><span data-stu-id="b13b7-117">For more info, see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

## <a name="whats-a-runtime-class"></a><span data-ttu-id="b13b7-118">Was ist eine *Laufzeitklasse*?</span><span class="sxs-lookup"><span data-stu-id="b13b7-118">What's a *runtime class*?</span></span>
<span data-ttu-id="b13b7-119">Eine Laufzeitklasse ist ein Typ, der über moderne COM-Schnittstellen aktiviert und genutzt werden kann, typischerweise über Ausführungsgrenzen hinweg.</span><span class="sxs-lookup"><span data-stu-id="b13b7-119">A runtime class is a type that can be activated and consumed via modern COM interfaces, typically across executable boundaries.</span></span> <span data-ttu-id="b13b7-120">Eine Laufzeitklasse kann aber auch innerhalb der Kompiliereinheit verwendet werden, die sie implementiert.</span><span class="sxs-lookup"><span data-stu-id="b13b7-120">However, a runtime class can also be used within the compilation unit that implements it.</span></span> <span data-ttu-id="b13b7-121">Sie deklarieren eine Laufzeitklasse in der Interface Definition Language (IDL) und können sie in Standard C++ mit C++/WinRT implementieren.</span><span class="sxs-lookup"><span data-stu-id="b13b7-121">You declare a runtime class in Interface Definition Language (IDL), and you can implement it in standard C++ using C++/WinRT.</span></span>

## <a name="what-do-the-projected-type-and-the-implementation-type-mean"></a><span data-ttu-id="b13b7-122">Was bedeuten *der projizierte Typ* und *der Implementierungstyp*?</span><span class="sxs-lookup"><span data-stu-id="b13b7-122">What do *the projected type* and *the implementation type* mean?</span></span>
<span data-ttu-id="b13b7-123">Wenn Sie eine Windows-Runtime-Klasse (Laufzeitklasse) nur *verwenden*, dann arbeiten Sie ausschließlich mit *projizierten Typen*.</span><span class="sxs-lookup"><span data-stu-id="b13b7-123">If you're only *consuming* a Windows Runtime class (runtime class), then you'll be dealing exclusively with *projected types*.</span></span> <span data-ttu-id="b13b7-124">C++/WinRT ist eine *Sprachprojektion*. Projizierte Typen sind Teil der Oberfläche von Windows-Runtime, die über C++/WinRT auf C++ *projiziert* werden.</span><span class="sxs-lookup"><span data-stu-id="b13b7-124">C++/WinRT is a *language projection*, so projected types are part of the surface of the Windows Runtime that's *projected* into C++ with C++/WinRT.</span></span> <span data-ttu-id="b13b7-125">Weitere Details finden Sie unter [APIs mit C++/WinRT nutzen](consume-apis.md).</span><span class="sxs-lookup"><span data-stu-id="b13b7-125">For more details, see see [Consume APIs with C++/WinRT](consume-apis.md).</span></span>

<span data-ttu-id="b13b7-126">Der *Implementierungstyp* enthält die Implementierung einer Laufzeitklasse. Er ist also nur im Projekt verfügbar, das die Laufzeitklasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="b13b7-126">The *implementation type* contains the implementation of a runtime class, so it's only available in the project that implements the runtime class.</span></span> <span data-ttu-id="b13b7-127">Wenn Sie in einem Projekt arbeiten, das Laufzeitklassen implementiert (ein Projekt für eine Komponente für Windows-Runtime oder ein Projekt, das XAML-UI verwendet), ist es wichtig, sich mit der Unterscheidung zwischen Ihrem Implementierungstyp für eine Laufzeitklasse und dem projizierten Typ, der die in C++/WinRT projizierte Laufzeitklasse repräsentiert, vertraut zu machen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-127">When you're working in a project that implements runtime classes (a Windows Runtime component project, or a project that uses XAML UI), it's important to be comfortable with the distinction between your implementation type for a runtime class, and the projected type that represents the runtime class projected into C++/WinRT.</span></span> <span data-ttu-id="b13b7-128">Weitere Details finden Sie unter [APIs mit C++/WinRT erstellen](author-apis.md).</span><span class="sxs-lookup"><span data-stu-id="b13b7-128">For more details, see [Author APIs with C++/WinRT](author-apis.md).</span></span>

## <a name="do-i-need-to-declare-a-constructor-in-my-runtime-classs-idl"></a><span data-ttu-id="b13b7-129">Muss ich einen Konstruktor in der IDL meiner Laufzeitklasse deklarieren?</span><span class="sxs-lookup"><span data-stu-id="b13b7-129">Do I need to declare a constructor in my runtime class's IDL?</span></span>
<span data-ttu-id="b13b7-130">Nur wenn die Laufzeitklasse so konzipiert ist, dass sie von außerhalb ihrer implementierenden Kompiliereinheit verwendet werden kann (es handelt sich um eine Komponente für Windows-Runtime, die für den allgemeinen Gebrauch durch Windows-Runtime-Clientanwendungen bestimmt ist).</span><span class="sxs-lookup"><span data-stu-id="b13b7-130">Only if the runtime class is designed to be consumed from outside its implementing compilation unit (it's a Windows Runtime component intended for general consumption by Windows Runtime client apps).</span></span> <span data-ttu-id="b13b7-131">Ausführliche Informationen über den Zweck und die Konsequenzen der Deklaration von Konstruktoren in IDL finden Sie unter [Runtime-Klassenkonstruktoren](author-apis.md#runtime-class-constructors).</span><span class="sxs-lookup"><span data-stu-id="b13b7-131">For full details on the purpose and consequences of declaring constructor(s) in IDL, see [Runtime class constructors](author-apis.md#runtime-class-constructors).</span></span>

## <a name="why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error"></a><span data-ttu-id="b13b7-132">Warum gibt der Linker den Fehler „LNK2019: Nicht aufgelöstes externes Symbol“ aus?</span><span class="sxs-lookup"><span data-stu-id="b13b7-132">Why is the linker giving me a "LNK2019: Unresolved external symbol" error?</span></span>
<span data-ttu-id="b13b7-133">Wenn es sich bei dem nicht aufgelösten Symbol um eine API aus den Windows-Namespace-Headern für die C++/WinRT-Projektion (im **Winrt**-Namespace) handelt, ist die API in einem Header forward-deklariert, den Sie eingeschlossen haben, ihre Definition befindet sich aber in einem Header, der noch nicht hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="b13b7-133">If the unresolved symbol is an API from the Windows namespace headers for the C++/WinRT projection (in the **winrt** namespace), then the API is forward-declared in a header that you've included, but its definition is in a header that you haven't yet included.</span></span> <span data-ttu-id="b13b7-134">Binden Sie den Header ein, der für den Namespace der API benannt ist, und führen Sie eine erneute Erstellung durch.</span><span class="sxs-lookup"><span data-stu-id="b13b7-134">Include the header named for the API's namespace, and rebuild.</span></span> <span data-ttu-id="b13b7-135">Weitere Informationen finden Sie unter [C++/WinRT-Projektionsheader](consume-apis.md#cwinrt-projection-headers).</span><span class="sxs-lookup"><span data-stu-id="b13b7-135">For more info, see [C++/WinRT projection headers](consume-apis.md#cwinrt-projection-headers).</span></span>

<span data-ttu-id="b13b7-136">Wenn das nicht aufgelöste Symbol um eine freie Windows-Runtime-Funktion, z. B. [RoInitialize](https://msdn.microsoft.com/library/br224650)ist, müssen Sie explizit die überbibliothek ["windowsapp.lib"](/uwp/win32-and-com/win32-apis) in Ihrem Projekt zu verknüpfen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-136">If the unresolved symbol is a Windows Runtime free function, such as [RoInitialize](https://msdn.microsoft.com/library/br224650), then you'll need to explicitly link the [WindowsApp.lib](/uwp/win32-and-com/win32-apis) umbrella library in your project.</span></span> <span data-ttu-id="b13b7-137">Die C++/WinRT-Projektion hängt von einigen dieser freien (Nicht-Mitglieds)-Funktionen und Einstiegspunkten ab.</span><span class="sxs-lookup"><span data-stu-id="b13b7-137">The C++/WinRT projection depends on some of these free (non-member) functions and entry points.</span></span> <span data-ttu-id="b13b7-138">Wenn Sie eine der [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)-Projektvorlagen für Ihre Anwendung verwenden, wird `WindowsApp.lib` automatisch für Sie verknüpft.</span><span class="sxs-lookup"><span data-stu-id="b13b7-138">If you use one of the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix) project templates for your application, then `WindowsApp.lib` is linked for you automatically.</span></span> <span data-ttu-id="b13b7-139">Andernfalls können Sie die Projektlinkeinstellungen verwenden, um sie einzuschließen, oder dies im Quellcode erledigen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-139">Otherwise, you can use project link settings to include it, or do it in source code.</span></span>

```cppwinrt
#pragma comment(lib, "windowsapp")
```

<span data-ttu-id="b13b7-140">Wir empfehlen, dass Sie alle Linkerfehler, die Sie auflösen über die Verknüpfung **"windowsapp.lib"** können.</span><span class="sxs-lookup"><span data-stu-id="b13b7-140">We do recommend that you resolve any linker errors that you can by linking **WindowsApp.lib**.</span></span> <span data-ttu-id="b13b7-141">Aber wenn Sie nicht, dass Ihre Anwendung benötigen auf der [Windows-Zertifizierungskit](../debug-test-perf/windows-app-certification-kit.md) Tests von Visual Studio und vom Microsoft Store Überprüfungszwecke verwendet, Übermittlungen (d. h., die es daher möglich, dass die Anwendung erfolgreich werden nicht mehr aufgenommen in den Microsoft Store), und klicken Sie dann Sie stattdessen eine alternative Static Link Bibliothek verknüpfen können.</span><span class="sxs-lookup"><span data-stu-id="b13b7-141">But, if you don't need your application to pass the [Windows App Certification Kit](../debug-test-perf/windows-app-certification-kit.md) tests used by Visual Studio and by the Microsoft Store to validate submissions (meaning that it consequently won't be possible for your application to be successfully ingested into the Microsoft Store), then you can link an alternative static-link library instead.</span></span> <span data-ttu-id="b13b7-142">Beispielsweise bezieht sich Ihre Linkerfehler auf **CoIncrementMTAUsage** (oder **WINRT_CoIncrementMTAUsage**), können Sie auflösen, die durch Ole32.lib verknüpfen, wenn es unbedingt erforderlich (z. B., wenn Ihre Version von **"windowsapp.lib"** nicht Exportieren Sie die Funktion).</span><span class="sxs-lookup"><span data-stu-id="b13b7-142">For example, if your linker error refers to **CoIncrementMTAUsage** (or **WINRT_CoIncrementMTAUsage**), then you can resolve that by linking Ole32.lib if absolutely necessary (for example, if your version of **WindowsApp.lib** doesn't export the function).</span></span>

## <a name="should-i-implement-windowsfoundationiclosableuwpapiwindowsfoundationiclosable-and-if-so-how"></a><span data-ttu-id="b13b7-143">Sollte ich [**Windows::Foundation::IClosable**](/uwp/api/windows.foundation.iclosable) implementieren und wenn ja, wie?</span><span class="sxs-lookup"><span data-stu-id="b13b7-143">Should I implement [**Windows::Foundation::IClosable**](/uwp/api/windows.foundation.iclosable) and, if so, how?</span></span>
<span data-ttu-id="b13b7-144">Wenn Sie eine Laufzeitklasse haben, die Ressourcen in ihrem Destruktor freigibt, und diese Laufzeitklasse dafür ausgelegt ist außerhalb ihrer implementierenden Kompiliereinheit genutzt zu werden (eine Komponente für Windows-Runtime, die für die allgemeinen Nutzung durch Windows-Runtime-Clientanwendungen bestimmt ist), dann empfehlen wir Ihnen,\*\* IClosable\*\* zu implementieren, um die Nutzung Ihrer Laufzeitklasse durch Sprachen ohne deterministische Finalisierung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-144">If you have a runtime class that frees resources in its destructor, and that runtime class is designed to be consumed from outside its implementing compilation unit (it's a Windows Runtime component intended for general consumption by Windows Runtime client apps), then we recommend that you also implement **IClosable** in order to support the consumption of your runtime class by languages that lack deterministic finalization.</span></span> <span data-ttu-id="b13b7-145">Stellen Sie sicher, dass Ihre Ressourcen freigegeben werden – egal ob der Destruktor, [**IClosable::Close**](/uwp/api/windows.foundation.iclosable.Close) oder beide aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="b13b7-145">Make sure that your resources are freed whether the destructor, [**IClosable::Close**](/uwp/api/windows.foundation.iclosable.Close), or both are called.</span></span> <span data-ttu-id="b13b7-146">**IClosable::Close** kann beliebig oft aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="b13b7-146">**IClosable::Close** may be called an arbitrary number of times.</span></span>

## <a name="do-i-need-to-call-iclosablecloseuwpapiwindowsfoundationiclosablewindowsfoundationiclosableclose-on-runtime-classes-that-i-consume"></a><span data-ttu-id="b13b7-147">Muss ich [**IClosable::Close**](/uwp/api/windows.foundation.iclosable#Windows_Foundation_IClosable_Close_) bei Laufzeitklassen aufrufen, die ich nutze?</span><span class="sxs-lookup"><span data-stu-id="b13b7-147">Do I need to call [**IClosable::Close**](/uwp/api/windows.foundation.iclosable#Windows_Foundation_IClosable_Close_) on runtime classes that I consume?</span></span>
<span data-ttu-id="b13b7-148">**IClosable** existiert, um Sprachen zu unterstützen, die keine deterministische Finalisierung haben.</span><span class="sxs-lookup"><span data-stu-id="b13b7-148">**IClosable** exists to support languages that lack deterministic finalization.</span></span> <span data-ttu-id="b13b7-149">Daher sollten Sie **IClosable::Close** nicht von C++/WinRT aus aufrufen, außer in sehr seltenen Fällen, in denen es um Shutdown-Races oder halb Semi-Deadocks geht.</span><span class="sxs-lookup"><span data-stu-id="b13b7-149">So, you shouldn't call **IClosable::Close** from C++/WinRT, except in very rare cases involving shutdown races or semi-deadly embraces.</span></span> <span data-ttu-id="b13b7-150">Wenn Sie z. B.\*\* Windows.UI.Composition\*\*-Typen verwenden, können Sie auf Fälle stoßen, in denen Sie Objekte in einer festgelegten Reihenfolge verwerfen möchten (statt dies durch den C++/WinRT-Wrapper erledigen zu lassen).</span><span class="sxs-lookup"><span data-stu-id="b13b7-150">If you're using **Windows.UI.Composition** types, as an example, then you may encounter cases where you want to dispose objects in a set sequence, as an alternative to allowing the destruction of the C++/WinRT wrapper do the work for you.</span></span>

## <a name="can-i-use-llvmclang-to-compile-with-cwinrt"></a><span data-ttu-id="b13b7-151">Kann ich LLVM/Clang verwenden, um mit C++/WinRT zu kompilieren?</span><span class="sxs-lookup"><span data-stu-id="b13b7-151">Can I use LLVM/Clang to compile with C++/WinRT?</span></span>
<span data-ttu-id="b13b7-152">Die Toolkette LLVM und Clang wird für C++/WinRT nicht unterstützt, aber wir verwenden sie intern, um die Standardkonformität von C++/WinRT zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-152">We don't support the LLVM and Clang toolchain for C++/WinRT, but we do make use of it internally to validate C++/WinRT's standards conformance.</span></span> <span data-ttu-id="b13b7-153">Wenn Sie z.B. emulieren möchten, was wir intern tun, könnten Sie ein Experiment wie das unten beschriebene ausprobieren.</span><span class="sxs-lookup"><span data-stu-id="b13b7-153">For example, if you wanted to emulate what we do internally, then you could try an experiment such as the one described below.</span></span>

<span data-ttu-id="b13b7-154">Wechseln Sie zur [LLVM-Download-Seite](https://releases.llvm.org/download.html), suchen Sie nach **Download LLVM 6.0.0** > **Pre-Built Binaries**, und laden Sie **Clang for Windows (64-bit)** herunter.</span><span class="sxs-lookup"><span data-stu-id="b13b7-154">Go to the [LLVM Download Page](https://releases.llvm.org/download.html), look for **Download LLVM 6.0.0** > **Pre-Built Binaries**, and download **Clang for Windows (64-bit)**.</span></span> <span data-ttu-id="b13b7-155">Geben Sie während der Installation an, dass LLVM zur Systemvariablen PATH hinzugefügt werden soll, sodass Sie in der Lage sind, sie von einer Befehlszeile aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-155">During installation, opt to add LLVM to the PATH system variable so that you'll be able to invoke it from a command prompt.</span></span> <span data-ttu-id="b13b7-156">Für die Zwecke dieses Experiments können Sie die Meldungen, dass das Verzeichnis für die MSBuild-Toolsets nicht gefunden werden konnte und/oder dass die MSVC-Integrationsinstallation fehlgeschlagen ist, ignorieren (sollten diese angezeigt werden).</span><span class="sxs-lookup"><span data-stu-id="b13b7-156">For the purposes of this experiment, you can ignore any "Failed to find MSBuild toolsets directory" and/or "MSVC integration install failed" errors, if you see them.</span></span> <span data-ttu-id="b13b7-157">Es gibt verschiedene Möglichkeiten zum Aufrufen von LLVM/Clang. Das folgende Beispiel zeigt nur eine davon.</span><span class="sxs-lookup"><span data-stu-id="b13b7-157">There are a variety of ways to invoke LLVM/Clang; the example below shows just one way.</span></span>

```
C:\ExperimentWithLLVMClang>type main.cpp
// main.cpp
#pragma comment(lib, "windowsapp")
#pragma comment(lib, "ole32")

#include <winrt/Windows.Foundation.h>
#include <stdio.h>
#include <iostream>

using namespace winrt;

int main()
{
    winrt::init_apartment();
    Windows::Foundation::Uri rssFeedUri{ L"https://blogs.windows.com/feed" };
    std::wcout << rssFeedUri.Domain().c_str() << std::endl;
}

C:\ExperimentWithLLVMClang>clang-cl main.cpp /EHsc /I ..\.. -Xclang -std=c++17 -Xclang -Wno-delete-non-virtual-dtor -o app.exe

C:\ExperimentWithLLVMClang>app
windows.com
```

<span data-ttu-id="b13b7-158">Da C++/WinRT Features vom C++17-Standard verwendet, müssen Sie alle Compiler-Flags verwenden, die erforderlich sind, um diese Unterstützung zu erhalten. Diese Flags sind je nach Compiler unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="b13b7-158">Because C++/WinRT uses features from the C++17 standard, you'll need to use whatever compiler flags are necessary to get that support; such flags differ from one compiler to another.</span></span>

<span data-ttu-id="b13b7-159">Visual Studio ist das Entwicklungstool, das wir unterstützen und für C++/WinRT empfehlen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-159">Visual Studio is the development tool that we support and recommend for C++/WinRT.</span></span> <span data-ttu-id="b13b7-160">Weitere Informationen finden Sie unter [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span><span class="sxs-lookup"><span data-stu-id="b13b7-160">See [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

## <a name="why-doesnt-the-generated-implementation-function-for-a-read-only-property-have-the-const-qualifier"></a><span data-ttu-id="b13b7-161">Warum nicht die Funktion generierten Implementierung für eine schreibgeschützte Eigenschaft hat die `const` Qualifizierer?</span><span class="sxs-lookup"><span data-stu-id="b13b7-161">Why doesn't the generated implementation function for a read-only property have the `const` qualifier?</span></span>

<span data-ttu-id="b13b7-162">Wenn Sie eine schreibgeschützte Eigenschaft in [MIDL 3.0](/uwp/midl-3/)deklarieren, können Sie davon ausgehen, dass die `cppwinrt.exe` -Tool zum Generieren von einer Funktion Implementierung für Sie, die `const`-qualifizierte (eine const Funktion behandelt den *diesem* Zeiger als const).</span><span class="sxs-lookup"><span data-stu-id="b13b7-162">When you declare a read-only property in [MIDL 3.0](/uwp/midl-3/), you might expect the `cppwinrt.exe` tool to generate an implementation function for you that is `const`-qualified (a const function treats the *this* pointer as const).</span></span>

<span data-ttu-id="b13b7-163">Sicherlich empfohlen Const verwenden, wann immer möglich, aber die `cppwinrt.exe` Tool selbst nicht versuchen, Grund, warum über die Implementierung Funktionen u. u. tatsächlich const werden und die möglicherweise nicht.</span><span class="sxs-lookup"><span data-stu-id="b13b7-163">We certainly recommend using const wherever possible, but the `cppwinrt.exe` tool itself doesn't attempt to reason about which implementation functions might conceivably be const, and which might not.</span></span> <span data-ttu-id="b13b7-164">Sie können festlegen, dass alle Ihre Implementierungsfunktionen const, wie im folgenden Beispiel.</span><span class="sxs-lookup"><span data-stu-id="b13b7-164">You can choose to make any of your implementation functions const, as in this example.</span></span>

```cppwinrt
struct MyStringable : winrt::implements<MyStringable, winrt::Windows::Foundation::IStringable>
{
    winrt::hstring ToString() const
    {
        return L"MyStringable";
    }
};
```

<span data-ttu-id="b13b7-165">Sie können entfernen, die `const` Qualifizierer auf **ToString** sollten Sie entscheiden, dass Sie einige Objektzustand in ihrer Implementierung ändern müssen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-165">You can remove that `const` qualifier on **ToString** should you decide that you need to alter some object state in its implementation.</span></span> <span data-ttu-id="b13b7-166">Es sollte jedoch darauf aller Ihrer Member Funktionen const oder nicht konstanter nicht beides.</span><span class="sxs-lookup"><span data-stu-id="b13b7-166">But make each of your member functions either const or non-const, not both.</span></span> <span data-ttu-id="b13b7-167">Anders ausgedrückt, nicht überladen, eine Implementierung Funktion auf `const`.</span><span class="sxs-lookup"><span data-stu-id="b13b7-167">In other words, don't overload an implementation function on `const`.</span></span>

<span data-ttu-id="b13b7-168">Abgesehen von der Implementierungsfunktionen, ein anderes andere dort, wo const wird das Bild in Windows-Runtime-Funktion Projektionen ist.</span><span class="sxs-lookup"><span data-stu-id="b13b7-168">Aside from your implementation functions, another other place where const comes into the picture is in Windows Runtime function projections.</span></span> <span data-ttu-id="b13b7-169">Betrachten Sie diesen Code.</span><span class="sxs-lookup"><span data-stu-id="b13b7-169">Consider this code.</span></span>

```cppwinrt
int main()
{
    winrt::Windows::Foundation::IStringable s{ winrt::make<MyStringable>() };
    auto result{ s.ToString() };
}
```

<span data-ttu-id="b13b7-170">Für den Aufruf von **ToString** oben, der Befehl **Gehe zu Deklaration** in Visual Studio zeigt, dass die Projektion der Windows-Runtime- **istringable:: ToString** in C++ / WinRT sieht wie folgt aus.</span><span class="sxs-lookup"><span data-stu-id="b13b7-170">For the call to **ToString** above, the **Go To Declaration** command in Visual Studio shows that the projection of the Windows Runtime **IStringable::ToString** into C++/WinRT looks like this.</span></span>

```
winrt::hstring ToString() const;
```

<span data-ttu-id="b13b7-171">Funktionen in der Projektion sind const unabhängig davon, wie Sie Ihre Implementierung von ihnen zu qualifizieren.</span><span class="sxs-lookup"><span data-stu-id="b13b7-171">Functions on the projection are const no matter how you choose to qualify your implementation of them.</span></span> <span data-ttu-id="b13b7-172">Hinter den Kulissen Ruft die Projektion auf der binären Anwendungsschnittstelle (ABI), welche Mengen an einen Aufruf über eine COM-Interface-Zeiger.</span><span class="sxs-lookup"><span data-stu-id="b13b7-172">Behind the scenes, the projection calls the application binary interface (ABI), which amounts to a call through a COM interface pointer.</span></span> <span data-ttu-id="b13b7-173">Der einzige Zustand, mit dem die projizierte **ToString** interagiert ist, das diesem Zeiger COM-Schnittstelle. und natürlich keine Notwendigkeit, das diesem Zeiger zu ändern, so dass die Funktion konstant ist verfügt.</span><span class="sxs-lookup"><span data-stu-id="b13b7-173">The only state that the projected **ToString** interacts with is that COM interface pointer; and it certainly has no need to modify that pointer, so the function is const.</span></span> <span data-ttu-id="b13b7-174">Dieses können Sie den Sicherstellung, dass es sich nicht über die **IStringable** -Referenz, der Sie ändert durch Aufrufen, und es wird sichergestellt, dass Sie auch mit einem Const **ToString** aufrufen können, ein **IStringable**verweisen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-174">This gives you the assurance that it won't change anything about the **IStringable** reference that you're calling through, and it ensures that you can call **ToString** even with a const reference to an **IStringable**.</span></span>

<span data-ttu-id="b13b7-175">Zu verstehen, die diese Beispiele für `const` sind Details zur Implementierung von C++ / WinRT Projektionen und Implementierungen; Sie bilden Code Hygienevorschriften für Ihre Vorteile.</span><span class="sxs-lookup"><span data-stu-id="b13b7-175">Understand that these examples of `const` are implementation details of C++/WinRT projections and implementations; they constitute code hygiene for your benefit.</span></span> <span data-ttu-id="b13b7-176">Es gibt keine `const` auf die COM- noch die Windows-Runtime-ABI (für Memberfunktion).</span><span class="sxs-lookup"><span data-stu-id="b13b7-176">There's no such thing as `const` on the COM nor Windows Runtime ABI (for member functions).</span></span>

## <a name="do-you-have-any-recommendations-for-decreasing-the-code-size-for-cwinrt-binaries"></a><span data-ttu-id="b13b7-177">Haben Sie alle Empfehlungen zur Verringerung der Codegröße für C++ / WinRT-Binärdateien?</span><span class="sxs-lookup"><span data-stu-id="b13b7-177">Do you have any recommendations for decreasing the code size for C++/WinRT binaries?</span></span>

<span data-ttu-id="b13b7-178">Bei der Arbeit mit Windows-Runtime-Objekten vermeiden Sie das Codierungsmuster unten dargestellt, da es eine negative Auswirkung auf Ihre Anwendung aufweisen kann, indem verursacht Weitere Binärcode als nötig, generiert werden.</span><span class="sxs-lookup"><span data-stu-id="b13b7-178">When working with Windows Runtime objects, you should avoid the coding pattern shown below because it can have a negative impact on your application by causing more binary code than necessary to be generated.</span></span>

```cppwinrt
anobject.b().c().d();
anobject.b().c().e();
anobject.b().c().f();
```

<span data-ttu-id="b13b7-179">Der Compiler kann entweder den Wert der Zwischenspeichern in der Windows-Runtime-Welt `c()` oder die Schnittstellen für jede Methode, die durch eine Dereferenzierung aufgerufen wird ('. ').</span><span class="sxs-lookup"><span data-stu-id="b13b7-179">In the Windows Runtime world, the compiler is unable to cache either the value of `c()` or the interfaces for each method that's called through an indirection ('.').</span></span> <span data-ttu-id="b13b7-180">Es sei denn, Sie eingreifen führt, die weitere virtuelle Aufrufe und referenzzählung Aufwand.</span><span class="sxs-lookup"><span data-stu-id="b13b7-180">Unless you intervene, that results in more virtual calls and reference counting overhead.</span></span> <span data-ttu-id="b13b7-181">Die oben genannten Muster konnte leicht doppelt so viel Code wie unbedingt notwendig generiert werden.</span><span class="sxs-lookup"><span data-stu-id="b13b7-181">The pattern above could easily generate twice as much code as strictly needed.</span></span> <span data-ttu-id="b13b7-182">Bevorzugen Sie stattdessen das Muster unten überall können.</span><span class="sxs-lookup"><span data-stu-id="b13b7-182">Instead, prefer the pattern shown below wherever you can.</span></span> <span data-ttu-id="b13b7-183">Es viel weniger Code generiert, und es kann auch erheblich verbessern der Leistung Ihrer zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="b13b7-183">It generates a lot less code, and it can also dramatically improve your run time performance.</span></span>

```cppwinrt
auto a{ anobject.b().c() };
a.d();
a.e();
a.f();
```

<span data-ttu-id="b13b7-184">Die empfohlene oben gezeigte Muster gilt nicht nur für C++ / WinRT jedoch auf alle Windows-Runtime-sprachprojektionen.</span><span class="sxs-lookup"><span data-stu-id="b13b7-184">The recommended pattern shown above applies not just to C++/WinRT but to all Windows Runtime language projections.</span></span>

> [!NOTE]
> <span data-ttu-id="b13b7-185">Wenn Ihre Frage in diesem Thema nicht beantwortet, und klicken Sie dann unter Hilfe Umständen finden Sie auf der [Visual Studio C++-Entwicklercommunity](https://developercommunity.visualstudio.com/spaces/62/index.html)oder mithilfe der [ `c++-winrt` -Tag auf Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span><span class="sxs-lookup"><span data-stu-id="b13b7-185">If this topic didn't answer your question, then you might find help by visiting the [Visual Studio C++ developer community](https://developercommunity.visualstudio.com/spaces/62/index.html), or by using the [`c++-winrt` tag on Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span></span>
