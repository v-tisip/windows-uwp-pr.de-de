---
author: stevewhims
description: Antworten auf Fragen zur Erstellung und Nutzung von Windows-Runtime-APIs mit C++/WinRT.
title: Häufig gestellte Fragen zu C++/WinRT
ms.author: stwhi
ms.date: 05/07/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: windows 10, uwp, standard, c++, cpp, winrt, projektion, häufig, gestellte, fragen, faq
ms.localizationpriority: medium
ms.openlocfilehash: 9316a29a50970bdaa288a4744f3aab7d873cbe4e
ms.sourcegitcommit: 68fcac3288d5698a13dbcbd57f51b30592f24860
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/19/2018
ms.locfileid: "4057938"
---
# <a name="frequently-asked-questions-about-cwinrtwindowsuwpcpp-and-winrt-apisintro-to-using-cpp-with-winrt"></a><span data-ttu-id="3181e-104">Häufig gestellte Fragen zu [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)</span><span class="sxs-lookup"><span data-stu-id="3181e-104">Frequently-asked questions about [C++/WinRT](/windows/uwp/cpp-and-winrt-apis/intro-to-using-cpp-with-winrt)</span></span>
<span data-ttu-id="3181e-105">Antworten auf Fragen zur Erstellung und Nutzung von Windows-Runtime-APIs mit C++/WinRT.</span><span class="sxs-lookup"><span data-stu-id="3181e-105">Answers to questions that you're likely to have about authoring and consuming Windows Runtime APIs with C++/WinRT.</span></span>

> [!NOTE]
> <span data-ttu-id="3181e-106">Wenn Ihre Frage eine Fehlermeldung betrifft, die Sie gesehen haben, lesen Sie auch das Thema [Problembehandlung bei C++/WinRT](troubleshooting.md).</span><span class="sxs-lookup"><span data-stu-id="3181e-106">If your question is about an error message that you've seen, then also see the [Troubleshooting C++/WinRT](troubleshooting.md) topic.</span></span>

## <a name="why-wont-my-new-project-compile-im-using-visual-studio-2017-version-1580-or-higher-and-sdk-version-17134"></a><span data-ttu-id="3181e-107">Warum kompiliert nicht Mein neue Projekt?</span><span class="sxs-lookup"><span data-stu-id="3181e-107">Why won't my new project compile?</span></span> <span data-ttu-id="3181e-108">Ich verwende Visual Studio 2017 (Version 15.8.0 oder höher), und SDK-Version 17134</span><span class="sxs-lookup"><span data-stu-id="3181e-108">I'm using Visual Studio 2017 (version 15.8.0 or higher), and SDK version 17134</span></span>

<span data-ttu-id="3181e-109">Wenn Sie Visual Studio 2017 verwenden (Version 15.8.0 oder höher), und für das Windows SDK-Version 10.0.17134.0 (Windows 10, Version 1803), klicken Sie dann eine neu erstellte C++ / WinRT-Projekt möglicherweise nicht mit dem Fehler kompilieren "*Fehler C3861: 'From_abi': Bezeichner nicht gefunden*", und mit anderen sein, der aus *base.h*Fehlern.</span><span class="sxs-lookup"><span data-stu-id="3181e-109">If you're using Visual Studio 2017 (version 15.8.0 or higher), and targeting the Windows SDK version 10.0.17134.0 (Windows 10, version 1803), then a newly created C++/WinRT project may fail to compile with the error "*error C3861: 'from_abi': identifier not found*", and with other errors originating in *base.h*.</span></span> <span data-ttu-id="3181e-110">Die Lösung besteht darin, entweder Ziel höher (größere Übereinstimmung) Version des Windows SDK oder der Set-Projekteigenschaft **C/C++-** > **Sprache** > **Konformitätsmodus: Nein** (auch, wenn **/ PERMISSIVE--** wird im Projekteigenschaft \*\* C/C++\*\* > **Sprache** > **Befehlszeile** unter **Zusätzliche Optionen**, löschen Sie es).</span><span class="sxs-lookup"><span data-stu-id="3181e-110">The solution is to either target a later (more conformant) version of the Windows SDK, or set project property **C/C++** > **Language** > **Conformance mode: No** (also, if **/permissive-** appears in project property **C/C++** > **Language** > **Command Line** under **Additional Options**, then delete it).</span></span>

## <a name="what-are-the-requirements-for-the-cwinrt-visual-studio-extension-vsixhttpsakamscppwinrtvsix"></a><span data-ttu-id="3181e-111">Was sind die Voraussetzungen für die [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)?</span><span class="sxs-lookup"><span data-stu-id="3181e-111">What are the requirements for the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)?</span></span>
<span data-ttu-id="3181e-112">Das [VSIX](https://aka.ms/cppwinrt/vsix) erzwingt eine minimale Windows SDK-Zielversion von 10.0.17134.0 (Windows 10, Version 1803).</span><span class="sxs-lookup"><span data-stu-id="3181e-112">The [VSIX](https://aka.ms/cppwinrt/vsix) enforces a minimum Windows SDK target version of 10.0.17134.0 (Windows 10, version 1803).</span></span> <span data-ttu-id="3181e-113">Sie benötigen außerdem Visual Studio2017 (mindestens Version 15.6– wir empfehlen mindestens 15.7).</span><span class="sxs-lookup"><span data-stu-id="3181e-113">You'll also need Visual Studio 2017 (at least version 15.6; we recommend at least 15.7).</span></span> <span data-ttu-id="3181e-114">Sie können ein Projekt, das VSIX verwendet, durch das Vorhandensein von `<CppWinRTEnabled>true</CppWinRTEnabled>` in `<PropertyGroup Label="Globals">` in der Datei `.vcxproj` erkennen.</span><span class="sxs-lookup"><span data-stu-id="3181e-114">You can identify a project that uses the VSIX by the presence of `<CppWinRTEnabled>true</CppWinRTEnabled>` in `<PropertyGroup Label="Globals">` in the `.vcxproj` file.</span></span> <span data-ttu-id="3181e-115">Weitere Informationen finden Sie unter [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span><span class="sxs-lookup"><span data-stu-id="3181e-115">For more info, see [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

## <a name="whats-a-runtime-class"></a><span data-ttu-id="3181e-116">Was ist eine *Laufzeitklasse*?</span><span class="sxs-lookup"><span data-stu-id="3181e-116">What's a *runtime class*?</span></span>
<span data-ttu-id="3181e-117">Eine Laufzeitklasse ist ein Typ, der über moderne COM-Schnittstellen aktiviert und genutzt werden kann, typischerweise über Ausführungsgrenzen hinweg.</span><span class="sxs-lookup"><span data-stu-id="3181e-117">A runtime class is a type that can be activated and consumed via modern COM interfaces, typically across executable boundaries.</span></span> <span data-ttu-id="3181e-118">Eine Laufzeitklasse kann aber auch innerhalb der Kompiliereinheit verwendet werden, die sie implementiert.</span><span class="sxs-lookup"><span data-stu-id="3181e-118">However, a runtime class can also be used within the compilation unit that implements it.</span></span> <span data-ttu-id="3181e-119">Sie deklarieren eine Laufzeitklasse in der Interface Definition Language (IDL) und können sie in Standard C++ mit C++/WinRT implementieren.</span><span class="sxs-lookup"><span data-stu-id="3181e-119">You declare a runtime class in Interface Definition Language (IDL), and you can implement it in standard C++ using C++/WinRT.</span></span>

## <a name="what-do-the-projected-type-and-the-implementation-type-mean"></a><span data-ttu-id="3181e-120">Was bedeuten *der projizierte Typ* und *der Implementierungstyp*?</span><span class="sxs-lookup"><span data-stu-id="3181e-120">What do *the projected type* and *the implementation type* mean?</span></span>
<span data-ttu-id="3181e-121">Wenn Sie eine Windows-Runtime-Klasse (Laufzeitklasse) nur *verwenden*, dann arbeiten Sie ausschließlich mit *projizierten Typen*.</span><span class="sxs-lookup"><span data-stu-id="3181e-121">If you're only *consuming* a Windows Runtime class (runtime class), then you'll be dealing exclusively with *projected types*.</span></span> <span data-ttu-id="3181e-122">C++/WinRT ist eine *Sprachprojektion*. Projizierte Typen sind Teil der Oberfläche von Windows-Runtime, die über C++/WinRT auf C++ *projiziert* werden.</span><span class="sxs-lookup"><span data-stu-id="3181e-122">C++/WinRT is a *language projection*, so projected types are part of the surface of the Windows Runtime that's *projected* into C++ with C++/WinRT.</span></span> <span data-ttu-id="3181e-123">Weitere Details finden Sie unter [APIs mit C++/WinRT nutzen](consume-apis.md).</span><span class="sxs-lookup"><span data-stu-id="3181e-123">For more details, see see [Consume APIs with C++/WinRT](consume-apis.md).</span></span>

<span data-ttu-id="3181e-124">Der *Implementierungstyp* enthält die Implementierung einer Laufzeitklasse. Er ist also nur im Projekt verfügbar, das die Laufzeitklasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="3181e-124">The *implementation type* contains the implementation of a runtime class, so it's only available in the project that implements the runtime class.</span></span> <span data-ttu-id="3181e-125">Wenn Sie in einem Projekt arbeiten, das Laufzeitklassen implementiert (ein Projekt für eine Komponente für Windows-Runtime oder ein Projekt, das XAML-UI verwendet), ist es wichtig, sich mit der Unterscheidung zwischen Ihrem Implementierungstyp für eine Laufzeitklasse und dem projizierten Typ, der die in C++/WinRT projizierte Laufzeitklasse repräsentiert, vertraut zu machen.</span><span class="sxs-lookup"><span data-stu-id="3181e-125">When you're working in a project that implements runtime classes (a Windows Runtime component project, or a project that uses XAML UI), it's important to be comfortable with the distinction between your implementation type for a runtime class, and the projected type that represents the runtime class projected into C++/WinRT.</span></span> <span data-ttu-id="3181e-126">Weitere Details finden Sie unter [APIs mit C++/WinRT erstellen](author-apis.md).</span><span class="sxs-lookup"><span data-stu-id="3181e-126">For more details, see [Author APIs with C++/WinRT](author-apis.md).</span></span>

## <a name="do-i-need-to-declare-a-constructor-in-my-runtime-classs-idl"></a><span data-ttu-id="3181e-127">Muss ich einen Konstruktor in der IDL meiner Laufzeitklasse deklarieren?</span><span class="sxs-lookup"><span data-stu-id="3181e-127">Do I need to declare a constructor in my runtime class's IDL?</span></span>
<span data-ttu-id="3181e-128">Nur wenn die Laufzeitklasse so konzipiert ist, dass sie von außerhalb ihrer implementierenden Kompiliereinheit verwendet werden kann (es handelt sich um eine Komponente für Windows-Runtime, die für den allgemeinen Gebrauch durch Windows-Runtime-Clientanwendungen bestimmt ist).</span><span class="sxs-lookup"><span data-stu-id="3181e-128">Only if the runtime class is designed to be consumed from outside its implementing compilation unit (it's a Windows Runtime component intended for general consumption by Windows Runtime client apps).</span></span> <span data-ttu-id="3181e-129">Ausführliche Informationen über den Zweck und die Konsequenzen der Deklaration von Konstruktoren in IDL finden Sie unter [Runtime-Klassenkonstruktoren](author-apis.md#runtime-class-constructors).</span><span class="sxs-lookup"><span data-stu-id="3181e-129">For full details on the purpose and consequences of declaring constructor(s) in IDL, see [Runtime class constructors](author-apis.md#runtime-class-constructors).</span></span>

## <a name="why-is-the-linker-giving-me-a-lnk2019-unresolved-external-symbol-error"></a><span data-ttu-id="3181e-130">Warum gibt der Linker den Fehler „LNK2019: Nicht aufgelöstes externes Symbol“ aus?</span><span class="sxs-lookup"><span data-stu-id="3181e-130">Why is the linker giving me a "LNK2019: Unresolved external symbol" error?</span></span>
<span data-ttu-id="3181e-131">Wenn es sich bei dem nicht aufgelösten Symbol um eine API aus den Windows-Namespace-Headern für die C++/WinRT-Projektion (im **Winrt**-Namespace) handelt, ist die API in einem Header forward-deklariert, den Sie eingeschlossen haben, ihre Definition befindet sich aber in einem Header, der noch nicht hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="3181e-131">If the unresolved symbol is an API from the Windows namespace headers for the C++/WinRT projection (in the **winrt** namespace), then the API is forward-declared in a header that you've included, but its definition is in a header that you haven't yet included.</span></span> <span data-ttu-id="3181e-132">Binden Sie den Header ein, der für den Namespace der API benannt ist, und führen Sie eine erneute Erstellung durch.</span><span class="sxs-lookup"><span data-stu-id="3181e-132">Include the header named for the API's namespace, and rebuild.</span></span> <span data-ttu-id="3181e-133">Weitere Informationen finden Sie unter [C++/WinRT-Projektionsheader](consume-apis.md#cwinrt-projection-headers).</span><span class="sxs-lookup"><span data-stu-id="3181e-133">For more info, see [C++/WinRT projection headers](consume-apis.md#cwinrt-projection-headers).</span></span>

<span data-ttu-id="3181e-134">Wenn es sich bei dem nicht aufgelösten Symbol um eine freie Windows-Runtime-Funktion handelt, z.B. [RoInitialize](https://msdn.microsoft.com/library/br224650), müssen Sie explizit die Überbibliothek [WindowsApp.lib](/uwp/win32-and-com/win32-apis) zu Ihrem Projekt hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="3181e-134">If the unresolved symbol is a Windows Runtime free function, such as [RoInitialize](https://msdn.microsoft.com/library/br224650), then you'll need to explicitly include the [WindowsApp.lib](/uwp/win32-and-com/win32-apis) umbrella library in your project.</span></span> <span data-ttu-id="3181e-135">Die C++/WinRT-Projektion hängt von einigen dieser freien (Nicht-Mitglieds)-Funktionen und Einstiegspunkten ab.</span><span class="sxs-lookup"><span data-stu-id="3181e-135">The C++/WinRT projection depends on some of these free (non-member) functions and entry points.</span></span> <span data-ttu-id="3181e-136">Wenn Sie eine der [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix)-Projektvorlagen für Ihre Anwendung verwenden, wird `WindowsApp.lib` automatisch für Sie verknüpft.</span><span class="sxs-lookup"><span data-stu-id="3181e-136">If you use one of the [C++/WinRT Visual Studio Extension (VSIX)](https://aka.ms/cppwinrt/vsix) project templates for your application, then `WindowsApp.lib` is linked for you automatically.</span></span> <span data-ttu-id="3181e-137">Andernfalls können Sie die Projektlinkeinstellungen verwenden, um sie einzuschließen, oder dies im Quellcode erledigen.</span><span class="sxs-lookup"><span data-stu-id="3181e-137">Otherwise, you can use project link settings to include it, or do it in source code.</span></span>

```cppwinrt
#pragma comment(lib, "windowsapp")
```

## <a name="should-i-implement-windowsfoundationiclosableuwpapiwindowsfoundationiclosable-and-if-so-how"></a><span data-ttu-id="3181e-138">Sollte ich [**Windows::Foundation::IClosable**](/uwp/api/windows.foundation.iclosable) implementieren und wenn ja, wie?</span><span class="sxs-lookup"><span data-stu-id="3181e-138">Should I implement [**Windows::Foundation::IClosable**](/uwp/api/windows.foundation.iclosable) and, if so, how?</span></span>
<span data-ttu-id="3181e-139">Wenn Sie eine Laufzeitklasse haben, die Ressourcen in ihrem Destruktor freigibt, und diese Laufzeitklasse dafür ausgelegt ist außerhalb ihrer implementierenden Kompiliereinheit genutzt zu werden (eine Komponente für Windows-Runtime, die für die allgemeinen Nutzung durch Windows-Runtime-Clientanwendungen bestimmt ist), dann empfehlen wir Ihnen,\*\* IClosable\*\* zu implementieren, um die Nutzung Ihrer Laufzeitklasse durch Sprachen ohne deterministische Finalisierung zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="3181e-139">If you have a runtime class that frees resources in its destructor, and that runtime class is designed to be consumed from outside its implementing compilation unit (it's a Windows Runtime component intended for general consumption by Windows Runtime client apps), then we recommend that you also implement **IClosable** in order to support the consumption of your runtime class by languages that lack deterministic finalization.</span></span> <span data-ttu-id="3181e-140">Stellen Sie sicher, dass Ihre Ressourcen freigegeben werden – egal ob der Destruktor, [**IClosable::Close**](/uwp/api/windows.foundation.iclosable.Close) oder beide aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3181e-140">Make sure that your resources are freed whether the destructor, [**IClosable::Close**](/uwp/api/windows.foundation.iclosable.Close), or both are called.</span></span> <span data-ttu-id="3181e-141">**IClosable::Close** kann beliebig oft aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="3181e-141">**IClosable::Close** may be called an arbitrary number of times.</span></span>

## <a name="do-i-need-to-call-iclosablecloseuwpapiwindowsfoundationiclosablewindowsfoundationiclosableclose-on-runtime-classes-that-i-consume"></a><span data-ttu-id="3181e-142">Muss ich [**IClosable::Close**](/uwp/api/windows.foundation.iclosable#Windows_Foundation_IClosable_Close_) bei Laufzeitklassen aufrufen, die ich nutze?</span><span class="sxs-lookup"><span data-stu-id="3181e-142">Do I need to call [**IClosable::Close**](/uwp/api/windows.foundation.iclosable#Windows_Foundation_IClosable_Close_) on runtime classes that I consume?</span></span>
<span data-ttu-id="3181e-143">**IClosable** existiert, um Sprachen zu unterstützen, die keine deterministische Finalisierung haben.</span><span class="sxs-lookup"><span data-stu-id="3181e-143">**IClosable** exists to support languages that lack deterministic finalization.</span></span> <span data-ttu-id="3181e-144">Daher sollten Sie **IClosable::Close** nicht von C++/WinRT aus aufrufen, außer in sehr seltenen Fällen, in denen es um Shutdown-Races oder halb Semi-Deadocks geht.</span><span class="sxs-lookup"><span data-stu-id="3181e-144">So, you shouldn't call **IClosable::Close** from C++/WinRT, except in very rare cases involving shutdown races or semi-deadly embraces.</span></span> <span data-ttu-id="3181e-145">Wenn Sie z. B.\*\* Windows.UI.Composition\*\*-Typen verwenden, können Sie auf Fälle stoßen, in denen Sie Objekte in einer festgelegten Reihenfolge verwerfen möchten (statt dies durch den C++/WinRT-Wrapper erledigen zu lassen).</span><span class="sxs-lookup"><span data-stu-id="3181e-145">If you're using **Windows.UI.Composition** types, as an example, then you may encounter cases where you want to dispose objects in a set sequence, as an alternative to allowing the destruction of the C++/WinRT wrapper do the work for you.</span></span>

## <a name="can-i-use-llvmclang-to-compile-with-cwinrt"></a><span data-ttu-id="3181e-146">Kann ich LLVM/Clang verwenden, um mit C++/WinRT zu kompilieren?</span><span class="sxs-lookup"><span data-stu-id="3181e-146">Can I use LLVM/Clang to compile with C++/WinRT?</span></span>
<span data-ttu-id="3181e-147">Die Toolkette LLVM und Clang wird für C++/WinRT nicht unterstützt, aber wir verwenden sie intern, um die Standardkonformität von C++/WinRT zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="3181e-147">We don't support the LLVM and Clang toolchain for C++/WinRT, but we do make use of it internally to validate C++/WinRT's standards conformance.</span></span> <span data-ttu-id="3181e-148">Wenn Sie z.B. emulieren möchten, was wir intern tun, könnten Sie ein Experiment wie das unten beschriebene ausprobieren.</span><span class="sxs-lookup"><span data-stu-id="3181e-148">For example, if you wanted to emulate what we do internally, then you could try an experiment such as the one described below.</span></span>

<span data-ttu-id="3181e-149">Wechseln Sie zur [LLVM-Download-Seite](https://releases.llvm.org/download.html), suchen Sie nach **Download LLVM 6.0.0** > **Pre-Built Binaries**, und laden Sie **Clang for Windows (64-bit)** herunter.</span><span class="sxs-lookup"><span data-stu-id="3181e-149">Go to the [LLVM Download Page](https://releases.llvm.org/download.html), look for **Download LLVM 6.0.0** > **Pre-Built Binaries**, and download **Clang for Windows (64-bit)**.</span></span> <span data-ttu-id="3181e-150">Geben Sie während der Installation an, dass LLVM zur Systemvariablen PATH hinzugefügt werden soll, sodass Sie in der Lage sind, sie von einer Befehlszeile aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="3181e-150">During installation, opt to add LLVM to the PATH system variable so that you'll be able to invoke it from a command prompt.</span></span> <span data-ttu-id="3181e-151">Für die Zwecke dieses Experiments können Sie die Meldungen, dass das Verzeichnis für die MSBuild-Toolsets nicht gefunden werden konnte und/oder dass die MSVC-Integrationsinstallation fehlgeschlagen ist, ignorieren (sollten diese angezeigt werden).</span><span class="sxs-lookup"><span data-stu-id="3181e-151">For the purposes of this experiment, you can ignore any "Failed to find MSBuild toolsets directory" and/or "MSVC integration install failed" errors, if you see them.</span></span> <span data-ttu-id="3181e-152">Es gibt verschiedene Möglichkeiten zum Aufrufen von LLVM/Clang. Das folgende Beispiel zeigt nur eine davon.</span><span class="sxs-lookup"><span data-stu-id="3181e-152">There are a variety of ways to invoke LLVM/Clang; the example below shows just one way.</span></span>

```
C:\ExperimentWithLLVMClang>type main.cpp
// main.cpp
#pragma comment(lib, "windowsapp")
#pragma comment(lib, "ole32")

#include "winrt/Windows.Foundation.h"
#include <stdio.h>
#include <iostream>

using namespace winrt;

int main()
{
    winrt::init_apartment();
    Windows::Foundation::Uri rssFeedUri{ L"https://blogs.windows.com/feed" };
    std::wcout << rssFeedUri.Domain().c_str() << std::endl;
}

C:\ExperimentWithLLVMClang>clang-cl main.cpp /EHsc /I ..\.. -Xclang -std=c++17 -Xclang -Wno-delete-non-virtual-dtor -o app.exe

C:\ExperimentWithLLVMClang>app
windows.com
```

<span data-ttu-id="3181e-153">Da C++/WinRT Features vom C++17-Standard verwendet, müssen Sie alle Compiler-Flags verwenden, die erforderlich sind, um diese Unterstützung zu erhalten. Diese Flags sind je nach Compiler unterschiedlich.</span><span class="sxs-lookup"><span data-stu-id="3181e-153">Because C++/WinRT uses features from the C++17 standard, you'll need to use whatever compiler flags are necessary to get that support; such flags differ from one compiler to another.</span></span>

<span data-ttu-id="3181e-154">Visual Studio ist das Entwicklungstool, das wir unterstützen und für C++/WinRT empfehlen.</span><span class="sxs-lookup"><span data-stu-id="3181e-154">Visual Studio is the development tool that we support and recommend for C++/WinRT.</span></span> <span data-ttu-id="3181e-155">Weitere Informationen finden Sie unter [Visual Studio-Unterstützung für C++/WinRT und VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span><span class="sxs-lookup"><span data-stu-id="3181e-155">See [Visual Studio support for C++/WinRT, and the VSIX](intro-to-using-cpp-with-winrt.md#visual-studio-support-for-cwinrt-and-the-vsix).</span></span>

## <a name="why-doesnt-the-generated-implementation-function-for-a-read-only-property-have-the-const-qualifier"></a><span data-ttu-id="3181e-156">Warum nicht die Funktion generierten Implementierung für eine schreibgeschützte Eigenschaft hat die `const` Qualifizierer?</span><span class="sxs-lookup"><span data-stu-id="3181e-156">Why doesn't the generated implementation function for a read-only property have the `const` qualifier?</span></span>

<span data-ttu-id="3181e-157">Wenn Sie eine schreibgeschützte Eigenschaft in [MIDL 3.0](/uwp/midl-3/)deklarieren, können Sie davon ausgehen, dass die `cppwinrt.exe` Tool zum Generieren einer Implementierung-Funktion für Sie `const`-qualifizierte (eine const Funktion behandelt den *diesem* Zeiger als const).</span><span class="sxs-lookup"><span data-stu-id="3181e-157">When you declare a read-only property in [MIDL 3.0](/uwp/midl-3/), you might expect the `cppwinrt.exe` tool to generate an implementation function for you that is `const`-qualified (a const function treats the *this* pointer as const).</span></span>

<span data-ttu-id="3181e-158">Sicherlich empfohlen, Const nach Möglichkeit, aber die `cppwinrt.exe` Tool selbst nicht versuchen, Grund, über welche Implementierung Funktionen u. u. tatsächlich const werden und die möglicherweise nicht.</span><span class="sxs-lookup"><span data-stu-id="3181e-158">We certainly recommend using const wherever possible, but the `cppwinrt.exe` tool itself doesn't attempt to reason about which implementation functions might conceivably be const, and which might not.</span></span> <span data-ttu-id="3181e-159">Sie können festlegen, dass Ihre Implementierung Funktionen const, wie im folgenden Beispiel.</span><span class="sxs-lookup"><span data-stu-id="3181e-159">You can choose to make any of your implementation functions const, as in this example.</span></span>

```cppwinrt
struct MyStringable : winrt::implements<MyStringable, winrt::Windows::Foundation::IStringable>
{
    winrt::hstring ToString() const
    {
        return L"MyStringable";
    }
};
```

<span data-ttu-id="3181e-160">Sie können entfernen, die `const` Qualifizierer für **ToString** sollten Sie entscheiden, dass Sie einige Objektzustand in der Implementierung ändern müssen.</span><span class="sxs-lookup"><span data-stu-id="3181e-160">You can remove that `const` qualifier on **ToString** should you decide that you need to alter some object state in its implementation.</span></span> <span data-ttu-id="3181e-161">Es sollte jedoch darauf aller Ihrer Member Funktionen const oder nicht-Const, nicht beides.</span><span class="sxs-lookup"><span data-stu-id="3181e-161">But make each of your member functions either const or non-const, not both.</span></span> <span data-ttu-id="3181e-162">Anders ausgedrückt, nicht überladen eine Implementierung Funktion auf `const`.</span><span class="sxs-lookup"><span data-stu-id="3181e-162">In other words, don't overload an implementation function on `const`.</span></span>

<span data-ttu-id="3181e-163">Abgesehen von der Ihrer Implementierungsfunktionen einer anderen anderen Standort const wird das Bild ist in Windows-Runtime-Funktion Projektionen.</span><span class="sxs-lookup"><span data-stu-id="3181e-163">Aside from your implementation functions, another other place where const comes into the picture is in Windows Runtime function projections.</span></span> <span data-ttu-id="3181e-164">Betrachten Sie diesen Code.</span><span class="sxs-lookup"><span data-stu-id="3181e-164">Consider this code.</span></span>

```cppwinrt
int main()
{
    winrt::Windows::Foundation::IStringable s{ winrt::make<MyStringable>() };
    auto result{ s.ToString() };
}
```

<span data-ttu-id="3181e-165">Für den Aufruf von **ToString** oben, der Befehl **Gehe zu Deklaration** in Visual Studio angezeigt, die die Projektion der Windows-Runtime- **istringable:: ToString** in C++ / WinRT sieht wie folgt aus.</span><span class="sxs-lookup"><span data-stu-id="3181e-165">For the call to **ToString** above, the **Go To Declaration** command in Visual Studio shows that the projection of the Windows Runtime **IStringable::ToString** into C++/WinRT looks like this.</span></span>

```
winrt::hstring ToString() const;
```

<span data-ttu-id="3181e-166">Funktionen in der Projektion sind const unabhängig davon, wie Sie Ihre Implementierung von ihnen zu qualifizieren.</span><span class="sxs-lookup"><span data-stu-id="3181e-166">Functions on the projection are const no matter how you choose to qualify your implementation of them.</span></span> <span data-ttu-id="3181e-167">Im Hintergrund Ruft die Projektion auf die binären Anwendungsschnittstelle (ABI), welche Beträge auf einen Aufruf über einen COM-Schnittstellenzeiger.</span><span class="sxs-lookup"><span data-stu-id="3181e-167">Behind the scenes, the projection calls the application binary interface (ABI), which amounts to a call through a COM interface pointer.</span></span> <span data-ttu-id="3181e-168">Der einzige Zustand, mit dem interagiert projizierten **ToString** ist die COM-Interface-Zeiger. und natürlich keine Notwendigkeit, das diesem Zeiger zu ändern, so dass die Funktion konstant ist verfügt.</span><span class="sxs-lookup"><span data-stu-id="3181e-168">The only state that the projected **ToString** interacts with is that COM interface pointer; and it certainly has no need to modify that pointer, so the function is const.</span></span> <span data-ttu-id="3181e-169">Mit dieser erhalten Sie die Sicherstellung, dass es sich nicht über die **IStringable** -Referenz, der Sie ändert durch Aufrufen, und es wird sichergestellt, dass Sie auch mit einer Const **ToString** aufrufen können, ein **IStringable**verweisen.</span><span class="sxs-lookup"><span data-stu-id="3181e-169">This gives you the assurance that it won't change anything about the **IStringable** reference that you're calling through, and it ensures that you can call **ToString** even with a const reference to an **IStringable**.</span></span>

<span data-ttu-id="3181e-170">Zu verstehen, die diese Beispiele für `const` sind Details zur Implementierung von C++ / WinRT Projektionen und Implementierungen; Sie bilden Code Hygiene Ihrem nutzen.</span><span class="sxs-lookup"><span data-stu-id="3181e-170">Understand that these examples of `const` are implementation details of C++/WinRT projections and implementations; they constitute code hygiene for your benefit.</span></span> <span data-ttu-id="3181e-171">Es gibt keine als `const` auf der COM- noch die Windows-Runtime-ABI (für Memberfunktion).</span><span class="sxs-lookup"><span data-stu-id="3181e-171">There's no such thing as `const` on the COM nor Windows Runtime ABI (for member functions).</span></span>

## <a name="do-you-have-any-recommendations-for-decreasing-the-code-size-for-cwinrt-binaries"></a><span data-ttu-id="3181e-172">Haben Sie alle Empfehlungen für das Verringern der Codegröße für C++ / WinRT-Binärdateien?</span><span class="sxs-lookup"><span data-stu-id="3181e-172">Do you have any recommendations for decreasing the code size for C++/WinRT binaries?</span></span>

<span data-ttu-id="3181e-173">Bei der Arbeit mit Windows-Runtime-Objekten vermeiden Sie das Codierungsmuster unten angezeigt werden, da es sich negativ auf Ihre Anwendung aufweisen kann, indem verursacht Weitere Binärcode als nötig, generiert werden.</span><span class="sxs-lookup"><span data-stu-id="3181e-173">When working with Windows Runtime objects, you should avoid the coding pattern shown below because it can have a negative impact on your application by causing more binary code than necessary to be generated.</span></span>

```cppwinrt
anobject.b().c().d();
anobject.b().c().e();
anobject.b().c().f();
```

<span data-ttu-id="3181e-174">In der Windows-Runtime-Welt, kann der Compiler nicht entweder den Wert der cache `c()` oder die Schnittstellen für jede Methode, die durch eine Dereferenzierung aufgerufen wird ('. ').</span><span class="sxs-lookup"><span data-stu-id="3181e-174">In the Windows Runtime world, the compiler is unable to cache either the value of `c()` or the interfaces for each method that's called through an indirection ('.').</span></span> <span data-ttu-id="3181e-175">Es sei denn, Sie eingreifen, führt, die weitere virtuelle Aufrufe und referenzzählung Aufwand.</span><span class="sxs-lookup"><span data-stu-id="3181e-175">Unless you intervene, that results in more virtual calls and reference counting overhead.</span></span> <span data-ttu-id="3181e-176">Das Muster, die oben genannten konnte leicht doppelt so viel Code, der als streng benötigt generiert werden.</span><span class="sxs-lookup"><span data-stu-id="3181e-176">The pattern above could easily generate twice as much code as strictly needed.</span></span> <span data-ttu-id="3181e-177">Bevorzugen Sie stattdessen das Muster unten Sie überall können.</span><span class="sxs-lookup"><span data-stu-id="3181e-177">Instead, prefer the pattern shown below wherever you can.</span></span> <span data-ttu-id="3181e-178">Es wird viel weniger Code generiert, und es kann auch erheblich verbessern der Leistung Ihrer Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="3181e-178">It generates a lot less code, and it can also dramatically improve your run time performance.</span></span>

```cppwinrt
auto a{ anobject.b().c() };
a.d();
a.e();
a.f();
```

<span data-ttu-id="3181e-179">Das empfohlene oben gezeigte Muster gilt nicht nur für C++ / WinRT jedoch auf alle Windows-Runtime-sprachprojektionen.</span><span class="sxs-lookup"><span data-stu-id="3181e-179">The recommended pattern shown above applies not just to C++/WinRT but to all Windows Runtime language projections.</span></span>

> [!NOTE]
> <span data-ttu-id="3181e-180">Wenn Ihre Frage in diesem Thema nicht beantwortet werden konnte, finden Sie ggf. hier Unterstützung: [`c++-winrt`-Tag auf Stack Overflow ](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span><span class="sxs-lookup"><span data-stu-id="3181e-180">If this topic didn't answer your question, you might find help by using the [`c++-winrt` tag on Stack Overflow](https://stackoverflow.com/questions/tagged/c%2b%2b-winrt).</span></span>
