---
title: CPUSets für die Entwicklung von Spielen
description: Dieser Artikel enthält eine Übersicht über die CPUSets-API,die in der universellen Windows-Plattform (UWP) neu ist, und liefert grundlegende Informationen zur Entwicklung von Spielen und Anwendungen.
ms.localizationpriority: medium
ms.openlocfilehash: 942c6b79d3b26e620ebb6e1318e1f7ffd75f929c
ms.sourcegitcommit: d7613c791107f74b6a3dc12a372d9de916c0454b
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/05/2018
ms.locfileid: "8753507"
---
# <a name="cpusets-for-game-development"></a><span data-ttu-id="6cf9a-103">CPUSets für die Entwicklung von Spielen</span><span class="sxs-lookup"><span data-stu-id="6cf9a-103">CPUSets for game development</span></span>

## <a name="introduction"></a><span data-ttu-id="6cf9a-104">Einführung</span><span class="sxs-lookup"><span data-stu-id="6cf9a-104">Introduction</span></span>

<span data-ttu-id="6cf9a-105">Die universelle Windows-Plattform (UWP) ist das Herzstück einer Vielzahl von elektronischen Geräten für Verbraucher.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-105">The Universal Windows Platform (UWP) is at the core of a wide range of consumer electronic devices.</span></span> <span data-ttu-id="6cf9a-106">Als solches benötigt sie eine allgemeine API, um die Bedürfnisse aller Anwendungsarten zu erfüllen: von Spielen über eingebettete Apps bis hin zu Enterprise-Software, die auf Servern ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-106">As such, it requires a general purpose API to address the needs of all types of applications from games to embedded apps to enterprise software running on servers.</span></span> <span data-ttu-id="6cf9a-107">Durch die Nutzung der richtigen Informationen, die von der API bereitgestellt werden, können Sie sicherstellen, dass Ihr Spiel auf jeder Hardware optimal ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-107">By leveraging the right information provided by the API, you can ensure your game runs at its best on any hardware.</span></span>

## <a name="cpusets-api"></a><span data-ttu-id="6cf9a-108">CPUSets-API</span><span class="sxs-lookup"><span data-stu-id="6cf9a-108">CPUSets API</span></span>

<span data-ttu-id="6cf9a-109">Die CPUSets-API bietet Kontrolle darüber, welche CPU-Sätze zur Verfügung stehen, um die Ausführung von Threads darauf zu planen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-109">The CPUSets API provides control over which CPU sets are available for threads to be scheduled on.</span></span> <span data-ttu-id="6cf9a-110">Zwei Funktionen sind verfügbar, um zu steuern, wo Threads geplant werden:</span><span class="sxs-lookup"><span data-stu-id="6cf9a-110">Two functions are available to control where threads are scheduled:</span></span>
- <span data-ttu-id="6cf9a-111">**SetProcessDefaultCpuSets**: Diese Funktion kann zum Angeben der CPU-Sätze verwendet werden, auf denen neue Threads ausgeführt werden können, wenn sie nicht bestimmten CPU-Sätze zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-111">**SetProcessDefaultCpuSets** – This function can be used to specify which CPU sets new threads may run on if they are not assigned to specific CPU sets.</span></span>
- <span data-ttu-id="6cf9a-112">**SetThreadSelectedCpuSets**: Mit dieser Funktion können Sie die CPU-Sätze beschränken, auf denen ein bestimmter Thread ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-112">**SetThreadSelectedCpuSets** – This function allows you to limit the CPU sets a specific thread may run on.</span></span>

<span data-ttu-id="6cf9a-113">Wenn die Funktion **SetProcessDefaultCpuSets** niemals verwendet wird, können neu erstellte Threads auf jeder CPU geplant werden, die für Ihren Prozess verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-113">If the **SetProcessDefaultCpuSets** function is never used, newly created threads may be scheduled on any CPU set available to your process.</span></span> <span data-ttu-id="6cf9a-114">Dieser Abschnitt behandelt die Grundlagen der CPUSets-API.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-114">This section goes over the basics of the CPUSets API.</span></span>

### <a name="getsystemcpusetinformation"></a><span data-ttu-id="6cf9a-115">GetSystemCpuSetInformation</span><span class="sxs-lookup"><span data-stu-id="6cf9a-115">GetSystemCpuSetInformation</span></span>

<span data-ttu-id="6cf9a-116">Die erste API, die zum Sammeln von Informationen verwendet wird, ist die **GetSystemCpuSetInformation**-Funktion.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-116">The first API used for gathering information is the **GetSystemCpuSetInformation** function.</span></span> <span data-ttu-id="6cf9a-117">Diese Funktion füllt Informationen in einem Bereich von **SYSTEM_CPU_SET_INFORMATION**-Objekten auf, die vom Titel-Code bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-117">This function populates information in an array of **SYSTEM_CPU_SET_INFORMATION** objects provided by title code.</span></span> <span data-ttu-id="6cf9a-118">Der Speicher für das Ziel muss vom Spielcode zugeordnet werden, dessen Größe durch Aufrufen von **GetSystemCpuSetInformation** selbst bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-118">The memory for the destination must be allocated by game code, the size of which is determined by calling **GetSystemCpuSetInformation** itself.</span></span> <span data-ttu-id="6cf9a-119">Dies erfordert zwei Aufrufe von **GetSystemCpuSetInformation**, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-119">This requires two calls to **GetSystemCpuSetInformation** as demonstrated in the following example.</span></span>

```
unsigned long size;
HANDLE curProc = GetCurrentProcess();
GetSystemCpuSetInformation(nullptr, 0, &size, curProc, 0);

std::unique_ptr<uint8_t[]> buffer(new uint8_t[size]);

PSYSTEM_CPU_SET_INFORMATION cpuSets = reinterpret_cast<PSYSTEM_CPU_SET_INFORMATION>(buffer.get());
  
GetSystemCpuSetInformation(cpuSets, size, &size, curProc, 0);
```

<span data-ttu-id="6cf9a-120">Jede Instanz von zurückgegebenen **SYSTEM_CPU_SET_INFORMATION** enthält Informationen zu einer eindeutigen Verarbeitungseinheit, die auch als CPU-Satz bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-120">Each instance of **SYSTEM_CPU_SET_INFORMATION** returned contains information about one unique processing unit, also known as a CPU set.</span></span> <span data-ttu-id="6cf9a-121">Dies bedeutet nicht notwendigerweise, dass er ein eindeutiges physisches Hardwaregerät darstellt.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-121">This does not necessarily mean that it represents a unique physical piece of hardware.</span></span> <span data-ttu-id="6cf9a-122">CPUs, die Hyperthreading nutzen, verfügen über mehrere logische Kerne, die auf einem einzigen physischen Verarbeitungskern ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-122">CPUs that utilize hyperthreading will have multiple logical cores running on a single physical processing core.</span></span> <span data-ttu-id="6cf9a-123">Das Planen von mehreren Threads auf verschiedenen logischen Kernen, die sich auf dem gleichen physischen Kern befinden, ermöglicht eine Optimierung von Ressourcen auf Hardware-Ebene, für die andernfalls zusätzliche Arbeit auf der Kernel-Ebene durchgeführt werden müsste.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-123">Scheduling multiple threads on different logical cores that reside on the same physical core allows hardware-level resource optimization that would otherwise require extra work to be done at the kernel level.</span></span> <span data-ttu-id="6cf9a-124">Zwei Threads, die auf separaten logischen Kernen auf dem gleichen physischen Kern geplant sind, müssen die CPU-Zeit teilen, würden aber effizienter ausgeführt werden, als wenn sie auf dem gleichen logischen Kern geplant worden wären.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-124">Two threads scheduled on separate logical cores on the same physical core must share CPU time, but would run more efficiently than if they were scheduled to the same logical core.</span></span>

### <a name="systemcpusetinformation"></a><span data-ttu-id="6cf9a-125">SYSTEM_CPU_SET_INFORMATION</span><span class="sxs-lookup"><span data-stu-id="6cf9a-125">SYSTEM_CPU_SET_INFORMATION</span></span>

<span data-ttu-id="6cf9a-126">Die Informationen in jeder Instanz dieser Datenstruktur, die von **GetSystemCpuSetInformation** zurückgegeben wird, enthalten Informationen zu einer eindeutigen Verarbeitungseinheit, auf der Threads geplant werden können.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-126">The information in each instance of this data structure returned from **GetSystemCpuSetInformation** contains information about a unique processing unit that threads may be scheduled on.</span></span> <span data-ttu-id="6cf9a-127">Angesichts der möglichen Bandbreite von Zielgeräten gelten möglicherweise viele der Informationen in der **SYSTEM_CPU_SET_INFORMATION**-Datenstruktur nicht für die Entwicklung von Spielen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-127">Given the possible range of target devices, a lot of the information in the **SYSTEM_CPU_SET_INFORMATION** data structure may not applicable for game development.</span></span> <span data-ttu-id="6cf9a-128">Tabelle 1 enthält eine Erläuterung der Datenmember, die für die Entwicklung von Spielen hilfreich sind.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-128">Table 1 provides an explanation of data members that are useful for game development.</span></span>

 **<span data-ttu-id="6cf9a-129">Tabelle1.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-129">Table 1.</span></span> <span data-ttu-id="6cf9a-130">Für die Entwicklung von Spielen hilfreiche Datenmember.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-130">Data members useful for game development.</span></span>**

| <span data-ttu-id="6cf9a-131">Membername</span><span class="sxs-lookup"><span data-stu-id="6cf9a-131">Member name</span></span>  | <span data-ttu-id="6cf9a-132">Datentyp</span><span class="sxs-lookup"><span data-stu-id="6cf9a-132">Data type</span></span> | <span data-ttu-id="6cf9a-133">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="6cf9a-133">Description</span></span> |
| ------------- | ------------- | ------------- |
| <span data-ttu-id="6cf9a-134">Typ</span><span class="sxs-lookup"><span data-stu-id="6cf9a-134">Type</span></span>  | <span data-ttu-id="6cf9a-135">CPU_SET_INFORMATION_TYPE</span><span class="sxs-lookup"><span data-stu-id="6cf9a-135">CPU_SET_INFORMATION_TYPE</span></span>  | <span data-ttu-id="6cf9a-136">Der Typ der Informationen in der Struktur.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-136">The type of information in the structure.</span></span> <span data-ttu-id="6cf9a-137">Wenn der Wert nicht **CpuSetInformation** lautet, sollte er ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-137">If the value of this is not **CpuSetInformation**, it should be ignored.</span></span>  |
| <span data-ttu-id="6cf9a-138">ID</span><span class="sxs-lookup"><span data-stu-id="6cf9a-138">Id</span></span>  | <span data-ttu-id="6cf9a-139">ohne Vorzeichen lang</span><span class="sxs-lookup"><span data-stu-id="6cf9a-139">unsigned long</span></span>  | <span data-ttu-id="6cf9a-140">Die ID des angegebenen CPU-Satzes.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-140">The ID of the specified CPU set.</span></span> <span data-ttu-id="6cf9a-141">Dies ist die ID, die mit CPU-Satz-Funktionen wie **SetThreadSelectedCpuSets** verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-141">This is the ID that should be used with CPU set functions such as **SetThreadSelectedCpuSets**.</span></span>  |
| <span data-ttu-id="6cf9a-142">Gruppe</span><span class="sxs-lookup"><span data-stu-id="6cf9a-142">Group</span></span>  | <span data-ttu-id="6cf9a-143">ohne Vorzeichen kurz</span><span class="sxs-lookup"><span data-stu-id="6cf9a-143">unsigned short</span></span>  | <span data-ttu-id="6cf9a-144">Gibt die „Prozessorgruppe“ des CPU-Satzes an.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-144">Specifies the “processor group” of the CPU set.</span></span> <span data-ttu-id="6cf9a-145">Mit Prozessorgruppen kann ein PC mehr als 64 logische Prozessorkerne haben, und ein Austausch von CPUs per Hot-Swap bei laufendem System wird möglich.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-145">Processor groups allow a PC to have more than 64 logical cores, and allow for hot swapping of CPUs while the system is running.</span></span> <span data-ttu-id="6cf9a-146">Es kommt nicht oft vor, dass ein PC kein Server mit mehr als einer Gruppe ist.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-146">It is uncommon to see a PC that is not a server with more than one group.</span></span> <span data-ttu-id="6cf9a-147">Wenn Sie nicht gerade Anwendungen schreiben, die auf großen Servern oder Serverfarmen ausgeführt werden sollen, empfiehlt es sich, CPU-Sätze in einer einzelnen Gruppe zu verwenden, da die meisten Verbraucher-PCs nur eine Prozessorgruppe haben.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-147">Unless you are writing applications meant to run on large servers or server farms, it is best to use CPU sets in a single group because most consumer PCs will only have one processor group.</span></span> <span data-ttu-id="6cf9a-148">Alle anderen Werte in dieser Struktur beziehen sich auf die Gruppe.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-148">All other values in this structure are relative to the Group.</span></span>  |
| <span data-ttu-id="6cf9a-149">LogicalProcessorIndex</span><span class="sxs-lookup"><span data-stu-id="6cf9a-149">LogicalProcessorIndex</span></span>  | <span data-ttu-id="6cf9a-150">char-Wert ohne Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="6cf9a-150">unsigned char</span></span>  | <span data-ttu-id="6cf9a-151">Zur Gruppe relativer Index des CPU-Satzes</span><span class="sxs-lookup"><span data-stu-id="6cf9a-151">Group relative index of the CPU set</span></span>  |
| <span data-ttu-id="6cf9a-152">CoreIndex</span><span class="sxs-lookup"><span data-stu-id="6cf9a-152">CoreIndex</span></span>  | <span data-ttu-id="6cf9a-153">char-Wert ohne Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="6cf9a-153">unsigned char</span></span>  | <span data-ttu-id="6cf9a-154">Zur Gruppe relativer Index des physischen CPU-Kerns, auf dem sich der CPU-Satz befindet.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-154">Group relative index of the physical CPU core where the CPU set is located</span></span>  |
| <span data-ttu-id="6cf9a-155">LastLevelCacheIndex</span><span class="sxs-lookup"><span data-stu-id="6cf9a-155">LastLevelCacheIndex</span></span>  | <span data-ttu-id="6cf9a-156">char-Wert ohne Vorzeichen</span><span class="sxs-lookup"><span data-stu-id="6cf9a-156">unsigned char</span></span>  | <span data-ttu-id="6cf9a-157">Zur Gruppe relativer Index des letzten Caches, der diesem CPU-Satz zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-157">Group relative index of the last cache associated with this CPU set.</span></span> <span data-ttu-id="6cf9a-158">Dies ist der langsamste Cache, es sei denn, das System verwendet NUMA-Knoten, in der Regel den L2- oder L3-Cache.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-158">This is the slowest cache unless the system utilizes NUMA nodes, usually the L2 or L3 cache.</span></span>  |

<br />

<span data-ttu-id="6cf9a-159">Die anderen Datenmember liefern Informationen, von denen es unwahrscheinlich ist, dass sie CPUs in Verbrauchercomputern oder anderen Verbrauchergeräten beschreiben, sodass sie wahrscheinlich nicht hilfreich sein.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-159">The other data members provide information that is unlikely to describe CPUs in consumer PCs or other consumer devices and is unlikely to be useful.</span></span> <span data-ttu-id="6cf9a-160">Die von den zurückgegebenen Daten gelieferten Informationen können dann verwendet werden, um Threads auf verschiedene Weise zu organisieren.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-160">The information provided by the data returned can then be used to organize threads in various ways.</span></span> <span data-ttu-id="6cf9a-161">Im Abschnitt [Überlegungen für die Spieleentwicklung](#considerations-for-game-development) dieses Whitepapers sind verschiedene Möglichkeiten beschrieben, wie diese Daten zur Optimierung der Thread-Zuordnung genutzt werden können.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-161">The [Considerations for game development](#considerations-for-game-development) section of this white paper details a few ways to leverage this data to optimize thread allocation.</span></span>

<span data-ttu-id="6cf9a-162">Im Folgenden sind einige Beispiele für die Art der Informationen aufgeführt, die von UWP-Anwendungen gesammelt werden, die auf verschiedene Arten von Hardware ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-162">The following are some examples of the type of information gathered from UWP applications running on various types of hardware.</span></span>

**<span data-ttu-id="6cf9a-163">Tabelle2.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-163">Table 2.</span></span> <span data-ttu-id="6cf9a-164">Informationen, die von einer UWP-App zurückgegeben werden, die auf einem Microsoft Lumia 950 ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-164">Information returned from a UWP app running on a Microsoft Lumia 950.</span></span> <span data-ttu-id="6cf9a-165">Dies ist ein Beispiel für ein System, das über mehrere Caches der letzten Ebene verfügt.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-165">This is an example of a system that has multiple last level caches.</span></span> <span data-ttu-id="6cf9a-166">Das Lumia 950 bietet einen Qualcomm 808 Snapdragon-Prozess, der einen Dual-Core ARM Cortex A57 und Quad-Core ARM Cortex A53-CPUs enthält.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-166">The Lumia 950 features a Qualcomm 808 Snapdragon process that contains a dual core ARM Cortex A57 and quad core ARM Cortex A53 CPUs.</span></span>**

  ![Tabelle2](images/cpusets-table2.png)

**<span data-ttu-id="6cf9a-168">Tabelle3.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-168">Table 3.</span></span> <span data-ttu-id="6cf9a-169">Informationen, die von einer UWP-App zurückgegeben werden, die auf einem herkömmlichen PC ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-169">Information returned from a UWP app running on a typical PC.</span></span> <span data-ttu-id="6cf9a-170">Dies ist ein Beispiel für ein System, das Hyperthreading verwendet; jeder physische Kern verfügt über zwei logische Kerne, auf denen Threads geplant werden können.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-170">This is an example of a system that uses hyperthreading; each physical core has two logical cores onto which threads can be scheduled.</span></span> <span data-ttu-id="6cf9a-171">In diesem Fall enthielt das System eine Intel Xenon CPU E5-2620.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-171">In this case, the system contained an Intel Xenon CPU E5-2620.</span></span>**

  ![Tabelle3](images/cpusets-table3.png)

**<span data-ttu-id="6cf9a-173">Tabelle4.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-173">Table 4.</span></span> <span data-ttu-id="6cf9a-174">Informationen, die von einer UWP-App zurückgegeben werden, die auf einem Quad-Core Microsoft Surface Pro 4 ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-174">Information returned from a UWP app running on a quad core Microsoft Surface Pro 4.</span></span> <span data-ttu-id="6cf9a-175">Diesem System verfügt über eine Intel Core i5 6300-CPU.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-175">This system had an Intel Core i5-6300 CPU.</span></span>**

  ![Tabelle4](images/cpusets-table4.png)

### <a name="setthreadselectedcpusets"></a><span data-ttu-id="6cf9a-177">SetThreadSelectedCpuSets</span><span class="sxs-lookup"><span data-stu-id="6cf9a-177">SetThreadSelectedCpuSets</span></span>

<span data-ttu-id="6cf9a-178">Nachdem nun Informationen zu den CPU-Sätzen verfügbar sind, können sie zum Organisieren von Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-178">Now that information about the CPU sets is available, it can be used to organize threads.</span></span> <span data-ttu-id="6cf9a-179">Das Handle eines mit **CreateThread** erstellten Threads wird an diese Funktion übergeben, zusammen mit einem Bereich von IDs der CPU-Sätze, auf denen der Thread geplant werden kann.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-179">The handle of a thread created with **CreateThread** is passed to this function along with an array of IDs of the CPU sets that the thread can be scheduled on.</span></span> <span data-ttu-id="6cf9a-180">Ein Beispiel für die Nutzung wird im folgenden Code veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-180">One example of its usage is demonstrated in the following code.</span></span>

```
HANDLE audioHandle = CreateThread(nullptr, 0, AudioThread, nullptr, 0, nullptr);
unsigned long cores [] = { cpuSets[0].CpuSet.Id, cpuSets[1].CpuSet.Id };
SetThreadSelectedCpuSets(audioHandle, cores, 2);
```
<span data-ttu-id="6cf9a-181">In diesem Beispiel wird ein Thread basierend auf einer Funktion erstellt, die als **AudioThread** deklariert wird.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-181">In this example, a thread is created based on a function declared as **AudioThread**.</span></span> <span data-ttu-id="6cf9a-182">Dieser Thread kann dann auf einem von zwei CPU-Sätzen geplant werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-182">This thread is then allowed to be scheduled on one of two CPU sets.</span></span> <span data-ttu-id="6cf9a-183">Threadbesitz des CPU-Satzes ist nicht ausschließend.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-183">Thread ownership of the CPU set is not exclusive.</span></span> <span data-ttu-id="6cf9a-184">Threads, die erstellt werden, ohne an einen bestimmten CPU-Satz gebunden zu sein, verwenden möglicherweise Zeit vom **AudioThread**.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-184">Threads that are created without being locked to a specific CPU set may take time from the **AudioThread**.</span></span> <span data-ttu-id="6cf9a-185">Ebenso können andere erstellte Threads zu einem späteren Zeitpunkt auch an einen oder beide dieser CPU-Sätze gebunden sein.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-185">Likewise, other threads created may also be locked to one or both of these CPU sets at a later time.</span></span>

### <a name="setprocessdefaultcpusets"></a><span data-ttu-id="6cf9a-186">SetProcessDefaultCpuSets</span><span class="sxs-lookup"><span data-stu-id="6cf9a-186">SetProcessDefaultCpuSets</span></span>

<span data-ttu-id="6cf9a-187">Die Umkehrung zu **SetThreadSelectedCpuSets** ist **SetProcessDefaultCpuSets**.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-187">The converse to **SetThreadSelectedCpuSets** is **SetProcessDefaultCpuSets**.</span></span> <span data-ttu-id="6cf9a-188">Bei der Erstellung von Threads müssen diese nicht an bestimmte CPU-Sätze gebunden werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-188">When threads are created, they do not need to be locked into certain CPU sets.</span></span> <span data-ttu-id="6cf9a-189">Wenn Sie nicht möchten, dass diese Threads auf bestimmten CPU-Sätzen ausgeführt werden (z. B. auf von Ihrem Render-Thread oder Audio-Thread verwendeten CPU-Sätzen), können Sie diese Funktion verwenden, um anzugeben, auf welchen Kernen diese Threads geplant werden dürfen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-189">If you do not want these threads to run on specific CPU sets (those used by your render thread or audio thread for example), you can use this function to specify which cores these threads are allowed to be scheduled on.</span></span>

## <a name="considerations-for-game-development"></a><span data-ttu-id="6cf9a-190">Überlegungen für die Spieleentwicklung</span><span class="sxs-lookup"><span data-stu-id="6cf9a-190">Considerations for game development</span></span>

<span data-ttu-id="6cf9a-191">Wie wir bereits gesehen haben, bietet die CPUSets-API viele Informationen und Flexibilität rund um die Planung von Threads.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-191">As we've seen, the CPUSets API provides a lot of information and flexibility when it comes to scheduling threads.</span></span> <span data-ttu-id="6cf9a-192">Anstatt nach dem Bottom-up-Konzept zu versuchen, Anwendungsfälle für diese Daten zu finden, ist es effektiver, den Top-Down-Ansatz zu verwenden, bei dem ermittelt wird, wie die Daten für gängige Szenarien verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-192">Instead of taking the bottom-up approach of trying to find uses for this data, it is more effective to take the top-down approach of finding how the data can be used to accommodate common scenarios.</span></span>

### <a name="working-with-time-critical-threads-and-hyperthreading"></a><span data-ttu-id="6cf9a-193">Arbeiten mit zeitkritischen Threads und Hyperthreading</span><span class="sxs-lookup"><span data-stu-id="6cf9a-193">Working with time critical threads and hyperthreading</span></span>

<span data-ttu-id="6cf9a-194">Diese Methode ist effektiv, wenn Ihr Spiel einige Threads aufweist, die in Echtzeit zusammen mit anderen Arbeitsthreads ausgeführt werden müssen, die relativ wenig CPU-Zeit in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-194">This method is effective if your game has a few threads that must run in real time along with other worker threads that require relatively little CPU time.</span></span> <span data-ttu-id="6cf9a-195">Manche Aufgaben, z. B. fortlaufende Hintergrundmusik, müssen für ein optimales Spielerlebnis ohne Unterbrechung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-195">Some tasks, like continuous background music, must run without interruption for an optimal gaming experience.</span></span> <span data-ttu-id="6cf9a-196">Bereits ein einzelner Frame mit Audio-Threadzurückstellung kann eine Störung verursachen, sodass es wichtig ist, dass für jeden Frame die erforderliche Menge an CPU-Zeit zur Verfügung steht.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-196">Even a single frame of starvation for an audio thread may cause popping or glitching, so it is critical that it receives the necessary amount of CPU time every frame.</span></span>

<span data-ttu-id="6cf9a-197">Mithilfe von **SetThreadSelectedCpuSets** in Verbindung mit **SetProcessDefaultCpuSets** können Sie sicherstellen, dass Ihre rechenintensiven Threads nicht von Arbeitsthreads unterbrochen werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-197">Using **SetThreadSelectedCpuSets** in conjunction with **SetProcessDefaultCpuSets** can ensure your heavy threads remain uninterrupted by any worker threads.</span></span> <span data-ttu-id="6cf9a-198">**SetThreadSelectedCpuSets** kann verwendet werden, um Ihre rechenintensiven Threads bestimmten CPU-Sätzen zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-198">**SetThreadSelectedCpuSets** can be used to assign your heavy threads to specific CPU sets.</span></span> <span data-ttu-id="6cf9a-199">**SetProcessDefaultCpuSets** kann dann verwendet werden, um sicherzustellen, dass alle erstellten nicht zugewiesenen Threads auf anderen CPU-Sätzen geplant werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-199">**SetProcessDefaultCpuSets** can then be used to make sure any unassigned threads created are put on other CPU sets.</span></span> <span data-ttu-id="6cf9a-200">Im Fall von CPUs, die Hyperthreading nutzen, ist es auch wichtig, logische Kerne auf dem gleichen physischen Kern zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-200">In the case of CPUs that utilize hyperthreading, it's also important to account for logical cores on the same physical core.</span></span> <span data-ttu-id="6cf9a-201">Arbeitsthreads sollten nicht auf logischen Kernen ausgeführt werden dürfen, die den gleichen physischen Kern wie ein Thread verwenden, den Sie mit Echtzeit-Reaktionsfähigkeit ausführen möchten.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-201">Worker threads should not be allowed to run on logical cores that share the same physical core as a thread that you want to run with real time responsiveness.</span></span> <span data-ttu-id="6cf9a-202">Der folgende Code veranschaulicht, wie Sie bestimmen, ob ein PC Hyperthreading verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-202">The following code demonstrates how to determine whether a PC uses hyperthreading.</span></span>

```
unsigned long retsize = 0;
(void)GetSystemCpuSetInformation( nullptr, 0, &retsize,
    GetCurrentProcess(), 0);
 
std::unique_ptr<uint8_t[]> data( new uint8_t[retsize] );
if ( !GetSystemCpuSetInformation(
    reinterpret_cast<PSYSTEM_CPU_SET_INFORMATION>( data.get() ),
    retsize, &retsize, GetCurrentProcess(), 0) )
{
    // Error!
}
 
std::set<DWORD> cores;
std::vector<DWORD> processors;
uint8_t const * ptr = data.get();
for( DWORD size = 0; size < retsize; ) {
    auto info = reinterpret_cast<const SYSTEM_CPU_SET_INFORMATION*>( ptr );
    if ( info->Type == CpuSetInformation ) {
         processors.push_back( info->CpuSet.Id );
         cores.insert( info->CpuSet.CoreIndex );
    }
    ptr += info->Size;
    size += info->Size;
}
 
bool hyperthreaded = processors.size() != cores.size();
```

<span data-ttu-id="6cf9a-203">Wenn das System Hyperthreading verwendet, ist es wichtig, dass der Satz von Standard-CPU-Sätzen keine logischen Kerne auf dem gleichen physischen Kern wie Echtzeit-Threads enthält.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-203">If the system utilizes hyperthreading, it is important that the set of default CPU sets does not include any logical cores on the same physical core as any real time threads.</span></span> <span data-ttu-id="6cf9a-204">Wenn das System kein Hyperthreading verwendet, muss nur sichergestellt werden, dass die CPU-Standardsätze nicht den gleichen Kern wie der CPU-Satz enthält, der Ihren Audio-Thread ausführt.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-204">If the system is not hyperthreading, it is only necessary to make sure that the default CPU sets do not include the same core as the CPU set running your audio thread.</span></span>

<span data-ttu-id="6cf9a-205">Ein Beispiel für das Organisieren von Threads basierend auf physischen Kernen finden Sie im CPUSets-Beispiel, das im GitHub-Repository verfügbar ist, das im Abschnitt [Zusätzliche Ressourcen](#additional-resources) verlinkt ist.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-205">An example of organizing threads based on physical cores can be found in the CPUSets sample available on the GitHub repository linked in the [Additional resources](#additional-resources) section.</span></span>

### <a name="reducing-the-cost-of-cache-coherence-with-last-level-cache"></a><span data-ttu-id="6cf9a-206">Senken der Kosten der Cache-Kohärenz mit Cache der letzten Ebene</span><span class="sxs-lookup"><span data-stu-id="6cf9a-206">Reducing the cost of cache coherence with last level cache</span></span>

<span data-ttu-id="6cf9a-207">Cache-Kohärenz bedeutet, dass gecachter Arbeitsspeicher der gleiche für mehrere Hardwareressourcen ist, die auf dieselben Daten zugreifen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-207">Cache coherency is the concept that cached memory is the same across multiple hardware resources that act on the same data.</span></span> <span data-ttu-id="6cf9a-208">Wenn Threads auf verschiedenen Kernen geplant sind, aber auf dieselben Daten zugreifen, arbeiten sie möglicherweise mit separaten Kopien dieser Daten in verschiedenen Caches.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-208">If threads are scheduled on different cores, but work on the same data, they may be working on separate copies of that data in different caches.</span></span> <span data-ttu-id="6cf9a-209">Um richtige Ergebnisse zu erhalten, muss die Kohärenz dieser Caches gewährleistet sein.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-209">In order to get correct results, these caches must be kept coherent with each other.</span></span> <span data-ttu-id="6cf9a-210">Die Aufrechterhaltung der Kohärenz zwischen mehreren Caches ist relativ teuer, ist aber erforderlich, damit ein System mit mehreren Kernen ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-210">Maintaining coherency between multiple caches is relatively expensive, but necessary for any multi-core system to operate.</span></span> <span data-ttu-id="6cf9a-211">Darüber hinaus liegt es völlig außerhalb der Kontrolle des Client-Codes; das zugrunde liegende System arbeitet unabhängig daran, Caches auf dem neuesten Stand zu halten, indem es auf zwischen Kernen freigegebene Speicherressourcen zugreift.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-211">Additionally, it is completely out of the control of client code; the underlying system works independently to keep caches up to date by accessing shared memory resources between cores.</span></span>

<span data-ttu-id="6cf9a-212">Wenn Ihr Spiel mehrere Threads verwendet, die gemeinsam eine besonders große Menge an Daten nutzen, können Sie die Kosten der Cache-Kohärenz minimieren, indem Sie sicherstellen, dass sie auf CPU-Sätzen geplant werden, die einen Cache der letzten Ebene teilen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-212">If your game has multiple threads that share an especially large amount of data, you can minimize the cost of cache coherency by ensuring that they are scheduled on CPU sets that share a last level cache.</span></span> <span data-ttu-id="6cf9a-213">Der Cache der letzten Ebene ist der langsamste Cache, der für einen Kern auf Systemen zur Verfügung steht, die keine NUMA-Knoten verwenden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-213">The last level cache is the slowest cache available to a core on systems that do not utilize NUMA nodes.</span></span> <span data-ttu-id="6cf9a-214">Es kommt äußerst selten vor, dass ein Spiele-PC NUMA-Knoten nutzt.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-214">It is extremely rare for a gaming PC to utilize NUMA nodes.</span></span> <span data-ttu-id="6cf9a-215">Wenn Kerne keinen Cache der letzten Ebene teilen, müsste zur Aufrechterhaltung der Kohärenz auf Speicherressourcen höherer Ebene und somit langsamere Speicherressourcen zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-215">If cores do not share a last level cache, maintaining coherency would require accessing higher level, and therefore slower, memory resources.</span></span> <span data-ttu-id="6cf9a-216">Durch eine Bindung von zwei Threads an separate CPU-Sätze, die einen Cache und einen physischen Kern teilen, kann eine noch bessere Leistung erzielt werden, als durch deren Planung auf separaten physischen Kernen, wenn sie in einem beliebigen Frame nicht mehr als 50% der Zeit benötigen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-216">Locking two threads to separate CPU sets that share a cache and a physical core may provide even better performance than scheduling them on separate physical cores if they do not require more than 50% of the time in any given frame.</span></span> 

<span data-ttu-id="6cf9a-217">In diesem Codebeispiel wird veranschaulicht, wie Sie ermitteln, ob Threads, die häufig kommunizieren, einen Cache der letzten Ebene teilen können.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-217">This code example shows how to determine whether threads that communicate frequently can share a last level cache.</span></span>

```
unsigned long retsize = 0;
(void)GetSystemCpuSetInformation(nullptr, 0, &retsize,
    GetCurrentProcess(), 0);
 
std::unique_ptr<uint8_t[]> data(new uint8_t[retsize]);
if (!GetSystemCpuSetInformation(
    reinterpret_cast<PSYSTEM_CPU_SET_INFORMATION>(data.get()),
    retsize, &retsize, GetCurrentProcess(), 0))
{
    // Error!
}
 
unsigned long count = retsize / sizeof(SYSTEM_CPU_SET_INFORMATION);
bool sharedcache = false;
 
std::map<unsigned char, std::vector<SYSTEM_CPU_SET_INFORMATION>> cachemap;
for (size_t i = 0; i < count; ++i)
{
    auto cpuset = reinterpret_cast<PSYSTEM_CPU_SET_INFORMATION>(data.get())[i];
    if (cpuset.Type == CPU_SET_INFORMATION_TYPE::CpuSetInformation)
    {
        if (cachemap.find(cpuset.CpuSet.LastLevelCacheIndex) == cachemap.end())
        {
            std::pair<unsigned char, std::vector<SYSTEM_CPU_SET_INFORMATION>> newvalue;
            newvalue.first = cpuset.CpuSet.LastLevelCacheIndex;
            newvalue.second.push_back(cpuset);
            cachemap.insert(newvalue);
        }
        else
        {
            sharedcache = true;
            cachemap[cpuset.CpuSet.LastLevelCacheIndex].push_back(cpuset);
        }
    }
}
```

<span data-ttu-id="6cf9a-218">Das in Abbildung 1 dargestellte Cache-Layout ist ein Beispiel für die Art von Layout, die Sie möglicherweise bei einem System sehen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-218">The cache layout illustrated in Figure 1 is an example of the type of layout you might see from a system.</span></span> <span data-ttu-id="6cf9a-219">In dieser Abbildung sehen Sie eine Darstellung der Caches in einem Microsoft Lumia 950.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-219">This figure is an illustration of the caches found in a Microsoft Lumia 950.</span></span> <span data-ttu-id="6cf9a-220">Threadübergreifende Kommunikation zwischen CPU 256 und CPU 260 würde erheblichen Overhead verursachen, da das System seine L2-Caches kohärent halten müsste.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-220">Inter-thread communication occurring between CPU 256 and CPU 260 would incur significant overhead because it would require the system to keep their L2 caches coherent.</span></span>

**<span data-ttu-id="6cf9a-221">Abbildung1.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-221">Figure 1.</span></span> <span data-ttu-id="6cf9a-222">Cache-Architektur in einem Microsoft Lumia 950-Gerät.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-222">Cache architecture found on a Microsoft Lumia 950 device.</span></span>**

![Lumia 950-Cache](images/cpusets-lumia950cache.png)

## <a name="summary"></a><span data-ttu-id="6cf9a-224">Zusammenfassung</span><span class="sxs-lookup"><span data-stu-id="6cf9a-224">Summary</span></span>

<span data-ttu-id="6cf9a-225">Die für UWP-Entwicklung verfügbare CPUSets-API bietet eine beträchtliche Menge an Informationen und Kontrolle über Ihre Multithreading-Optionen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-225">The CPUSets API available for UWP development provides a considerable amount of information and control over your multithreading options.</span></span> <span data-ttu-id="6cf9a-226">Der zusätzliche Komplexität im Vergleich zu früheren Multithread-APIs für die Windows-Entwicklung ist mit einer Lernkurve verbunden. Die gestiegene Flexibilität ermöglicht aber letztendlich eine bessere Leistung auf unterschiedlichen Verbraucher-PCs und anderen Hardwarezielen.</span><span class="sxs-lookup"><span data-stu-id="6cf9a-226">The added complexities compared to previous multithreaded APIs for Windows development has some learning curve, but the increased flexibility ultimately allows for better performance across a range of consumer PCs and other hardware targets.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="6cf9a-227">Weitere Ressourcen</span><span class="sxs-lookup"><span data-stu-id="6cf9a-227">Additional resources</span></span>
- [<span data-ttu-id="6cf9a-228">CPU-Sätze (MSDN)</span><span class="sxs-lookup"><span data-stu-id="6cf9a-228">CPU Sets (MSDN)</span></span>](https://msdn.microsoft.com/library/windows/desktop/mt186420(v=vs.85).aspx)
- [<span data-ttu-id="6cf9a-229">Von ATG bereitgestelltes CPUSets-Beispiel</span><span class="sxs-lookup"><span data-stu-id="6cf9a-229">CPUSets sample provided by ATG</span></span>](https://github.com/Microsoft/Xbox-ATG-Samples/tree/master/Samples/System/CPUSets)
- [<span data-ttu-id="6cf9a-230">UWP auf XboxOne</span><span class="sxs-lookup"><span data-stu-id="6cf9a-230">UWP on Xbox One</span></span>](index.md)

