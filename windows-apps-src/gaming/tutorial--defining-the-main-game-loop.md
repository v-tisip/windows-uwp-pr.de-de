---
author: joannaleecy
title: Definieren des Hauptobjekts für das Spiel
description: In diesem Abschnitt widmen wir uns den Details des Hauptobjekts des Beispielspiels. Außerdem erfahren Sie, wie die implementierten Regeln in Interaktionen mit der Spielwelt übersetzt werden.
ms.assetid: 6afeef84-39d0-cb78-aa2e-2e42aef936c9
ms.author: joanlee
ms.date: 10/24/2017
ms.topic: article
keywords: Windows10, UWP, Spiele, Hauptobjekt
ms.localizationpriority: medium
ms.openlocfilehash: b94d7139f35b3a18edd66af9959a0958d0bdcbc1
ms.sourcegitcommit: ca96031debe1e76d4501621a7680079244ef1c60
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/30/2018
ms.locfileid: "5815781"
---
# <a name="define-the-main-game-object"></a><span data-ttu-id="b3c97-104">Definieren des Hauptobjekts für das Spiel</span><span class="sxs-lookup"><span data-stu-id="b3c97-104">Define the main game object</span></span>

<span data-ttu-id="b3c97-105">Nachdem Sie das grundlegende Framework des beispielspiels angeordnet und implementiert einen Zustandsautomaten, der den allgemeinen Benutzer- und Systemverhalten behandelt haben, sollten Sie untersuchen der Regeln und spielmechaniken, die das Spielbeispiel in einem Spiel zu verwandeln.</span><span class="sxs-lookup"><span data-stu-id="b3c97-105">Once you’ve laid out the basic framework of the sample game and implemented a state machine that handles the high-level user and system behaviors, you’ll want to examine the rules and mechanics that turn the game sample into a game.</span></span> <span data-ttu-id="b3c97-106">Sehen wir uns die Details des Hauptobjekts für das Spielbeispiel, und wie Sie Spiele Regeln in Interaktionen mit der spielwelt übersetzt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-106">Let’s look at the details of the game sample's main object, and how to translate game rules into interactions with the game world.</span></span>

>[!Note]
><span data-ttu-id="b3c97-107">Wenn Sie den neuesten Code für dieses Beispiel noch nicht heruntergeladen haben, wechseln Sie zu [Direct3D-Spielbeispiel](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/Simple3DGameDX).</span><span class="sxs-lookup"><span data-stu-id="b3c97-107">If you haven't downloaded the latest game code for this sample, go to [Direct3D game sample](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/Simple3DGameDX).</span></span> <span data-ttu-id="b3c97-108">Dieses Beispiel gehört zu einer großen Sammlung von UWP-Featurebeispielen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-108">This sample is part of a large collection of UWP feature samples.</span></span> <span data-ttu-id="b3c97-109">Anweisungen zum Herunterladen des Beispiels finden Sie unter [Abrufen der UWP-Beispiele von GitHub](https://docs.microsoft.com/windows/uwp/get-started/get-uwp-app-samples).</span><span class="sxs-lookup"><span data-stu-id="b3c97-109">For instructions on how to download the sample, see [Get the UWP samples from GitHub](https://docs.microsoft.com/windows/uwp/get-started/get-uwp-app-samples).</span></span>

## <a name="objective"></a><span data-ttu-id="b3c97-110">Ziel</span><span class="sxs-lookup"><span data-stu-id="b3c97-110">Objective</span></span>

<span data-ttu-id="b3c97-111">Hier erfahren Sie, wie Sie grundlegender Entwicklungstechniken zum Implementieren der Spielregeln und Mechanismen für ein UWP-DirectX-Spiel.</span><span class="sxs-lookup"><span data-stu-id="b3c97-111">Learn how to apply basic development techniques to implement game rules and mechanics for a UWP DirectX game.</span></span>

## <a name="main-game-object"></a><span data-ttu-id="b3c97-112">Hauptobjekt für das Spiel</span><span class="sxs-lookup"><span data-stu-id="b3c97-112">Main game object</span></span>

<span data-ttu-id="b3c97-113">In diesem Beispielspiel ist __Simple3DGame__ die hauptspielobjekts-Klasse.</span><span class="sxs-lookup"><span data-stu-id="b3c97-113">In this sample game, __Simple3DGame__ is the main game object class.</span></span> <span data-ttu-id="b3c97-114">Eine Instanz des __Simple3DGame__ -Objekts wird in der __App:: Load__ -Methode konstruiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-114">An instance of __Simple3DGame__ object is constructed in the __App::Load__ method.</span></span>

<span data-ttu-id="b3c97-115">Das Klassenobjekt __Simple3DGame__ :</span><span class="sxs-lookup"><span data-stu-id="b3c97-115">The __Simple3DGame__ class object:</span></span>
* <span data-ttu-id="b3c97-116">Gibt an, das Gameplay-Logik implementiert</span><span class="sxs-lookup"><span data-stu-id="b3c97-116">Specifies implementation of the gameplay logic</span></span>
* <span data-ttu-id="b3c97-117">Enthält Methoden, die kommunizieren:</span><span class="sxs-lookup"><span data-stu-id="b3c97-117">Contains methods that communicate:</span></span>
    * <span data-ttu-id="b3c97-118">Ändert sich der Spielzustand an den im app-Framework definierten Zustandsautomaten.</span><span class="sxs-lookup"><span data-stu-id="b3c97-118">Changes in the game state to the state machine defined in the app framework.</span></span>
    * <span data-ttu-id="b3c97-119">Ändert sich der Spielzustand von der app an das spielobjekt selbst.</span><span class="sxs-lookup"><span data-stu-id="b3c97-119">Changes in the game state from the app to the game object itself.</span></span>
    * <span data-ttu-id="b3c97-120">Details zum Aktualisieren des Spiels UI (Overlay und Head-Up-Display), Animationen und Physik (Dynamik).</span><span class="sxs-lookup"><span data-stu-id="b3c97-120">Details for updating the game's UI (overlay and heads-up display), animations, and physics (the dynamics).</span></span>

    >[!Note]
    ><span data-ttu-id="b3c97-121">Aktualisierung von Grafiken erfolgt über die __GameRenderer__ -Klasse, die Methoden zum Abrufen und Verwenden von Grafikressourcen Gerät vom Spiel verwendeten enthält.</span><span class="sxs-lookup"><span data-stu-id="b3c97-121">Updating of graphics is handled by the __GameRenderer__ class, which contains methods to obtain and use graphics device resources used by the game.</span></span> <span data-ttu-id="b3c97-122">Weitere Informationen finden Sie unter [Rendering-Framework I: Einführung in das Rendering](tutorial--assembling-the-rendering-pipeline.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-122">For more info, see [Rendering framework I: Intro to rendering](tutorial--assembling-the-rendering-pipeline.md).</span></span>

* <span data-ttu-id="b3c97-123">Dient als Container für die Daten, die eine Ebene, spielsitzung, oder eine Lebensdauer ausmachen – je nachdem, wie Sie Ihr Spiel auf hoher Ebene definieren.</span><span class="sxs-lookup"><span data-stu-id="b3c97-123">Serves as a container for the data that defines a game session, level, or lifetime, depending on how you define your game at a high level.</span></span> <span data-ttu-id="b3c97-124">In diesem Fall die spielzustandsdaten ist für die Lebensdauer des Spiels und einmal, wenn der Benutzer das Spiel startet, initialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-124">In this case, the game state data is for the lifetime of the game, and is initialized one time when a user launches the game.</span></span>

<span data-ttu-id="b3c97-125">Um die Methoden und in dieses Klassenobjekt definierte Daten anzuzeigen, wechseln Sie zu [Simple3DGame-Objekts](#simple3dgame-object).</span><span class="sxs-lookup"><span data-stu-id="b3c97-125">To view methods and data defined in this class object, go to [Simple3DGame object](#simple3dgame-object).</span></span>

## <a name="initialize-and-start-the-game"></a><span data-ttu-id="b3c97-126">Initialisieren und Starten des Spiels</span><span class="sxs-lookup"><span data-stu-id="b3c97-126">Initialize and start the game</span></span>

<span data-ttu-id="b3c97-127">Wenn ein Spieler das Spiel startet, muss das Spielobjekt den eigenen Zustand initialisieren, das Overlay erstellen und hinzufügen, die Variablen zur Nachverfolgung der Erfolge des Spielers festlegen und die Objekte instanziieren, die zum Erstellen der Level benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-127">When a player starts the game, the game object must initialize its state, create and add the overlay, set the variables that track the player's performance, and instantiate the objects that it will use to build the levels.</span></span> <span data-ttu-id="b3c97-128">In diesem Beispiel geschieht dies, wenn die neue __GameMain__ -Instanz in [__App:: Load__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/App.cpp#L115-L123)erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="b3c97-128">In this sample, this is done when the new __GameMain__ instance is created in [__App::Load__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/App.cpp#L115-L123).</span></span> 

<span data-ttu-id="b3c97-129">Das spielobjekt __Simple3DGame__, wird im __GameMain__ -Konstruktor erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-129">The game object, __Simple3DGame__, is created in the __GameMain__ constructor.</span></span> <span data-ttu-id="b3c97-130">Es wird mithilfe der [__Simple3DGame::Initialize__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L54-L250) Methode während der [asynchronen erstellen Aufgabe im __GameMain__ -Konstruktor](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L65-L74)initialisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-130">It is then initialized using the [__Simple3DGame::Initialize__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L54-L250) method during the [async create task in the __GameMain__ constructor](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L65-L74).</span></span>

### <a name="simple3dgameinitialize-method"></a><span data-ttu-id="b3c97-131">Simple3DGame::Initialize-Methode</span><span class="sxs-lookup"><span data-stu-id="b3c97-131">Simple3DGame::Initialize method</span></span>

<span data-ttu-id="b3c97-132">Das Beispielspiel richtet die folgenden Komponenten in das spielobjekt:</span><span class="sxs-lookup"><span data-stu-id="b3c97-132">The game sample sets up the following components in the game object:</span></span>

* <span data-ttu-id="b3c97-133">Ein neues Audiowiedergabeobjekt wird erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-133">A new audio playback object is created.</span></span>
* <span data-ttu-id="b3c97-134">Arrays für die Grafikgrundtypen des Spiels werden erstellt (einschließlich Arrays für die Levelgrundtypen, Munition und Hindernisse).</span><span class="sxs-lookup"><span data-stu-id="b3c97-134">Arrays for the game's graphic primitives are created, including arrays for the level primitives, ammo, and obstacles.</span></span>
* <span data-ttu-id="b3c97-135">Ein Speicherort für die Spielzustandsdaten mit der Bezeichnung *Game* wird erstellt und am durch [**ApplicationData::Current**](https://msdn.microsoft.com/library/windows/apps/br241619) festgelegten Speicherort der App-Dateneinstellungen platziert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-135">A location for saving game state data is created, named *Game*, and placed in the app data settings storage location specified by [**ApplicationData::Current**](https://msdn.microsoft.com/library/windows/apps/br241619).</span></span>
* <span data-ttu-id="b3c97-136">Ein Spieltimer und die anfängliche spielinterne Overlaybitmap werden erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-136">A game timer and the initial in-game overlay bitmap are created.</span></span>
* <span data-ttu-id="b3c97-137">Eine neue Kamera mit einem spezifischen Satz von Ansichts- und Projektionsparametern wird erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-137">A new camera is created with a specific set of view and projection parameters.</span></span>
* <span data-ttu-id="b3c97-138">Das Eingabegerät (Controller) wird auf die gleiche Ausgangsausrichtung festgelegt wie die Kamera, sodass die Ausgangsposition der Steuerung exakt der Kameraposition entspricht.</span><span class="sxs-lookup"><span data-stu-id="b3c97-138">The input device (the controller) is set to the same starting pitch and yaw as the camera, so the player has a 1-to-1 correspondence between the starting control position and the camera position.</span></span>
* <span data-ttu-id="b3c97-139">Das Spielerobjekt wird erstellt und aktiviert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-139">The player object is created and set to active.</span></span> <span data-ttu-id="b3c97-140">Wir verwenden ein kugelobjekt, die Nähe des Spielers zu Wänden und Hindernissen zu ermitteln und um zu verhindern, dass die Kamera in der Lage, die immersionseffekt nicht beeinträchtigt wird möglicherweise platziert abrufen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-140">We use a sphere object to detect the player's proximity to walls and obstacles and to keep the camera from getting placed in a position that might break immersion.</span></span>
* <span data-ttu-id="b3c97-141">Der Spielweltgrundtyp wird erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-141">The game world primitive is created.</span></span>
* <span data-ttu-id="b3c97-142">Die Zylinderhindernisse werden erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-142">The cylinder obstacles are created.</span></span>
* <span data-ttu-id="b3c97-143">Die Ziele (**Face**-Objekte) werden erstellt und nummeriert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-143">The targets (**Face** objects) are created and numbered.</span></span>
* <span data-ttu-id="b3c97-144">Die Munitionskugeln werden erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-144">The ammo spheres are created.</span></span>
* <span data-ttu-id="b3c97-145">Die Level werden erstellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-145">The levels are created.</span></span>
* <span data-ttu-id="b3c97-146">Der Highscore wird geladen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-146">The high score is loaded.</span></span>
* <span data-ttu-id="b3c97-147">Alle ggf. zuvor gespeicherten Spielzustände werden geladen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-147">Any prior saved game state is loaded.</span></span>

<span data-ttu-id="b3c97-148">Das Spiel besitzt nun Instanzen aller wichtigen Komponenten: Spielwelt, Spieler, Hindernisse, Ziele und Munitionskugeln.</span><span class="sxs-lookup"><span data-stu-id="b3c97-148">The game now has instances of all the key components: the world, the player, the obstacles, the targets, and the ammo spheres.</span></span> <span data-ttu-id="b3c97-149">Außerdem besitzt es Instanzen der Level. Diese stehen für Konfigurationen aller oben genannten Komponenten und ihrer Verhalten für die einzelnen spezifischen Level.</span><span class="sxs-lookup"><span data-stu-id="b3c97-149">It also has instances of the levels, which represent configurations of all of the above components and their behaviors for each specific level.</span></span> <span data-ttu-id="b3c97-150">Im nächsten Abschnitt widmen wir uns der Levelerstellung des Spiels.</span><span class="sxs-lookup"><span data-stu-id="b3c97-150">Let's see how the game builds the levels.</span></span>

## <a name="build-and-load-game-levels"></a><span data-ttu-id="b3c97-151">Erstellen und Laden von spiellevels</span><span class="sxs-lookup"><span data-stu-id="b3c97-151">Build and load game levels</span></span>

<span data-ttu-id="b3c97-152">Die meisten die schwere Aufgabe für den Level Bau erfolgt in den __Level.h/.cpp__ -Dateien im Ordner " __GameLevels__ " der Beispiel-Lösung gefunden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-152">Most of the heavy lifting for the level construction is done in the __Level.h/.cpp__ files found in the __GameLevels__ folder of the sample solution.</span></span> <span data-ttu-id="b3c97-153">Da es auf eine sehr spezifische Implementierung konzentriert, wird nicht wir ihnen hier behandelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-153">Because it focuses on a very specific implementation, we won't be covering them here.</span></span> <span data-ttu-id="b3c97-154">Entscheidend ist in diesem Zusammenhang, dass der Code für die einzelnen Levels jeweils als separates __LevelN__-Objekt ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="b3c97-154">The important thing is that the code for each level is run as a separate __LevelN__ object.</span></span> <span data-ttu-id="b3c97-155">Wenn Sie das Spiel erweitern möchten, können Sie ein Objekt **Ebene** erstellen, die eine zugewiesene Nummer als Parameter annimmt und nach dem Zufallsprinzip platziert die Hindernisse und Ziele.</span><span class="sxs-lookup"><span data-stu-id="b3c97-155">If you'd like to extend the game, you can create a **Level** object that takes an assigned number as a parameter and randomly places the obstacles and targets.</span></span> <span data-ttu-id="b3c97-156">Oder Sie können es levelkonfigurationsdaten aus einer Ressourcendatei oder sogar aus dem Internet geladen haben.</span><span class="sxs-lookup"><span data-stu-id="b3c97-156">Or, you can have it load level configuration data from a resource file, or even the Internet.</span></span>

## <a name="define-the-game-play"></a><span data-ttu-id="b3c97-157">Definieren Sie das Spiel</span><span class="sxs-lookup"><span data-stu-id="b3c97-157">Define the game play</span></span>

<span data-ttu-id="b3c97-158">Wir verfügen nun über alle Komponenten, die wir benötigen, um das Spiel zusammenzufügen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-158">At this point, we have all the components we need to assemble the game.</span></span> <span data-ttu-id="b3c97-159">Die Level wurden auf Grundlage der Grundtypen im Speicher konstruiert und sind bereit für die Interaktion des Spielers.</span><span class="sxs-lookup"><span data-stu-id="b3c97-159">The levels have been constructed in memory from the primitives, and are ready for the player to start interacting with.</span></span>

<span data-ttu-id="b3c97-160">Codedateien gute Spiele reagieren sofort spielereingaben und liefern umgehend Feedback.</span><span class="sxs-lookup"><span data-stu-id="b3c97-160">Tthe best games react instantly to player input, and provide immediate feedback.</span></span> <span data-ttu-id="b3c97-161">Dies gilt für jede Art von Spiel von Twitch-Aktion, in Echtzeit First-Person-Shooter- rundenbasiertes Strategiespiel.</span><span class="sxs-lookup"><span data-stu-id="b3c97-161">This is true for any type of a game, from twitch-action, real-time First-person shooters to thoughtful, turn-based strategy games.</span></span>

### <a name="simple3dgamerungame-method"></a><span data-ttu-id="b3c97-162">Simple3DGame::RunGame-Methode</span><span class="sxs-lookup"><span data-stu-id="b3c97-162">Simple3DGame::RunGame method</span></span>

<span data-ttu-id="b3c97-163">Wenn Sie eine Ebene wiedergeben, ist das Spiel im Zustand " __Dynamics__ ".</span><span class="sxs-lookup"><span data-stu-id="b3c97-163">When playing a level, the game is in the __Dynamics__ state.</span></span> 

<span data-ttu-id="b3c97-164">[__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329) ist die wichtigsten Update-Schleife, die den Status der Anwendung einmal pro Frame aktualisiert, wie unten dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-164">[__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329) is the main update loop that updates the application state once per frame as shown below.</span></span> <span data-ttu-id="b3c97-165">In der Update-Schleife ruft es die [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) -Methode, um die Arbeit behandelt werden, wenn das Spiel im Zustand " __Dynamics__ " befindet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-165">In the update loop, it calls the [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) method to handle the work if the game is in the __Dynamics__ state.</span></span>

```cpp
// Updates the application state once per frame.
void GameMain::Update()
{
    m_controller->Update(); //the controller instance has its own update loop.

    switch (m_updateState)
    {
        //...

    case UpdateEngineState::Dynamics:
        if (m_controller->IsPauseRequested())
        {
            //...
        }
        else
        {
            GameState runState = m_game->RunGame(); //when playing a level, the game is in the Dynamics state. Work is handled by Simple3DGame::RunGame method.
            switch (runState)
            {
                
      //...
```
          
<span data-ttu-id="b3c97-166">[__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) verarbeitet den Satz von Daten, die den aktuellen Zustand des das Spiel für die aktuelle Iteration der spielschleife definiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-166">[__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) handles the set of data that defines the current state of the game play for the current iteration of the game loop.</span></span>

<span data-ttu-id="b3c97-167">Spielablauf Logik im __RunGame__:</span><span class="sxs-lookup"><span data-stu-id="b3c97-167">Game flow logic in __RunGame__:</span></span>
*  <span data-ttu-id="b3c97-168">Die Methode aktualisiert den Zeitgeber, der die Sekunden bis zum Levelabschluss herunterzählt, und überprüft, ob die Zeit für den Level abgelaufen ist.</span><span class="sxs-lookup"><span data-stu-id="b3c97-168">The method updates the timer that counts down the seconds until the level is completed, and tests to see if the level's time has expired.</span></span> <span data-ttu-id="b3c97-169">Dies ist eine der Regeln des Spiels: beim Zeit abläuft, und alle Ziele haben nicht aufgenommen wurde, ist es Spiels entspannt zurücklehnen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-169">This is one of the rules of the game: when time runs out and all the targets have not been shot, it's game over.</span></span>
*  <span data-ttu-id="b3c97-170">Ist die Zeit abgelaufen, legt die Methode den Spielzustand **TimeExpired** fest und kehrt zur **Update**-Methode im vorherigen Code zurück.</span><span class="sxs-lookup"><span data-stu-id="b3c97-170">If time has run out, the method sets the **TimeExpired** game state, and returns to the **Update** method in the previous code.</span></span>
*  <span data-ttu-id="b3c97-171">Ist die Zeit noch nicht abgelaufen, wird für den Bewegungs- und Blickrichtungscontroller eine aktualisierte Kameraposition abgefragt. Genauer gesagt: eine Aktualisierung des Blickwinkels – ausgehend von der Kameraebene (Blickrichtung des Spielers) – und des Abstands, um den sich der Blickwinkel seit der letzten Controllerabfrage bewegt hat.</span><span class="sxs-lookup"><span data-stu-id="b3c97-171">If time remains, the move-look controller is polled for an update to the camera position; specifically, an update to the angle of the view normal projecting from the camera plane (where the player is looking), and the distance that angle has moved from the previous time the controller was polled.</span></span>
*  <span data-ttu-id="b3c97-172">Die Kamera wird auf der Grundlage der neuen Daten des Bewegungs- und Blickrichtungscontrollers aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-172">The camera is updated based on the new data from the move-look controller.</span></span>
*  <span data-ttu-id="b3c97-173">Die Dynamik (also die Animationen und das Verhalten von Objekten in der Spielwelt, die nicht vom Spieler gesteuert werden) wird aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-173">The dynamics, or the animations and behaviors of objects in the game world independent of player control, are updated.</span></span> <span data-ttu-id="b3c97-174">In diesem Beispielspiel wird die [__UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) -Methode aufgerufen, um die Bewegung die Munition, die ausgelöst wurde, die Animation der säulenhindernisse und die Bewegung der Ziele zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="b3c97-174">In this game sample, the [__UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) method is called to update the motion of the ammo spheres that have been fired, the animation of the pillar obstacles and the movement of the targets.</span></span> <span data-ttu-id="b3c97-175">Weitere Informationen finden Sie unter [Aktualisieren die spielwelt](#update-the-game-world).</span><span class="sxs-lookup"><span data-stu-id="b3c97-175">For more information, see [Update the game world](#update-the-game-world).</span></span>
*  <span data-ttu-id="b3c97-176">Die Methode überprüft, ob die Kriterien für den erfolgreichen Abschluss eines Levels erfüllt sind.</span><span class="sxs-lookup"><span data-stu-id="b3c97-176">The method checks to see if the criteria for the successful completion of a level have been met.</span></span> <span data-ttu-id="b3c97-177">Ist dies der Fall, wird der endgültige Punktestand für das Level festgelegt und überprüft, ob es sich um das letzte Level (von sechs) handelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-177">If so, it finalizes the score for the level and checks to see if this is the last level (of 6).</span></span> <span data-ttu-id="b3c97-178">Ist dies der Fall, gibt die Methode den Spielzustand **GameComplete** zurück. Andernfalls gibt sie den Spielzustand __LevelComplete__ zurück.</span><span class="sxs-lookup"><span data-stu-id="b3c97-178">If it's the last level, the method returns the **GameComplete** game state; otherwise, it returns the __LevelComplete__ game state.</span></span>
*  <span data-ttu-id="b3c97-179">Wurde das Level nicht abgeschlossen, legt die Methode den Spielzustand auf __Active__ fest und springt zurück.</span><span class="sxs-lookup"><span data-stu-id="b3c97-179">If the level isn't complete, the method sets the game state to __Active__ and returns.</span></span>

## <a name="update-the-game-world"></a><span data-ttu-id="b3c97-180">Aktualisieren der spielwelt</span><span class="sxs-lookup"><span data-stu-id="b3c97-180">Update the game world</span></span>

<span data-ttu-id="b3c97-181">In diesem Beispiel wenn das Spiel ausgeführt wird, wird die [__Simple3DGame::UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) -Methode aufgerufen von der [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) -Methode (die [__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329)aufgerufen wird) zum Aktualisieren von Objekten, die in einem Spiel Szene gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-181">In this sample, when the game is running, the [__Simple3DGame::UpdateDynamics()__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L436-L856) method is called from the [__Simple3DGame::RunGame__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/Simple3DGame.cpp#L337-L418) method (which is called from [__GameMain::Update__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L261-L329)) to update objects that are rendered in a game scene.</span></span>

<span data-ttu-id="b3c97-182">In der Schleife __UpdateDynamics__ Aufrufen von Methoden, mit denen die spielwelt in Bewegung, unabhängig von der Spieler setzen Eingabe Erstellen einer immersiven Spielerlebnis und stellen die Ebene *Fotosequenz*.</span><span class="sxs-lookup"><span data-stu-id="b3c97-182">In the __UpdateDynamics__ loop, call methods that are used to set the game world in motion, independent of the player input, create an immersive game experience and make the level come *alive*.</span></span> <span data-ttu-id="b3c97-183">Dazu gehören Grafiken, die gerendert werden müssen, und durch die Animation ausgeführt, zu einer lebenden, Welt befinden, auch wenn es keine Eingaben des Spielers ist anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-183">This includes graphics that needs to be rendered and running animation loops to bring about a living, breathing world even when there's no player input.</span></span> <span data-ttu-id="b3c97-184">Beispielsweise Bäume weichen sich im Wind, Wellen cresting Küste, Maschinen Rauchen und Außerirdische Monster Strecken und bewegen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-184">For example, trees swaying in the wind, waves cresting along shore lines, machinery smoking, and alien monsters stretching and moving around.</span></span> <span data-ttu-id="b3c97-185">Hierzu gehört auch die Interaktion zwischen Objekten (beispielsweise Kollisionen zwischen der Spielerkugel und der Welt oder zwischen der Munition und den Hindernissen oder Zielen).</span><span class="sxs-lookup"><span data-stu-id="b3c97-185">It also encompasses the interaction between objects, including collisions between the player sphere and the world, or between the ammo and the obstacles and targets.</span></span>

<span data-ttu-id="b3c97-186">Die spielschleife sollten immer eine regelmäßige Aktualisierung der spielwelt, ob Spiellogik, physischen Algorithmen abhängig ist oder ob es einfach ist zufällige, außer wenn das Spiel nicht explizit angehalten wurde.</span><span class="sxs-lookup"><span data-stu-id="b3c97-186">The game loop should always keep updating the game world whether it's based on game logic, physical algorithms, or whether it's just plain random, except when the game is specifically paused.</span></span> 

<span data-ttu-id="b3c97-187">Im Beispielspiel wird dieses Prinzip als *Dynamik* bezeichnet. Es umfasst das Verhalten der Säulenhindernisse sowie die Bewegung und das physikalische Verhalten abgefeuerter Munitionskugeln.</span><span class="sxs-lookup"><span data-stu-id="b3c97-187">In the game sample, this principle is called *dynamics*, and it encompasses the rise and fall of the pillar obstacles, and the motion and physical behaviors of the ammo spheres as they are fired.</span></span> 

### <a name="simple3dgameupdatedynamics-method"></a><span data-ttu-id="b3c97-188">Simple3DGame::UpdateDynamics-Methode</span><span class="sxs-lookup"><span data-stu-id="b3c97-188">Simple3DGame::UpdateDynamics method</span></span> 

<span data-ttu-id="b3c97-189">Diese Methode behandelt vierBerechnungssätze:</span><span class="sxs-lookup"><span data-stu-id="b3c97-189">This method deals with four sets of computations:</span></span>

* <span data-ttu-id="b3c97-190">Die Positionen der Kugeln für die abgefeuerte Munition in der Spielwelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-190">The positions of the fired ammo spheres in the world.</span></span>
* <span data-ttu-id="b3c97-191">Die Animation der Säulenhindernisse.</span><span class="sxs-lookup"><span data-stu-id="b3c97-191">The animation of the pillar obstacles.</span></span>
* <span data-ttu-id="b3c97-192">Die Überschneidung des Spielers mit den Begrenzungen der Spielwelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-192">The intersection of the player and the world boundaries.</span></span>
* <span data-ttu-id="b3c97-193">Die Kollisionen von Munitionskugeln mit den Hindernissen, den Zielen, anderen Munitionskugeln und der Spielwelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-193">The collisions of the ammo spheres with the obstacles, the targets, other ammo spheres, and the world.</span></span>

<span data-ttu-id="b3c97-194">Bei der Animation der Hindernisse handelt es sich um eine in **Animate.h/.cpp** definierte Schleife.</span><span class="sxs-lookup"><span data-stu-id="b3c97-194">The animation of the obstacles is a loop defined in **Animate.h/.cpp**.</span></span> <span data-ttu-id="b3c97-195">Das Verhalten der Munition und sämtlicher Kollisionen sind durch vereinfachte Physik Algorithmen definiert, im Code angegeben und durch eine Reihe von globalen Konstanten für die spielwelt, einschließlich der Schwerkraft und Materialeigenschaften parametrisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-195">The behavior of the ammo and any collisions are defined by simplified physics algorithms, supplied in the code and parameterized by a set of global constants for the game world, including gravity and material properties.</span></span> <span data-ttu-id="b3c97-196">All dies wird im Koordinatenbereich der Spielwelt berechnet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-196">This is all computed in the game world coordinate space.</span></span>

### <a name="review-the-flow"></a><span data-ttu-id="b3c97-197">Überprüfen Sie den Fluss</span><span class="sxs-lookup"><span data-stu-id="b3c97-197">Review the flow</span></span>

<span data-ttu-id="b3c97-198">Nun, da wir alle Objekte in der Szene aktualisiert und sämtlicher Kollisionen berechnet haben, müssen wir diese Informationen verwenden, um die entsprechenden sichtbaren Veränderungen zu zeichnen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-198">Now that we've updated all the objects in the scene and calculated any collisions, we need to use this info to draw the corresponding visual changes.</span></span> 

<span data-ttu-id="b3c97-199">Nach Abschluss die aktuelle Iteration der spielschleife der __GameMain::Update()__ Ruft das Beispiel sofort __Render()__ um mithilfe der aktualisierten Objektdaten und generieren eine neue Szene zu der Spieler zu präsentieren, wie hier gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-199">After __GameMain::Update()__ completes the current iteration of the game loop, the sample immediately calls __Render()__ to take the updated object data and generate a new scene to present to the player, as shown here.</span></span> <span data-ttu-id="b3c97-200">Als Nächstes werfen wir einen Blick auf das Rendering.</span><span class="sxs-lookup"><span data-stu-id="b3c97-200">Next, let's take a look at the rendering.</span></span>

```cpp
void GameMain::Run()
{
    while (!m_windowClosed)
    {
        if (m_visible)
        {
            switch (m_updateState)
            {
            case UpdateEngineState::Deactivated:
            case UpdateEngineState::TooSmall:
                // ...
                // otherwise fall through and do normal processing to get the rendering handled.
            default:
                CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);
                Update(); // GameMain::Update calls Simple3DGame::RunGame() if game is in Dynamics state, uses Simple3DGame::UpdateDynamics() to update game world.
                m_renderer->Render(); //Render() is called immediately after the Update() loop
                m_deviceResources->Present();
                m_renderNeeded = false;
            }
        }
        else
        {
            CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessOneAndAllPending);
        }
    }
    m_game->OnSuspending();  // exiting due to window close.  Make sure to save state.
}
```

## <a name="render-the-game-worlds-graphics"></a><span data-ttu-id="b3c97-201">Rendern der spielweltgrafik</span><span class="sxs-lookup"><span data-stu-id="b3c97-201">Render the game world's graphics</span></span>

<span data-ttu-id="b3c97-202">Wir empfehlen, die Grafik in einem Spiel so oft wie möglich (im Höchstfall also bei jeder Iteration der Hauptschleife des Spiels) zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="b3c97-202">We recommend that the graphics in a game update as often as possible, which, at maximum, is every time the main game loop iterates.</span></span> <span data-ttu-id="b3c97-203">Im Zuge der Schleifeniteration wird das Spiel unabhängig von einer Spielereingabe aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-203">As the loop iterates, the game is updated, with or without player input.</span></span> <span data-ttu-id="b3c97-204">Dies ermöglicht eine flüssige Darstellung der berechneten Animationen und Verhalten.</span><span class="sxs-lookup"><span data-stu-id="b3c97-204">This allows the animations and behaviors that are calculated to be displayed smoothly.</span></span> <span data-ttu-id="b3c97-205">Stellen Sie sich nur einmal eine einfache Szene mit Wasser vor, das sich nur bewegt, wenn der Spieler eine Taste drückt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-205">Imagine if we had a simple scene of water that only moved when the player pressed a button.</span></span> <span data-ttu-id="b3c97-206">Das Ergebnis wäre eine schrecklich langweilige Grafik.</span><span class="sxs-lookup"><span data-stu-id="b3c97-206">That would make for terribly boring visuals.</span></span> <span data-ttu-id="b3c97-207">Ein gutes Spiel wird ruckelfrei und flüssig dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-207">A good game looks smooth and fluid.</span></span>

<span data-ttu-id="b3c97-208">Erinnern Sie Schleife des beispielspiels auf, wie oben in [__gamemain:: Run__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L143-L202)dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-208">Recall the sample game's loop as shown above in [__GameMain::Run__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameMain.cpp#L143-L202).</span></span> <span data-ttu-id="b3c97-209">Ist das Hauptfenster des Spiels sichtbar und nicht angedockt oder deaktiviert, werden weiterhin Updates für das Spiel ausgeführt und die Ergebnisse gerendert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-209">If the game's main window is visible, and isn't snapped or deactivated, the game continues to update and render the results of that update.</span></span> <span data-ttu-id="b3c97-210">[__Rendern__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameRenderer.cpp#L474-L624) Methode, die wir untersuchen sind rendert jetzt eine Darstellung dieses Zustands.</span><span class="sxs-lookup"><span data-stu-id="b3c97-210">The [__Render__](https://github.com/Microsoft/Windows-universal-samples/blob/5f0d0912214afc1c2a7c7470203933ddb46f7c89/Samples/Simple3DGameDX/cpp/GameRenderer.cpp#L474-L624) method we're examining now renders a representation of that state.</span></span> <span data-ttu-id="b3c97-211">Dies erfolgt sofort nach dem Aufrufen von zu **Aktualisieren**, einschließlich **RunGame** um Zustände zu aktualisieren, das im vorherigen Abschnitt beschrieben wurde.</span><span class="sxs-lookup"><span data-stu-id="b3c97-211">This is done immediately after a call to **Update**, which includes **RunGame** to update states, which was discussed in the previous section.</span></span>

<span data-ttu-id="b3c97-212">Diese Methode zeichnet die Projektion der dreidimensionalen Welt und legt anschließend das Direct2D-Overlay darüber.</span><span class="sxs-lookup"><span data-stu-id="b3c97-212">This method draws the projection of the 3D world, and then draws the Direct2D overlay on top of it.</span></span> <span data-ttu-id="b3c97-213">Nach Abschluss des Vorgangs zeigt sie die finale Swapchain mit den kombinierten Puffern an.</span><span class="sxs-lookup"><span data-stu-id="b3c97-213">When completed, it presents the final swap chain with the combined buffers for display.</span></span>

>[!Note]
><span data-ttu-id="b3c97-214">Es gibt für das Direct2D Overlay zwei Zustände: eines, in dem das Spiel die Überlagerung von Spieledaten, das die Bitmap für das pausenmenü und, wo zeigt das Spiel das Fadenkreuz sowie die Rechtecke für den bewegungs-/ Touchscreen enthält anzeigt, Controller.</span><span class="sxs-lookup"><span data-stu-id="b3c97-214">There are two states for the sample game's Direct2D overlay: one where the game displays the game info overlay that contains the bitmap for the pause menu, and one where the game displays the cross hairs along with the rectangles for the touchscreen move-look controller.</span></span> <span data-ttu-id="b3c97-215">Der Text mit dem Spielstand wird in beiden Zuständen gezeichnet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-215">The score text is drawn in both states.</span></span> <span data-ttu-id="b3c97-216">Weitere Informationen finden Sie unter [Rendering-Framework I: Einführung in das Rendering](tutorial--assembling-the-rendering-pipeline.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-216">For more information, see [Rendering framework I: Intro to rendering](tutorial--assembling-the-rendering-pipeline.md).</span></span>

### <a name="gamerendererrender-method"></a><span data-ttu-id="b3c97-217">GameRenderer::Render-Methode</span><span class="sxs-lookup"><span data-stu-id="b3c97-217">GameRenderer::Render method</span></span>

```cpp
void GameRenderer::Render()
{
    bool stereoEnabled = m_deviceResources->GetStereoState();

    auto d3dContext = m_deviceResources->GetD3DDeviceContext();
    auto d2dContext = m_deviceResources->GetD2DDeviceContext();
   
        // ...
        if (m_game != nullptr && m_gameResourcesLoaded && m_levelResourcesLoaded)
        {
            // This section is only used after the game state has been initialized and all device
            // resources needed for the game have been created and associated with the game objects.
            //...
            auto objects = m_game->RenderObjects();
            for (auto object = objects.begin(); object != objects.end(); object++)
            {
                (*object)->Render(d3dContext, m_constantBufferChangesEveryPrim.Get()); // Renders the 3D objects
            }

        //...
        d3dContext->BeginEventInt(L"D2D BeginDraw", 1);
        d2dContext->BeginDraw(); //Start drawing the overlays
        
        // To handle the swapchain being pre-rotated, set the D2D transformation to include it.
        d2dContext->SetTransform(m_deviceResources->GetOrientationTransform2D());

        if (m_game != nullptr && m_gameResourcesLoaded)
        {
            // This is only used after the game state has been initialized.
            m_gameHud->Render(m_game); // Renders number of hits, shots, and time
        }

        if (m_gameInfoOverlay->Visible())
        {
            d2dContext->DrawBitmap(     // Renders the game overlay
                m_gameInfoOverlay->Bitmap(),
                m_gameInfoOverlayRect
                );
        }
        //...
    }
}
```

## <a name="simple3dgame-object"></a><span data-ttu-id="b3c97-218">Simple3DGame-Objekts</span><span class="sxs-lookup"><span data-stu-id="b3c97-218">Simple3DGame object</span></span>

<span data-ttu-id="b3c97-219">Dies sind die Methoden und Daten, die in der Klasse __Simple3DGame__ Objekt definiert sind.</span><span class="sxs-lookup"><span data-stu-id="b3c97-219">These are the methods and data that are defined in the __Simple3DGame__ object class.</span></span>

### <a name="methods"></a><span data-ttu-id="b3c97-220">Methoden</span><span class="sxs-lookup"><span data-stu-id="b3c97-220">Methods</span></span>

<span data-ttu-id="b3c97-221">Die internen Methoden auf **Simple3DGame** definiert:</span><span class="sxs-lookup"><span data-stu-id="b3c97-221">The internal methods defined on **Simple3DGame** include:</span></span>

-   <span data-ttu-id="b3c97-222">**Initialisieren**: Legt die Anfangswerte der globalen Variablen fest und initialisiert die Spielobjekte.</span><span class="sxs-lookup"><span data-stu-id="b3c97-222">**Initialize**: Sets the starting values of the global variables and initializes the game objects.</span></span> <span data-ttu-id="b3c97-223">Dies wird im Abschnitt [zu initialisieren und Starten des Spiels](#initialize-and-start-the-game) behandelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-223">This is covered in the [Initialize and start the game](#initialize-and-start-the-game) section.</span></span>
-   <span data-ttu-id="b3c97-224">**LoadGame**: Initialisiert ein neues Level und startet den entsprechenden Ladevorgang.</span><span class="sxs-lookup"><span data-stu-id="b3c97-224">**LoadGame**: Initializes a new level and starts loading it.</span></span>
-   <span data-ttu-id="b3c97-225">**LoadLevelAsync**: Startet eine asynchrone Aufgabe (Wenn Sie mit asynchronen Aufgaben nicht vertraut sind, finden Sie unter [Parallel Patterns Library](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl)) zum Initialisieren des Levels und ruft dann eine asynchrone Aufgabe für den Renderer auf die gerätespezifischen Ebene Ressourcen geladen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-225">**LoadLevelAsync**: Starts an async task (if you're unfamiliar with async tasks, see [Parallel Patterns Library](https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl)) to initialize the level and then invoke an async task on the renderer to load the device specific level resources.</span></span> <span data-ttu-id="b3c97-226">Diese Methode wird in einem gesonderten Thread ausgeführt. Daher können in diesem Thread nur [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379)-Methoden (und keine [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)-Methoden) aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-226">This method runs in a separate thread; as a result, only [**ID3D11Device**](https://msdn.microsoft.com/library/windows/desktop/ff476379) methods (as opposed to [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) methods) can be called from this thread.</span></span> <span data-ttu-id="b3c97-227">Alle Gerätekontextmethoden werden in der **FinalizeLoadLevel**-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-227">Any device context methods are called in the **FinalizeLoadLevel** method.</span></span>
-   <span data-ttu-id="b3c97-228">**FinalizeLoadLevel**: führt alle Aktionen zum Laden des Levels, die im Hauptthread ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="b3c97-228">**FinalizeLoadLevel**: Completes any work for level loading that needs to be done on the main thread.</span></span> <span data-ttu-id="b3c97-229">Dies schließt alle Aufrufe von Direct3D11-Gerätekontextmethoden ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)) ein.</span><span class="sxs-lookup"><span data-stu-id="b3c97-229">This includes any calls to Direct3D 11 device context ([**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385)) methods.</span></span>
-   <span data-ttu-id="b3c97-230">**StartLevel**: das Gameplay für ein neues Level startet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-230">**StartLevel**: Starts the game play for a new level.</span></span>
-   <span data-ttu-id="b3c97-231">**PauseGame**: hält das Spiel an.</span><span class="sxs-lookup"><span data-stu-id="b3c97-231">**PauseGame**: Pauses the game.</span></span>
-   <span data-ttu-id="b3c97-232">**RunGame**: führt eine Iteration der spielschleife.</span><span class="sxs-lookup"><span data-stu-id="b3c97-232">**RunGame**: Runs an iteration of the game loop.</span></span> <span data-ttu-id="b3c97-233">Wird jeweils einmal pro Iteration der Spielschleife von **App::Update** aufgerufen, sofern sich das Spiel im Zustand **Active** befindet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-233">It's called from **App::Update** one time every iteration of the game loop if the game state is **Active**.</span></span>
-   <span data-ttu-id="b3c97-234">**OnSuspending** und **OnResuming**: anhält und fortsetzt Audiowiedergabe des Spiels bzw..</span><span class="sxs-lookup"><span data-stu-id="b3c97-234">**OnSuspending** and **OnResuming**: Suspends and resumes the game's audio, respectively.</span></span>

<span data-ttu-id="b3c97-235">Und die privaten Methoden:</span><span class="sxs-lookup"><span data-stu-id="b3c97-235">And the private methods:</span></span>

-   <span data-ttu-id="b3c97-236">**LoadSavedState** und **SaveState**: lädt bzw. speichert den aktuellen Zustand des Spiels.</span><span class="sxs-lookup"><span data-stu-id="b3c97-236">**LoadSavedState** and **SaveState**: Loads and saves the current state of the game, respectively.</span></span>
-   <span data-ttu-id="b3c97-237">**SaveHighScore** und **LoadHighScore**: speichert und lädt den spielübergreifenden Highscore Spiele, bzw..</span><span class="sxs-lookup"><span data-stu-id="b3c97-237">**SaveHighScore** and **LoadHighScore**: Saves and loads the high score across games, respectively.</span></span>
-   <span data-ttu-id="b3c97-238">**InitializeAmmo**: setzt den Zustand der als Munition wieder auf den ursprünglichen Zustand für die am Anfang jeder Runde Munition verwendeten.</span><span class="sxs-lookup"><span data-stu-id="b3c97-238">**InitializeAmmo**: Resets the state of each sphere object used as ammunition back to its original state for the beginning of each round.</span></span>
-   <span data-ttu-id="b3c97-239">**UpdateDynamics**: Dies ist eine wichtige Methode, da sie alle Spielobjekte Grundlage vordefinierter animationsroutinen, physikeffekte und steuerungseingaben aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="b3c97-239">**UpdateDynamics**: This is an important method, because it updates all the game objects based on canned animation routines, physics, and control input.</span></span> <span data-ttu-id="b3c97-240">Hierbei handelt es sich gewissermaßen um das Herzstück der Interaktivität, die das Spiel ausmacht.</span><span class="sxs-lookup"><span data-stu-id="b3c97-240">This is the heart of the interactivity that defines the game.</span></span> <span data-ttu-id="b3c97-241">Dies wird im Abschnitt [Aktualisieren die spielwelt](#update-the-game-world) behandelt.</span><span class="sxs-lookup"><span data-stu-id="b3c97-241">This is covered in the [Update the game world](#update-the-game-world) section.</span></span>

<span data-ttu-id="b3c97-242">Die anderen öffentlichen Methoden dienen zum Abrufen von Eigenschaften und geben Gameplay- und Overlay-spezifische Informationen an das App-Framework zurück, um diese anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-242">The other public methods are property getters that return game play and overlay specific information to the app framework for display.</span></span>

### <a name="data"></a><span data-ttu-id="b3c97-243">Daten</span><span class="sxs-lookup"><span data-stu-id="b3c97-243">Data</span></span>

<span data-ttu-id="b3c97-244">Am Anfang des Codebeispiels befinden sich vier Objekte, deren Instanzen während der Ausführung der Spielschleife aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="b3c97-244">At the top of the code example, there are four objects whose instances are updated as the game loop runs.</span></span>

-   <span data-ttu-id="b3c97-245">**MoveLookController** Objekt: stellt die Eingaben des Spielers dar.</span><span class="sxs-lookup"><span data-stu-id="b3c97-245">**MoveLookController** object: Represents the player input.</span></span> <span data-ttu-id="b3c97-246">Weitere Informationen finden Sie unter [Hinzufügen von Steuerelementen](tutorial--adding-controls.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-246">For more information, see [Adding controls](tutorial--adding-controls.md).</span></span>
-   <span data-ttu-id="b3c97-247">**GameRenderer** Objekt: stellt der Direct3D 11-Renderer abgeleitet aus der **DirectXBase** -Klasse, die alle gerätespezifischen Objekte und deren Rendering verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="b3c97-247">**GameRenderer** object: Represents the Direct3D 11 renderer derived from the **DirectXBase** class that handles all the device-specific objects and their rendering.</span></span> <span data-ttu-id="b3c97-248">Weitere Informationen finden Sie unter [Rendering-Framework I](tutorial--assembling-the-rendering-pipeline.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-248">For more information, see [Rendering framework I](tutorial--assembling-the-rendering-pipeline.md).</span></span>
-   <span data-ttu-id="b3c97-249">**Audio** -Objekt: steuert die Audiowiedergabe für das Spiel.</span><span class="sxs-lookup"><span data-stu-id="b3c97-249">**Audio** object: Controls the audio playback for the game.</span></span> <span data-ttu-id="b3c97-250">Weitere Informationen finden Sie unter [Hinzufügen von sound](tutorial--adding-sound.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-250">For more information, see [Adding sound](tutorial--adding-sound.md).</span></span>

<span data-ttu-id="b3c97-251">Die restlichen Spielvariablen enthalten die Listen mit den Grundtypen und die entsprechenden spielinternen Werte sowie Gameplay-spezifische Daten und Beschränkungen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-251">The rest of the game variables contain the lists of the primitives and their respective in-game amounts, and game play specific data and constraints.</span></span>

## <a name="next-steps"></a><span data-ttu-id="b3c97-252">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="b3c97-252">Next steps</span></span>

<span data-ttu-id="b3c97-253">Jetzt sind Sie gespannt auf die tatsächliche Rendering-Engine: wie Aufrufe der __Render__ -Methoden für die aktualisierten Grundtypen in Pixel auf dem Bildschirm aktiviert abrufen.</span><span class="sxs-lookup"><span data-stu-id="b3c97-253">By now, you're probably curious about the actual rendering engine: how calls to the __Render__ methods on the updated primitives get turned into pixels on your screen.</span></span> <span data-ttu-id="b3c97-254">Dies wird in zwei Teile behandelt &mdash; [Rendering-Framework I: Einführung in das Rendering](tutorial--assembling-the-rendering-pipeline.md) und [Rendering-Framework II: Spiel-Rendering](tutorial-game-rendering.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-254">This is covered in two parts &mdash; [Rendering framework I: Intro to rendering](tutorial--assembling-the-rendering-pipeline.md) and [Rendering framework II: Game rendering](tutorial-game-rendering.md).</span></span> <span data-ttu-id="b3c97-255">Sollten Sie sich dagegen mehr für die Aktualisierung des Spielzustands durch die Spielersteuerung interessieren, finden Sie entsprechende Informationen unter [Hinzufügen von Steuerelementen](tutorial--adding-controls.md).</span><span class="sxs-lookup"><span data-stu-id="b3c97-255">If you're more interested in how the player controls update the game state, then check out [Adding controls](tutorial--adding-controls.md).</span></span>
