---
author: muhsinking
Description: Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.
MS-HAID: dev\_ctrl\_layout\_txt.boxpanel\_example\_custom\_panel
MSHAttr: PreferredLib:/library/windows/apps
Search.Product: eADQiWindows 10XVcnh
title: BoxPanel, ein Beispiel für benutzerdefinierte Panels (Windows-Apps)
ms.assetid: 981999DB-81B1-4B9C-A786-3025B62B74D6
label: BoxPanel, an example custom panel
template: detail.hbs
op-migration-status: ready
ms.author: mukin
ms.date: 05/19/2017
ms.topic: article
keywords: Windows10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 7d29b85c7ec3ec9ec0114a3a49dff834f859511e
ms.sourcegitcommit: d0e836dfc937ebf7dfa9c424620f93f3c8e0a7e8
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/26/2018
ms.locfileid: "5640616"
---
# <a name="boxpanel-an-example-custom-panel"></a><span data-ttu-id="5ca60-103">BoxPanel, ein Beispiel für benutzerdefinierte Panels</span><span class="sxs-lookup"><span data-stu-id="5ca60-103">BoxPanel, an example custom panel</span></span>

 

<span data-ttu-id="5ca60-104">Hier erfahren Sie, wie Sie Code für eine benutzerdefinierte [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)-Klasse schreiben. Dabei implementieren Sie die Methoden [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) und [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) und verwenden die [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514)-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="5ca60-104">Learn to write code for a custom [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class, implementing [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, and using the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property.</span></span> 

> <span data-ttu-id="5ca60-105">**Wichtige APIs**: [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711), [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)</span><span class="sxs-lookup"><span data-stu-id="5ca60-105">**Important APIs**: [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711),[**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)</span></span> 

<span data-ttu-id="5ca60-106">Der Beispielcode zeigt eine benutzerdefinierte Panelimplementierung. Wir gehen jedoch nicht detailliert auf die Erklärung der Layoutkonzepte ein, die Einfluss darauf haben, wie Sie ein Panel für verschiedene Layoutszenarien anpassen können.</span><span class="sxs-lookup"><span data-stu-id="5ca60-106">The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.</span></span> <span data-ttu-id="5ca60-107">Wenn Sie weitere Informationen zu diesen Layoutkonzepten und der Anwendbarkeit auf Ihr jeweiliges Layoutszenario benötigen, lesen Sie [Übersicht über benutzerdefinierte XAML-Panels](custom-panels-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5ca60-107">If you want more info about these layout concepts and how they might apply to your particular layout scenario, see [XAML custom panels overview](custom-panels-overview.md).</span></span>

<span data-ttu-id="5ca60-108">Ein *Panel* ist ein Objekt, das ein Layoutverhalten für die darin enthaltenen untergeordneten Elemente bereitstellt, wenn das XAML-Layoutsystem ausgeführt und die Benutzeroberfläche Ihrer App dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-108">A *panel* is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.</span></span> <span data-ttu-id="5ca60-109">Sie können für ein XAML-Layout benutzerdefinierte Panels definieren, indem Sie eine benutzerdefinierte Klasse aus der [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)-Klasse ableiten.</span><span class="sxs-lookup"><span data-stu-id="5ca60-109">You can define custom panels for XAML layout by deriving a custom class from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class.</span></span> <span data-ttu-id="5ca60-110">Das Verhalten für das Panel wird bereitgestellt, indem Sie die Methoden [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) und [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) außer Kraft setzen und somit eine Logik liefern, die die untergeordneten Elemente misst und anordnet.</span><span class="sxs-lookup"><span data-stu-id="5ca60-110">You provide behavior for your panel by overriding the [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods, supplying logic that measures and arranges the child elements.</span></span> <span data-ttu-id="5ca60-111">Dieses Beispiel wurde von **Panel** abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="5ca60-111">This example derives from **Panel**.</span></span> <span data-ttu-id="5ca60-112">Wenn Sie mit einem **Panel** beginnen, haben die Methoden **ArrangeOverride** und **MeasureOverride** kein Startverhalten.</span><span class="sxs-lookup"><span data-stu-id="5ca60-112">When you start from **Panel**, **ArrangeOverride** and **MeasureOverride** methods don't have a starting behavior.</span></span> <span data-ttu-id="5ca60-113">Ihr Code stellt das Gateway bereit, mit dessen Hilfe die untergeordneten Elemente dem XAML-Layoutsystem mitgeteilt und auf der Benutzeroberfläche gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-113">Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.</span></span> <span data-ttu-id="5ca60-114">Daher ist es wirklich wichtig, dass der Code alle untergeordneten Elemente berücksichtigt und dem vom Layoutsystem erwarteten Muster folgt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-114">So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.</span></span>

## <a name="your-layout-scenario"></a><span data-ttu-id="5ca60-115">Ihr Layoutszenario</span><span class="sxs-lookup"><span data-stu-id="5ca60-115">Your layout scenario</span></span>

<span data-ttu-id="5ca60-116">Beim Definieren eines benutzerdefinierten Panels definieren Sie ein Layoutszenario.</span><span class="sxs-lookup"><span data-stu-id="5ca60-116">When you define a custom panel, you're defining a layout scenario.</span></span>

<span data-ttu-id="5ca60-117">Ein Layoutszenario wird durch folgende Aspekte ausgedrückt:</span><span class="sxs-lookup"><span data-stu-id="5ca60-117">A layout scenario is expressed through:</span></span>

-   <span data-ttu-id="5ca60-118">Was geschieht, wenn das Panel untergeordnete Elemente enthält?</span><span class="sxs-lookup"><span data-stu-id="5ca60-118">What the panel will do when it has child elements</span></span>
-   <span data-ttu-id="5ca60-119">Gelten für den eigenen Bereich des Panels Einschränkungen?</span><span class="sxs-lookup"><span data-stu-id="5ca60-119">When the panel has constraints on its own space</span></span>
-   <span data-ttu-id="5ca60-120">Wie bestimmt die Logik des Panels alle Messwerte, Platzierungspositionen und Größenanpassungen, die letztlich zu einem gerenderten UI-Layout der untergeordneten Elemente führen?</span><span class="sxs-lookup"><span data-stu-id="5ca60-120">How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children</span></span>

<span data-ttu-id="5ca60-121">Unter Berücksichtigung dieser Aspekte ist das hier gezeigte `BoxPanel` für ein bestimmtes Szenario geeignet.</span><span class="sxs-lookup"><span data-stu-id="5ca60-121">With that in mind, the `BoxPanel` shown here is for a particular scenario.</span></span> <span data-ttu-id="5ca60-122">Da in diesem Beispiel der Code im Vordergrund stehen soll, werden wir das Szenario noch nicht detailliert erläutern, sondern uns stattdessen auf die notwendigen Schritte und die Codierungsmuster konzentrieren.</span><span class="sxs-lookup"><span data-stu-id="5ca60-122">In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.</span></span> <span data-ttu-id="5ca60-123">Wenn Sie sich zunächst detaillierter über das Szenario informieren möchten, lesen Sie unter [Szenario für `BoxPanel`](#the-scenario-for-boxpanel) weiter, und kehren Sie später zum Code zurück.</span><span class="sxs-lookup"><span data-stu-id="5ca60-123">If you want to know more about the scenario first, skip ahead to ["The scenario for `BoxPanel`"](#the-scenario-for-boxpanel), and then come back to the code.</span></span>

## <a name="start-by-deriving-from-panel"></a><span data-ttu-id="5ca60-124">Erster Schritt: Ableiten von der **Panel**-Klasse</span><span class="sxs-lookup"><span data-stu-id="5ca60-124">Start by deriving from **Panel**</span></span>

<span data-ttu-id="5ca60-125">Leiten Sie zunächst aus der [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)-Klasse eine benutzerdefinierte Klasse ab.</span><span class="sxs-lookup"><span data-stu-id="5ca60-125">Start by deriving a custom class from [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511).</span></span> <span data-ttu-id="5ca60-126">Die einfachste Methode dafür ist wahrscheinlich, mithilfe der Kontextmenüoptionen **Hinzufügen** | **Neues Element** | **Klasse** für ein Projekt aus dem **5Projektmappen-Explorer** in Microsoft Visual Studio eine separate Codedatei für diese Klasse zu definieren.</span><span class="sxs-lookup"><span data-stu-id="5ca60-126">Probably the easiest way to do this is to define a separate code file for this class, using the **Add** | **New Item** | **Class** context menu options for a project from the **Solution Explorer** in Microsoft Visual Studio.</span></span> <span data-ttu-id="5ca60-127">Benennen Sie die Klasse (und Datei) mit `BoxPanel`.</span><span class="sxs-lookup"><span data-stu-id="5ca60-127">Name the class (and file) `BoxPanel`.</span></span>

<span data-ttu-id="5ca60-128">Die Vorlagendatei für eine Klasse beginnt nicht mit vielen **using**-Anweisungen, weil sie nicht ausschließlich für UWP-Apps (Universelle Windows-Plattform) bestimmt ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-128">The template file for a class doesn't start with many **using** statements because it's not specifically for Universal Windows Platform (UWP) apps.</span></span> <span data-ttu-id="5ca60-129">Fügen Sie daher zuerst **using**-Anweisungen hinzu.</span><span class="sxs-lookup"><span data-stu-id="5ca60-129">So first, add **using** statements.</span></span> <span data-ttu-id="5ca60-130">Die Vorlagendatei beginnt außerdem mit einigen **using**-Anweisungen, die Sie vielleicht nicht benötigen, und die gelöscht werden können.</span><span class="sxs-lookup"><span data-stu-id="5ca60-130">The template file also starts with a few **using** statements that you probably don't need, and can be deleted.</span></span> <span data-ttu-id="5ca60-131">Hier ist eine Liste mit Vorschlägen für **using**-Anweisungen zur Auflösung von Typen, die Sie für einen typischen Code eines benutzerdefinierten Panels benötigen:</span><span class="sxs-lookup"><span data-stu-id="5ca60-131">Here's a suggested list of **using** statements that can resolve types you'll need for typical custom panel code:</span></span>

```CSharp
using System;
using System.Collections.Generic; // if you need to cast IEnumerable for iteration, or define your own collection properties
using Windows.Foundation; // Point, Size, and Rect
using Windows.UI.Xaml; // DependencyObject, UIElement, and FrameworkElement
using Windows.UI.Xaml.Controls; // Panel
using Windows.UI.Xaml.Media; // if you need Brushes or other utilities
```

<span data-ttu-id="5ca60-132">Da Sie nun die [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)-Klasse auflösen können, legen Sie diese als Basisklasse für `BoxPanel` fest.</span><span class="sxs-lookup"><span data-stu-id="5ca60-132">Now that you can resolve [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), make it the base class of `BoxPanel`.</span></span> <span data-ttu-id="5ca60-133">Machen Sie `BoxPanel` zudem öffentlich:</span><span class="sxs-lookup"><span data-stu-id="5ca60-133">Also, make `BoxPanel` public:</span></span>

```CSharp
public class BoxPanel : Panel
{
}
```

<span data-ttu-id="5ca60-134">Definieren Sie auf Klassenebene einige **int**- und **double**-Werte, die von mehreren Logikfunktionen gemeinsam verwendet werden, aber nicht als öffentliche API verfügbar gemacht werden müssen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-134">At the class level, define some **int** and **double** values that will be shared by several of your logic functions, but which won't need to be exposed as public API.</span></span> <span data-ttu-id="5ca60-135">In dem Beispiel sind diese wie folgt benannt: `maxrc`, `rowcount`, `colcount`, `cellwidth`, `cellheight`, `maxcellheight`, `aspectratio`.</span><span class="sxs-lookup"><span data-stu-id="5ca60-135">In the example, these are named: `maxrc`, `rowcount`, `colcount`, `cellwidth`, `cellheight`, `maxcellheight`, `aspectratio`.</span></span>

<span data-ttu-id="5ca60-136">Nachdem Sie dies getan haben, sieht die vollständige Codedatei wie folgt aus (Kommentare zu **using** werden entfernt, da Sie nun wissen, wozu sie dienen):</span><span class="sxs-lookup"><span data-stu-id="5ca60-136">After you've done this, the complete code file looks like this (removing comments on **using**, now that you know why we have them):</span></span>

```CSharp
using System;
using System.Collections.Generic;
using Windows.Foundation;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Media;

public class BoxPanel : Panel 
{
    int maxrc, rowcount, colcount;
    double cellwidth, cellheight, maxcellheight, aspectratio;
}
```

<span data-ttu-id="5ca60-137">Ab hier zeigen wir Ihnen jeweils eine Memberdefinition. Dabei kann es sich um eine Methodenüberschreibung oder eine Unterstützung wie eine Abhängigkeitseigenschaft handeln.</span><span class="sxs-lookup"><span data-stu-id="5ca60-137">From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.</span></span> <span data-ttu-id="5ca60-138">Sie können diese dem oben gezeigten Skelett in beliebiger Reihenfolge hinzufügen. Wir zeigen die **using**-Anweisungen oder die Definition des Klassenbereichs erst wieder in den Codeausschnitten, wenn wir den finalen Code präsentieren.</span><span class="sxs-lookup"><span data-stu-id="5ca60-138">You can add these to the skeleton above in any order, and we won't be showing the **using** statements or the definition of the class scope again in the snippets until we show the final code.</span></span>

## **<a name="measureoverride"></a><span data-ttu-id="5ca60-139">MeasureOverride</span><span class="sxs-lookup"><span data-stu-id="5ca60-139">MeasureOverride</span></span>**


```CSharp
protected override Size MeasureOverride(Size availableSize)
{
    Size returnSize;
    // Determine the square that can contain this number of items.
    maxrc = (int)Math.Ceiling(Math.Sqrt(Children.Count));
    // Get an aspect ratio from availableSize, decides whether to trim row or column.
    aspectratio = availableSize.Width / availableSize.Height;

    // Now trim this square down to a rect, many times an entire row or column can be omitted.
    if (aspectratio > 1)
    {
        rowcount = maxrc;
        colcount = (maxrc > 2 && Children.Count < maxrc * (maxrc - 1)) ? maxrc - 1 : maxrc;
    } 
    else 
    {
        rowcount = (maxrc > 2 && Children.Count < maxrc * (maxrc - 1)) ? maxrc - 1 : maxrc;
        colcount = maxrc;
    }

    // Now that we have a column count, divide available horizontal, that's our cell width.
    cellwidth = (int)Math.Floor(availableSize.Width / colcount);
    // Next get a cell height, same logic of dividing available vertical by rowcount.
    cellheight = Double.IsInfinity(availableSize.Height) ? Double.PositiveInfinity : availableSize.Height / rowcount;
           
    foreach (UIElement child in Children)
    {
        child.Measure(new Size(cellwidth, cellheight));
        maxcellheight = (child.DesiredSize.Height > maxcellheight) ? child.DesiredSize.Height : maxcellheight;
    }
    return LimitUnboundedSize(availableSize);
}
```

<span data-ttu-id="5ca60-140">Das notwendige Muster einer [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)-Implementierung ist die Schleife durch die einzelnen Elemente in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514).</span><span class="sxs-lookup"><span data-stu-id="5ca60-140">The necessary pattern of a [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514).</span></span> <span data-ttu-id="5ca60-141">Rufen Sie für jedes dieser Elemente immer die [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952)-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="5ca60-141">Always call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each of these elements.</span></span> <span data-ttu-id="5ca60-142">**Measure** hat einen Parameter vom Typ [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995).</span><span class="sxs-lookup"><span data-stu-id="5ca60-142">**Measure** has a parameter of type [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995).</span></span> <span data-ttu-id="5ca60-143">An dieser Stelle übergeben Sie die Größe, die dem Panel für das jeweilige untergeordnete Element zur Verfügung stehen soll.</span><span class="sxs-lookup"><span data-stu-id="5ca60-143">What you're passing here is the size that your panel is committing to have available for that particular child element.</span></span> <span data-ttu-id="5ca60-144">Bevor Sie also den Schleife ausführen und mit dem **Measure**-Aufruf beginnen können, müssen Sie wissen, wie viel Platz die einzelnen Zellen belegen können.</span><span class="sxs-lookup"><span data-stu-id="5ca60-144">So, before you can do the loop and start calling **Measure**, you need to know how much space each cell can devote.</span></span> <span data-ttu-id="5ca60-145">Aus der **MeasureOverride**-Methode selbst stammt der *availableSize*-Wert.</span><span class="sxs-lookup"><span data-stu-id="5ca60-145">From the **MeasureOverride** method itself, you have the *availableSize* value.</span></span> <span data-ttu-id="5ca60-146">Dies ist die Größe, die vom übergeordneten Panel beim **Measure**-Aufruf verwendet wurde. Dies war in erster Linie der Auslöser für diesen **MeasureOverride**-Aufruf.</span><span class="sxs-lookup"><span data-stu-id="5ca60-146">That is the size that the panel's parent used when it called **Measure**, which was the trigger for this **MeasureOverride** being called in the first place.</span></span> <span data-ttu-id="5ca60-147">Eine typische Logik besteht also darin, ein Schema zu entwerfen, in dem jedes untergeordnete Element den Raum des gesamten *availableSize*-Werts für das Panel teilt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-147">So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall *availableSize*.</span></span> <span data-ttu-id="5ca60-148">Anschließend übergeben Sie die einzelnen Größenteilungen für jedes untergeordnete Element an **Measure**.</span><span class="sxs-lookup"><span data-stu-id="5ca60-148">You then pass each division of size to **Measure** of each child element.</span></span>

<span data-ttu-id="5ca60-149">Die Größe wird vom `BoxPanel` ziemlich einfach aufgeteilt: Es teilt den Platz in mehrere Felder, deren Anzahl größtenteils durch die Anzahl Elemente bestimmt wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-149">How `BoxPanel` divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.</span></span> <span data-ttu-id="5ca60-150">Die Größenanpassung der Felder basiert auf der Anzahl der Zeilen und Spalten und auf der verfügbaren Größe.</span><span class="sxs-lookup"><span data-stu-id="5ca60-150">Boxes are sized based on row and column count and the available size.</span></span> <span data-ttu-id="5ca60-151">Mitunter wird eine Zeile oder Spalte eines Quadrats nicht benötigt. Demzufolge wird es verworfen, und der Bereich ist bezüglich des Zeilen-/Spaltenverhältnisses kein Quadrat mehr, sondern wird zu einem Rechteck.</span><span class="sxs-lookup"><span data-stu-id="5ca60-151">Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.</span></span> <span data-ttu-id="5ca60-152">Wenn Sie weitere Informationen dazu erhalten möchten, wie diese Logik erstellt wurde, lesen Sie unter [„Das Szenario für BoxPanel](#the-scenario-for-boxpanel)“ weiter.</span><span class="sxs-lookup"><span data-stu-id="5ca60-152">For more info about how this logic was arrived at, skip ahead to ["The scenario for BoxPanel"](#the-scenario-for-boxpanel).</span></span>

<span data-ttu-id="5ca60-153">Was geschieht also während des Messdurchlaufs?</span><span class="sxs-lookup"><span data-stu-id="5ca60-153">So what does the measure pass do?</span></span> <span data-ttu-id="5ca60-154">Dabei wird für jedes Element, bei dem [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) aufgerufen wurde, ein Wert für die schreibgeschützte [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921)-Eigenschaft festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-154">It sets a value for the read-only [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property on each element where [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) was called.</span></span> <span data-ttu-id="5ca60-155">Das Vorhandensein eines **DesiredSize**-Werts kann beim Erreichen des Anordnungsdurchlaufs von Bedeutung sein, weil **DesiredSize** Aufschluss darüber gibt, wie die Größe bei der Anordnung und in der finalen Darstellung lauten kann oder soll.</span><span class="sxs-lookup"><span data-stu-id="5ca60-155">Having a **DesiredSize** value is possibly important once you get to the arrange pass, because the **DesiredSize** communicates what the size can or should be when arranging and in the final rendering.</span></span> <span data-ttu-id="5ca60-156">Selbst wenn Sie **DesiredSize** in Ihrer eigenen Logik nicht verwenden, wird der Wert dennoch vom System benötigt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-156">Even if you don't use **DesiredSize** in your own logic, the system still needs it.</span></span>

<span data-ttu-id="5ca60-157">Dieses Panel kann verwendet werden, wenn die Höhenkomponenten von *availableSize* unbegrenzt ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-157">It's possible for this panel to be used when the height component of *availableSize* is unbounded.</span></span> <span data-ttu-id="5ca60-158">Wenn dies wahr ist, verfügt das Panel über keine bekannte Höhe zum Teilen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-158">If that's true, the panel doesn't have a known height to divide.</span></span> <span data-ttu-id="5ca60-159">In diesem Fall informiert die Logik für den Messdurchlauf jedes untergeordnete Element darüber, dass es noch keine begrenzte Höhe aufweist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-159">In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.</span></span> <span data-ttu-id="5ca60-160">Dazu wird ein [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995)-Wert an den [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952)-Aufruf für untergeordnete Elemente übergeben, wobei [**Size.Height**](https://msdn.microsoft.com/library/windows/apps/hh763910) endlos ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-160">It does so by passing a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) to the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) call for children where [**Size.Height**](https://msdn.microsoft.com/library/windows/apps/hh763910) is infinite.</span></span> <span data-ttu-id="5ca60-161">Dies ist zulässig.</span><span class="sxs-lookup"><span data-stu-id="5ca60-161">That's legal.</span></span> <span data-ttu-id="5ca60-162">Beim Aufruf von **Measure** wird der [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921)-Wert laut Logik als Minimalwert von Folgendem festgelegt: an **Measure** übergebene Werte oder die natürliche Größe des jeweiligen Elements aus Faktoren wie den explizit festgelegten Werten [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) und [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width).</span><span class="sxs-lookup"><span data-stu-id="5ca60-162">When **Measure** is called, the logic is that the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) is set as the minimum of these: what was passed to **Measure**, or that element's natural size from factors such as explicitly-set [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) and [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width).</span></span>

> [!NOTE]
> <span data-ttu-id="5ca60-163">Die interne [**StackPanel-Logik**](https://msdn.microsoft.com/library/windows/apps/br209635) weist zudem dieses Verhalten auf: **StackPanel** übergibt einen endlosen Dimensionswert an [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) für untergeordnete Elemente. Hiermit wird angegeben, dass für untergeordnete Elemente in der Ausrichtungsdimension keine Beschränkung vorliegt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-163">The internal logic of [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) also has this behavior: **StackPanel** passes an infinite dimension value to [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) on children, indicating that there is no constraint on children in the orientation dimension.</span></span> <span data-ttu-id="5ca60-164">**StackPanel** passt seine Größe normalerweise dynamisch an, sodass alle untergeordneten Elemente in einem Stapel Platz haben, der in dieser Dimension zunimmt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-164">**StackPanel** typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.</span></span>

<span data-ttu-id="5ca60-165">Das Panel selbst kann aber kein [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995)-Element mit einem endlosen Wert aus [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) zurückgeben, weil dadurch im Layout eine Ausnahme ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-165">However, the panel itself can't return a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) with an infinite value from [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that throws an exception during layout.</span></span> <span data-ttu-id="5ca60-166">Teil dieser Logik ist es also, die von einem beliebigen untergeordneten Element angeforderte Maximalhöhe herauszufinden und diese Höhe als Zellenhöhe zu verwenden, wenn sie nicht bereits aus den eigenen Größenbeschränkungen des Panels stammt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-166">So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.</span></span> <span data-ttu-id="5ca60-167">Dies ist die Hilfsfunktion `LimitUnboundedSize`, auf die im vorherigen Code verwiesen wurde, der diese Zellenmaximalhöhe verwendet, um dem Panel eine begrenzte Höhe zuzuweisen. Zudem wird davon ausgegangen, dass `cellheight` eine finite Zahl ist, bevor der Anordnungsdurchlauf initiiert wird:</span><span class="sxs-lookup"><span data-stu-id="5ca60-167">Here's the helper function `LimitUnboundedSize` that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that `cellheight` is a finite number before the arrange pass is initiated:</span></span>

```CSharp
// This method is called only if one of the availableSize dimensions of measure is infinite.
// That can happen to height if the panel is close to the root of main app window.
// In this case, base the height of a cell on the max height from desired size
// and base the height of the panel on that number times the #rows.

Size LimitUnboundedSize(Size input)
{
    if (Double.IsInfinity(input.Height))
    {
        input.Height = maxcellheight * colcount;
        cellheight = maxcellheight;
    }
    return input;
}
```

## **<a name="arrangeoverride"></a><span data-ttu-id="5ca60-168">ArrangeOverride</span><span class="sxs-lookup"><span data-stu-id="5ca60-168">ArrangeOverride</span></span>**

```CSharp
protected override Size ArrangeOverride(Size finalSize)
{
     int count = 1
     double x, y;
     foreach (UIElement child in Children)
     {
          x = (count - 1) % colcount * cellwidth;
          y = ((int)(count - 1) / colcount) * cellheight;
          Point anchorPoint = new Point(x, y);
          child.Arrange(new Rect(anchorPoint, child.DesiredSize));
          count++;
     }
     return finalSize;
}
```

<span data-ttu-id="5ca60-169">Das notwendige Muster einer [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)-Implementierung ist die Schleife durch die einzelnen Elemente in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514).</span><span class="sxs-lookup"><span data-stu-id="5ca60-169">The necessary pattern of an [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation is the loop through each element in [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514).</span></span> <span data-ttu-id="5ca60-170">Rufen Sie für jedes dieser Elemente immer die [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914)-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="5ca60-170">Always call the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method on each of these elements.</span></span>

<span data-ttu-id="5ca60-171">Beachten Sie, dass hier nicht so viele Berechnungen erfolgen wie in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)– das ist typisch.</span><span class="sxs-lookup"><span data-stu-id="5ca60-171">Note how there aren't as many calculations as in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730); that's typical.</span></span> <span data-ttu-id="5ca60-172">Die Größe der untergeordneten Elemente ist bereits aus der eigenen **MeasureOverride**-Logik des Panels oder aus dem [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921)-Wert der einzelnen untergeordneten Elemente bekannt, der während des Messdurchlaufs festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-172">The size of children is already known from the panel's own **MeasureOverride** logic, or from the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value of each child set during the measure pass.</span></span> <span data-ttu-id="5ca60-173">Dennoch müssen wir die Position innerhalb des Panels festlegen, an der die einzelnen untergeordneten Elemente angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-173">However, we still need to decide the location within the panel where each child will appear.</span></span> <span data-ttu-id="5ca60-174">In einem typischen Panel sollte jedes untergeordnete Element an einer anderen Position gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-174">In a typical panel, each child should render at a different position.</span></span> <span data-ttu-id="5ca60-175">Ein Panel, das überlappende Elemente erzeugt, ist für gewöhnliche Szenarien nicht wünschenswert (obwohl Sie durchaus Panels mit zweckmäßigen Überlappungen erstellen können, wenn dies wirklich das beabsichtigte Szenario ist).</span><span class="sxs-lookup"><span data-stu-id="5ca60-175">A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).</span></span>

<span data-ttu-id="5ca60-176">Dieses Panel wird nach dem Konzept von Zeilen und Spalten angeordnet.</span><span class="sxs-lookup"><span data-stu-id="5ca60-176">This panel arranges by the concept of rows and columns.</span></span> <span data-ttu-id="5ca60-177">Die Anzahl Zeilen und Spalten wurde bereits berechnet (dies war für die Messung nötig).</span><span class="sxs-lookup"><span data-stu-id="5ca60-177">The number of rows and columns was already calculated (it was necessary for measurement).</span></span> <span data-ttu-id="5ca60-178">Die Form der Zeilen und Spalten sowie die bekannten Größen der einzelnen Zellen sind also Teil der Definitionslogik einer Darstellungsposition (`anchorPoint`) für jedes Element, das in diesem Panel enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-178">So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the `anchorPoint`) for each element that this panel contains.</span></span> <span data-ttu-id="5ca60-179">Dieser [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870)-Wert und der bereits aus der Messung bekannte [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995)-Wert werden zusammen als die beiden Komponenten verwendet, aus denen eine [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994)-Struktur konstruiert wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-179">That [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870), along with the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) already known from measure, are used as the two components that construct a [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994).</span></span> <span data-ttu-id="5ca60-180">**Rect** ist der Eingabetyp für [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914).</span><span class="sxs-lookup"><span data-stu-id="5ca60-180">**Rect** is the input type for [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914).</span></span>

<span data-ttu-id="5ca60-181">Panels müssen die zugehörigen Inhalte mitunter beschneiden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-181">Panels sometimes need to clip their content.</span></span> <span data-ttu-id="5ca60-182">Wenn dies der Fall ist, entspricht die beschnittene Größe der in [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) vorhandenen Größe, weil sie die [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952)-Logik als Mindestwert, der an **Measure** übergeben wurde, oder als andere natürliche Größenfaktoren festlegt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-182">If they do, the clipped size is the size that's present in [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921), because the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) logic sets it as the minimum of what was passed to **Measure**, or other natural size factors.</span></span> <span data-ttu-id="5ca60-183">Normalerweise müssen Sie die Beschneidung in der [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914)-Phase also nicht überprüfen. Die Beschneidung erfolgt einfach basierend auf der Übergabe der **DesiredSize** an die einzelnen **Arrange**-Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="5ca60-183">So you don't typically need to specifically check for clipping during [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914); the clipping just happens based on passing the **DesiredSize** through to each **Arrange** call.</span></span>

<span data-ttu-id="5ca60-184">Beim Durchlaufen der Schleife benötigen Sie nicht immer eine Zählung, wenn alle zum Definieren der Renderingposition benötigten Informationen anderweitig bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="5ca60-184">You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.</span></span> <span data-ttu-id="5ca60-185">Zum Beispiel ist in der [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267)-Layoutlogik die Position in der [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514)-Sammlung unerheblich.</span><span class="sxs-lookup"><span data-stu-id="5ca60-185">For example, in [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) layout logic, the position in the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) collection doesn't matter.</span></span> <span data-ttu-id="5ca60-186">Alle zum Positionieren der einzelnen Elemente in einer **Canvas** benötigten Infos sind durch Lesen der Werte [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) und [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) der untergeordneten Elemente im Rahmen der Anordnungslogik bekannt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-186">All the info needed to position each element in a **Canvas** is known by reading [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) values of children as part of the arrange logic.</span></span> <span data-ttu-id="5ca60-187">Die `BoxPanel`-Logik benötigt eine Zählung für den Vergleich mit dem *colcount*-Wert, damit ersichtlich ist, wann eine neue Zeile begonnen und der *y*-Wert versetzt wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-187">The `BoxPanel` logic happens to need a count to compare to the *colcount* so it's known when to begin a new row and offset the *y* value.</span></span>

<span data-ttu-id="5ca60-188">Normalerweise sind der eingegebene Wert für *finalSize* und der Wert für [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995), der aus einer [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)-Implementierung zurückgegeben wird, identisch.</span><span class="sxs-lookup"><span data-stu-id="5ca60-188">It's typical that the input *finalSize* and the [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) you return from a [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementation are the same.</span></span> <span data-ttu-id="5ca60-189">Weitere Informationen zu den entsprechenden Gründen finden Sie unter [Übersicht über benutzerdefinierte XAML-Panels](custom-panels-overview.md) im Abschnitt **ArrangeOverride**.</span><span class="sxs-lookup"><span data-stu-id="5ca60-189">For more info about why, see "**ArrangeOverride**" section of [XAML custom panels overview](custom-panels-overview.md).</span></span>

## <a name="a-refinement-controlling-the-row-vs-column-count"></a><span data-ttu-id="5ca60-190">Verfeinerung: Steuern der Anzahl der Zeilen und Spalten</span><span class="sxs-lookup"><span data-stu-id="5ca60-190">A refinement: controlling the row vs. column count</span></span>

<span data-ttu-id="5ca60-191">Sie könnten diesen Bereich nun in diesem Zustand kompilieren und verwenden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-191">You could compile and use this panel just as it is now.</span></span> <span data-ttu-id="5ca60-192">Wir fügen jedoch noch eine Verfeinerung hinzu.</span><span class="sxs-lookup"><span data-stu-id="5ca60-192">However, we'll add one more refinement.</span></span> <span data-ttu-id="5ca60-193">In dem gerade gezeigten Code positioniert die Logik die Extrazeile oder -spalte auf der Seite, die im Seitenverhältnis die längste ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-193">In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.</span></span> <span data-ttu-id="5ca60-194">Aus Gründen der besseren Kontrolle über die Formen der Zellen kann es jedoch wünschenswert sein, eine 4-x-3-Zellenmenge anstatt 3x4 auszuwählen. Dies ist auch dann der Fall, wenn das eigene Seitenverhältnis des Panels „Hochformat“ lautet.</span><span class="sxs-lookup"><span data-stu-id="5ca60-194">But for greater control over the shapes of cells, it might be desirable to choose a 4x3 set of cells instead of 3x4 even if the panel's own aspect ratio is "portrait."</span></span> <span data-ttu-id="5ca60-195">Daher fügen wir eine optionale Abhängigkeitseigenschaft hinzu, die der Benutzer des Panels zum Steuern dieses Verhaltens festlegen kann.</span><span class="sxs-lookup"><span data-stu-id="5ca60-195">So we'll add an optional dependency property that the panel consumer can set to control that behavior.</span></span> <span data-ttu-id="5ca60-196">Hier finden Sie die sehr einfache Definition der Abhängigkeitseigenschaft:</span><span class="sxs-lookup"><span data-stu-id="5ca60-196">Here's the dependency property definition, which is very basic:</span></span>

```CSharp
public static readonly DependencyProperty UseOppositeRCRatioProperty =
   DependencyProperty.Register("UseOppositeRCRatio", typeof(bool), typeof(BoxPanel), null);

public bool UseSquareCells
{
    get { return (bool)GetValue(UseOppositeRCRatioProperty); }
    set { SetValue(UseOppositeRCRatioProperty, value); }
}
```

<span data-ttu-id="5ca60-197">Und so wirkt sich die Verwendung von `UseOppositeRCRatio` auf die Messlogik aus.</span><span class="sxs-lookup"><span data-stu-id="5ca60-197">And here's how using `UseOppositeRCRatio` impacts the measure logic.</span></span> <span data-ttu-id="5ca60-198">Dabei werden tatsächlich lediglich die Ableitungen von `rowcount` und `colcount` von `maxrc` und das tatsächliche Seitenverhältnis geändert. Daraus ergeben sich für jede Zelle entsprechende Größenunterschiede.</span><span class="sxs-lookup"><span data-stu-id="5ca60-198">Really all it's doing is changing how `rowcount` and `colcount` are derived from `maxrc` and the true aspect ratio, and there are corresponding size differences for each cell because of that.</span></span> <span data-ttu-id="5ca60-199">Wenn `UseOppositeRCRatio` **true** ist, wird der Wert des tatsächlichen Seitenverhältnisses vor dessen Verwendung für die Zählung der Zeilen und Spalten invertiert.</span><span class="sxs-lookup"><span data-stu-id="5ca60-199">When `UseOppositeRCRatio` is **true**, it inverts the value of the true aspect ratio before using it for row and column counts.</span></span>

```CSharp
if (UseOppositeRCRatio) { aspectratio = 1 / aspectratio;}
```

## <a name="the-scenario-for-boxpanel"></a><span data-ttu-id="5ca60-200">Szenario für BoxPanel</span><span class="sxs-lookup"><span data-stu-id="5ca60-200">The scenario for BoxPanel</span></span>

<span data-ttu-id="5ca60-201">Das besondere Szenario für `BoxPanel` sieht so aus, dass es sich um einen Bereich handelt, in dem sich eine der Hauptdeterminante zur Aufteilung der Fläche aus der Kenntnis der Anzahl untergeordneter Elemente ergibt und in dem die bekannte verfügbare Fläche für den Bereich geteilt wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-201">The particular scenario for `BoxPanel` is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.</span></span> <span data-ttu-id="5ca60-202">Bereiche sind immanente Rechtecksformen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-202">Panels are innately rectangle shapes.</span></span> <span data-ttu-id="5ca60-203">Viele Panels funktionieren so, dass die rechteckige Fläche in weitere Rechtecke geteilt wird. Genau diese Funktion übernimmt die [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704)-Klasse für die zugehörigen Zellen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-203">Many panels operate by dividing that rectangle space into further rectangles; that's what [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) does for its cells.</span></span> <span data-ttu-id="5ca60-204">Im Fall von **Grid** wird die Größe der Zellen durch [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324)- und [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606)-Werte festgelegt, und Elemente deklarieren die exakte Zelle, in die sie über die angehängten Eigenschaften [**Grid.Row**](https://msdn.microsoft.com/library/windows/apps/hh759795) und [**Grid.Column**](https://msdn.microsoft.com/library/windows/apps/hh759774) einfließen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-204">In **Grid**'s case, the size of the cells is set by [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) and [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) values, and elements declare the exact cell they go into with [**Grid.Row**](https://msdn.microsoft.com/library/windows/apps/hh759795) and [**Grid.Column**](https://msdn.microsoft.com/library/windows/apps/hh759774) attached properties.</span></span> <span data-ttu-id="5ca60-205">Zum Abrufen eines guten Layouts aus einem **Grid** muss zuvor normalerweise die Anzahl der untergeordneten Elemente bekannt sein, sodass genügend Zellen vorhanden sind und jedes untergeordnete Element seine angehängten Eigenschaften so festlegt, dass es in seine eigene Zelle passt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-205">Getting good layout from a **Grid** usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.</span></span>

<span data-ttu-id="5ca60-206">Wie verhält es sich jedoch, wenn die Anzahl untergeordneter Elemente dynamisch ist?</span><span class="sxs-lookup"><span data-stu-id="5ca60-206">But what if the number of children is dynamic?</span></span> <span data-ttu-id="5ca60-207">Das ist durchaus möglich. Der Code Ihrer App kann Sammlungen Elemente hinzufügen. Dies geschieht in Reaktion auf dynamische Laufzeitzustände, die Sie für wichtig genug erachten, um die Benutzeroberfläche zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="5ca60-207">That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.</span></span> <span data-ttu-id="5ca60-208">Wenn Sie eine Datenbindung zum Sichern von Sammlungen/Geschäftsobjekten verwenden, erfolgen der Abruf solcher Updates und die Aktualisierung der Benutzeroberfläche automatisch. Daher ist dies oftmals die bevorzugte Technik (siehe [Datenbindung im Detail](https://msdn.microsoft.com/library/windows/apps/mt210946)).</span><span class="sxs-lookup"><span data-stu-id="5ca60-208">If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)).</span></span>

<span data-ttu-id="5ca60-209">Aber nicht alle App-Szenarien eignen sich für die Datenbindung.</span><span class="sxs-lookup"><span data-stu-id="5ca60-209">But not all app scenarios lend themselves to data binding.</span></span> <span data-ttu-id="5ca60-210">Manchmal müssen Sie zur Laufzeit neue UI-Elemente erstellen und sichtbar machen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-210">Sometimes, you need to create new UI elements at runtime and make them visible.</span></span> `BoxPanel` <span data-ttu-id="5ca60-211"> ist für dieses Szenario gedacht.</span><span class="sxs-lookup"><span data-stu-id="5ca60-211">is for this scenario.</span></span> <span data-ttu-id="5ca60-212">Eine Änderung der Anzahl der untergeordneten Elemente ist kein Problem für `BoxPanel`, weil diese Anzahl in Berechnungen verwendet wird und sowohl die vorhandenen als auch die neuen untergeordneten Elemente in einem neuen Layout angepasst werden, sodass sie alle passen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-212">A changing number of child items is no problem for `BoxPanel` because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.</span></span>

<span data-ttu-id="5ca60-213">Ein erweitertes Szenario für das Erweitern von `BoxPanel` (hier nicht gezeigt) könnte sowohl dynamische untergeordnete Elemente umfassen als auch den [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921)-Wert eines untergeordneten Elements als stärkeren Faktor für die Größenanpassung einzelner Zellen verwenden.</span><span class="sxs-lookup"><span data-stu-id="5ca60-213">An advanced scenario for extending `BoxPanel` further (not shown here) could both accommodate dynamic children and use a child's [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) as a stronger factor for the sizing of individual cells.</span></span> <span data-ttu-id="5ca60-214">In diesem Szenario könnten auch die Zeilen- oder Spaltengrößen oder Nichtrasterformen variieren, sodass weniger Platz „verschwendet“ wird.</span><span class="sxs-lookup"><span data-stu-id="5ca60-214">This scenario might use varying row or column sizes or non-grid shapes so that there's less "wasted" space.</span></span> <span data-ttu-id="5ca60-215">Dies erfordert eine Strategie für die Einpassung von mehreren Rechtecken mit verschiedenen Größen und Seitenverhältnissen in ein einschließendes Rechteck, um ästhetische Aspekte ebenso wie die kleinste Größe zu berücksichtigen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-215">This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.</span></span> `BoxPanel` <span data-ttu-id="5ca60-216"> verwendet solch eine Strategie nicht. Stattdessen wird der Platz mithilfe einer einfacheren Technik aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-216">doesn't do that; it's using a simpler technique for dividing space.</span></span> `BoxPanel`<span data-ttu-id="5ca60-217">Die Technik besteht darin, die kleinste Quadratzahl zu bestimmen, die größer als die Anzahl der untergeordneten Elemente ist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-217">'s technique is to determine the least square number that's greater than the child count.</span></span> <span data-ttu-id="5ca60-218">Beispielsweise würden neun Elemente in ein Quadrat mit den Abmessungen 3×3 passen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-218">For example, 9 items would fit in a 3x3 square.</span></span> <span data-ttu-id="5ca60-219">Für zehn Elemente wird ein Quadrat mit den Abmessungen 4×4 benötigt.</span><span class="sxs-lookup"><span data-stu-id="5ca60-219">10 items require a 4x4 square.</span></span> <span data-ttu-id="5ca60-220">Oftmals können Sie aber Elemente zuordnen und trotzdem eine Zeile oder Spalte aus dem Ausgangsquadrat entfernen, um Platz zu sparen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-220">However, you can often fit items while still removing one row or column of the starting square, to save space.</span></span> <span data-ttu-id="5ca60-221">Im Beispiel mit der Anzahl10 würde das in ein Rechteck mit 4x3 oder 3x4 passen.</span><span class="sxs-lookup"><span data-stu-id="5ca60-221">In the count=10 example, that fits in a 4x3 or 3x4 rectangle.</span></span>

<span data-ttu-id="5ca60-222">Möglicherweise fragen Sie sich, warum das Panel nicht stattdessen die Abmessung 5x2 für zehn Elemente auswählt, da die Elementanzahl dann genau passen würde.</span><span class="sxs-lookup"><span data-stu-id="5ca60-222">You might wonder why the panel wouldn't instead choose 5x2 for 10 items, because that fits the item number neatly.</span></span> <span data-ttu-id="5ca60-223">In der Praxis wird die Größe von Panels aber als Rechteck festgelegt, das nur selten ein fest ausgerichtetes Seitenverhältnis aufweist.</span><span class="sxs-lookup"><span data-stu-id="5ca60-223">However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.</span></span> <span data-ttu-id="5ca60-224">Die Technik mit den kleinsten Quadraten ist eine Methode, um die Größenfestlegungslogik so zu beeinflussen, dass sie ordnungsgemäß mit den typischen Layoutformen funktioniert und um zu verhindern, dass durch die Größenfestlegung eigenartige Seitenverhältnisse der Zellenformen auftreten.</span><span class="sxs-lookup"><span data-stu-id="5ca60-224">The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5ca60-225">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="5ca60-225">Related topics</span></span>

**<span data-ttu-id="5ca60-226">Referenz</span><span class="sxs-lookup"><span data-stu-id="5ca60-226">Reference</span></span>**

* [**<span data-ttu-id="5ca60-227">FrameworkElement.ArrangeOverride</span><span class="sxs-lookup"><span data-stu-id="5ca60-227">FrameworkElement.ArrangeOverride</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208711)
* [**<span data-ttu-id="5ca60-228">FrameworkElement.MeasureOverride</span><span class="sxs-lookup"><span data-stu-id="5ca60-228">FrameworkElement.MeasureOverride</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208730)
* [**<span data-ttu-id="5ca60-229">Panel</span><span class="sxs-lookup"><span data-stu-id="5ca60-229">Panel</span></span>**](https://msdn.microsoft.com/library/windows/apps/br227511)

**<span data-ttu-id="5ca60-230">Konzepte</span><span class="sxs-lookup"><span data-stu-id="5ca60-230">Concepts</span></span>**

* [<span data-ttu-id="5ca60-231">Ausrichtung, Rand und Abstand</span><span class="sxs-lookup"><span data-stu-id="5ca60-231">Alignment, margin, and padding</span></span>](alignment-margin-padding.md)
