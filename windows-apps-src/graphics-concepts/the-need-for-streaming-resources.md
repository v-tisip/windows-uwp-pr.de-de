---
title: Die Notwendigkeit zur Verwendung von Streamingressourcen
description: Streamingressourcen sind erforderlich, damit der GPU-Speicher nicht unnötig durch die Speicherung von Oberflächenbereichen belegt wird, auf die nicht zugegriffen wird, und um der Hardware mitzuteilen, wie angrenzende Kacheln gefiltert werden sollen.
ms.assetid: A88BE65B-104F-4176-9809-C12580A3684C
keywords:
- Die Notwendigkeit zur Verwendung von Streamingressourcen
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: 25d5e1d88ec631c3d9105d0291710ca6d0389f13
ms.sourcegitcommit: 144f5f127fc4fbd852f2f6780ef26054192d68fc
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/03/2018
ms.locfileid: "5993307"
---
# <a name="the-need-for-streaming-resources"></a><span data-ttu-id="ce606-104">Die Notwendigkeit zur Verwendung von Streamingressourcen</span><span class="sxs-lookup"><span data-stu-id="ce606-104">The need for streaming resources</span></span>


<span data-ttu-id="ce606-105">Streamingressourcen sind erforderlich, damit der Speicher des Grafikprozessors nicht unnötig durch die Speicherung von Oberflächenbereichen belegt wird, auf die nicht zugegriffen wird, und um der Hardware mitzuteilen, wie angrenzende Kacheln gefiltert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ce606-105">Streaming resources are needed so GPU memory isn't wasted storing regions of surfaces that won't be accessed, and to tell the hardware how to filter across adjacent tiles.</span></span>

## <a name="span-idstreamingresourcesorsparsetexturesspanspan-idstreamingresourcesorsparsetexturesspanspan-idstreamingresourcesorsparsetexturesspanstreaming-resources-or-sparse-textures"></a><span data-ttu-id="ce606-106"><span id="Streaming_resources_or_sparse_textures"></span><span id="streaming_resources_or_sparse_textures"></span><span id="STREAMING_RESOURCES_OR_SPARSE_TEXTURES"></span>Streamingressourcen oder Texturen geringer Dichte</span><span class="sxs-lookup"><span data-stu-id="ce606-106"><span id="Streaming_resources_or_sparse_textures"></span><span id="streaming_resources_or_sparse_textures"></span><span id="STREAMING_RESOURCES_OR_SPARSE_TEXTURES"></span>Streaming resources or sparse textures</span></span>


<span data-ttu-id="ce606-107">*Streamingressourcen* ( in Direct3D 11 als *unterteilte Ressourcen* bezeichnet) sind große logische Ressourcen, die wenig physischen Speicher verwenden.</span><span class="sxs-lookup"><span data-stu-id="ce606-107">*Streaming resources* (called *tiled resources* in Direct3D 11), are large logical resources that use small amounts of physical memory.</span></span>

<span data-ttu-id="ce606-108">Eine andere Bezeichnung für Streamingressourcen ist *Texturen geringer Dichte*.</span><span class="sxs-lookup"><span data-stu-id="ce606-108">Another name for streaming resources is *sparse textures*.</span></span> <span data-ttu-id="ce606-109">„Geringe Dichte“ bezeichnet sowohl die Art der Ressourcen als auch den vielleicht wichtigsten Grund für die Kachelanordnung der Ressourcen – dass nicht alle gleichzeitig zugeordnet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ce606-109">"Sparse" conveys both the tiled nature of the resources as well as perhaps the primary reason for tiling them - that not all of them are expected to be mapped at once.</span></span> <span data-ttu-id="ce606-110">Eine Anwendung kann tatsächlich eine Streamingressource erstellen, in der absichtlich keine Daten für alle Regionen + Mips der Ressource erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-110">In fact, an application could conceivably author a streaming resource in which no data is authored for all regions+mips of the resource, intentionally.</span></span> <span data-ttu-id="ce606-111">Daher kann der Inhalt selbst über eine geringe Datendichte verfügen, und die Zuordnung des Inhalts im Arbeitsspeicher des Grafikprozessors (GPU) wäre zu einem bestimmten Zeitpunkt eine Teilmenge davon (sogar mit noch geringerer Datendichte).</span><span class="sxs-lookup"><span data-stu-id="ce606-111">So, the content itself could be sparse, and the mapping of the content in graphics processing unit (GPU) memory at a given time would be a subset of that (even more sparse).</span></span>

## <a name="span-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanspan-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanspan-idwithouttilingmemoryallocationsaremanagedatsubresourcegranularityspanwithout-tiling-memory-allocations-are-managed-at-subresource-granularity"></a><span data-ttu-id="ce606-112"><span id="Without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="WITHOUT_TILING__MEMORY_ALLOCATIONS_ARE_MANAGED_AT_SUBRESOURCE_GRANULARITY"></span>Ohne Kachelzuordnung werden die Speicherzuordnungen mit der Präzision von Unterressourcen verwaltet.</span><span class="sxs-lookup"><span data-stu-id="ce606-112"><span id="Without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="without_tiling__memory_allocations_are_managed_at_subresource_granularity"></span><span id="WITHOUT_TILING__MEMORY_ALLOCATIONS_ARE_MANAGED_AT_SUBRESOURCE_GRANULARITY"></span>Without tiling, memory allocations are managed at subresource granularity</span></span>


<span data-ttu-id="ce606-113">In einem Grafiksystem (d.h. einem Betriebssystem, einem Bildschirmtreiber und Grafikhardware) ohne Unterstützung von Streamingressourcen verwaltet das Grafiksystem alle Direct3D-Speicherzuordnung mit der Präzision von Unterressourcen.</span><span class="sxs-lookup"><span data-stu-id="ce606-113">In a graphics system (that is, the operating system, display driver, and graphics hardware) without streaming resource support, the graphics system manages all Direct3D memory allocations at subresource granularity.</span></span>

<span data-ttu-id="ce606-114">Für einen [Puffer](introduction-to-buffers.md) ist der gesamte Puffer die Unterressource.</span><span class="sxs-lookup"><span data-stu-id="ce606-114">For a [buffer](introduction-to-buffers.md), the entire buffer is the subresource.</span></span>

<span data-ttu-id="ce606-115">Für eine [Textur](textures.md) (z.B. [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525)) ist jede Mip-Ebene eine Unterressource; für ein Textur-Array (z.B. [**Texture2DArray**](https://msdn.microsoft.com/library/windows/desktop/ff471526)) ist jede Mip-Ebene an einem bestimmten Arraysegment eine Unterressource.</span><span class="sxs-lookup"><span data-stu-id="ce606-115">For a [Texture](textures.md), (for example, [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525)), each mip level is a subresource; for a texture array, (for example, [**Texture2DArray**](https://msdn.microsoft.com/library/windows/desktop/ff471526)) each mip level at a given array slice is a subresource.</span></span> <span data-ttu-id="ce606-116">Das Grafiksystem weist nur die Möglichkeit zur Verwaltung der Zuordnung von Vergaben bei dieser Unterressourcen-Granularität auf.</span><span class="sxs-lookup"><span data-stu-id="ce606-116">The graphics system only exposes the ability to manage the mapping of allocations at this subresource granularity.</span></span> <span data-ttu-id="ce606-117">Im Kontext von Streamingressourcen bezieht sich der Begriff „Zuordnung” auf die Sichtbarmachung der Daten für den Grafikprozessor.</span><span class="sxs-lookup"><span data-stu-id="ce606-117">In the context of streaming resources, "mapping" refers to making data visible to the GPU.</span></span>

## <a name="span-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanspan-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanspan-idwithouttilingcantaccessonlyasmallportionofmipmapchainspanwithout-tiling-cant-access-only-a-small-portion-of-mipmap-chain"></a><span data-ttu-id="ce606-118"><span id="Without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="WITHOUT_TILING__CAN_T_ACCESS_ONLY_A_SMALL_PORTION_OF_MIPMAP_CHAIN"></span>Ohne Kacheln kann nur auf einen kleinen Teil der Mipmap-Kette zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-118"><span id="Without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="without_tiling__can_t_access_only_a_small_portion_of_mipmap_chain"></span><span id="WITHOUT_TILING__CAN_T_ACCESS_ONLY_A_SMALL_PORTION_OF_MIPMAP_CHAIN"></span>Without tiling, can't access only a small portion of mipmap chain</span></span>


<span data-ttu-id="ce606-119">Angenommen, einer Anwendung ist bekannt, dass ein bestimmter Renderingvorgang nur auf einen kleinen Teil eines Image-Mipmaps zugreifen muss (möglicherweise sogar nicht einmal auf den gesamten Bereich eines bestimmten Mipmaps).</span><span class="sxs-lookup"><span data-stu-id="ce606-119">Suppose an application knows that a particular rendering operation only needs to access a small portion of an image mipmap chain (perhaps not even the full area of a given mipmap).</span></span> <span data-ttu-id="ce606-120">Im Idealfall könnte die App das Grafiksystem über diese Anforderung informieren.</span><span class="sxs-lookup"><span data-stu-id="ce606-120">Ideally, the app could inform the graphics system about this need.</span></span> <span data-ttu-id="ce606-121">Das Grafiksystem würde dann nur sicherstellen, dass der benötigte Speicher dem Grafikprozessor zugeordnet wird, ohne dass zu viel Speicher eingelagert wird.</span><span class="sxs-lookup"><span data-stu-id="ce606-121">The graphics system would then only bother to ensure that the needed memory is mapped on the GPU without paging in too much memory.</span></span>

<span data-ttu-id="ce606-122">In der Praxis kann das Grafiksystem ohne Streamingressourcenunterstützung nur über den Speicher informiert werden, der auf dem Grafikprozessor bei Unterressourcengranularität (z.B. eine Reihe vollständiger Mipmap-Ebenen, auf die zugegriffen werden kann) zugeordnet werden muss.</span><span class="sxs-lookup"><span data-stu-id="ce606-122">In reality, without streaming resource support, the graphics system can only be informed about the memory that needs to be mapped on the GPU at subresource granularity (for example, a range of full mipmap levels that could be accessed).</span></span> <span data-ttu-id="ce606-123">Es gibt im Grafiksystem auch keine bedarfsgesteuerte Fehlersuche; somit muss möglicherweise ein Großteil des überflüssigen Grafikprozessor-Speichers verwendet werden, um vollständige Unterressourcenzuordnungen zu erstellen, bevor ein Renderingbefehl, der auf einen Teil des Speichers verweist, ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="ce606-123">There is no demand faulting in the graphics system either, so potentially a lot of excess GPU memory must be used to make full subresources mapped before a rendering command that references any part of the memory is executed.</span></span> <span data-ttu-id="ce606-124">Dies ist nur eines der Probleme, die die Verwendung von großen Speicherzuordnungen in Direct3D ohne Streamingunterstützung erschwert.</span><span class="sxs-lookup"><span data-stu-id="ce606-124">This is just one issue that makes the use of large memory allocations difficult in Direct3D without streaming resource support.</span></span>

## <a name="span-idsoftwarepagingtobreakthesurfaceintosmallertilesspanspan-idsoftwarepagingtobreakthesurfaceintosmallertilesspanspan-idsoftwarepagingtobreakthesurfaceintosmallertilesspansoftware-paging-to-break-the-surface-into-smaller-tiles"></a><span data-ttu-id="ce606-125"><span id="Software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="SOFTWARE_PAGING_TO_BREAK_THE_SURFACE_INTO_SMALLER_TILES"></span>Softwareauslagerung, um die Oberfläche in kleinere Kacheln zu unterteilen</span><span class="sxs-lookup"><span data-stu-id="ce606-125"><span id="Software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="software_paging_to_break_the_surface_into_smaller_tiles"></span><span id="SOFTWARE_PAGING_TO_BREAK_THE_SURFACE_INTO_SMALLER_TILES"></span>Software paging to break the surface into smaller tiles</span></span>


<span data-ttu-id="ce606-126">Die Softwareauslagerung kann für die Unterteilung der Oberfläche in Kacheln verwendet werden, die klein genug sind, um von der Hardware behandelt zu werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-126">Software paging can be used to break the surface into tiles that are small enough for the hardware to handle.</span></span>

<span data-ttu-id="ce606-127">Direct3D unterstützt [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525) Oberflächen mit bis zu 16384 Pixeln auf einer Seite.</span><span class="sxs-lookup"><span data-stu-id="ce606-127">Direct3D supports [**Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff471525) surfaces with up to 16384 pixels on a given side.</span></span> <span data-ttu-id="ce606-128">Ein Bild, das 16384 breit und 16384 hoch ist und 4 Byte pro Pixel aufweist, würde 1GB Videospeicher verbrauchen (und das Hinzufügen von Mipmaps würde diese Menge verdoppeln).</span><span class="sxs-lookup"><span data-stu-id="ce606-128">An image that is 16384 wide by 16384 tall and 4 bytes per pixel would consume 1GB of video memory (and adding mipmaps would double that amount).</span></span> <span data-ttu-id="ce606-129">In der Praxis müssten die gesamten 1GB nur selten in einem einzelnen Renderingvorgang referenziert werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-129">In practice, all 1GB would rarely need to be referenced in a single rendering operation.</span></span>

<span data-ttu-id="ce606-130">Einige Spieleentwickler modellieren Geländeoberflächen mit Größen von bis zu 128KB x 128KB.</span><span class="sxs-lookup"><span data-stu-id="ce606-130">Some game developers model terrain surfaces as large as 128K by 128K.</span></span> <span data-ttu-id="ce606-131">Auf vorhandenen Grafikprozessoren erreichen sie dies, indem sie die Oberfläche in Kacheln unterteilen, die für die Hardware klein genug sind.</span><span class="sxs-lookup"><span data-stu-id="ce606-131">The way they get this to work on existing GPUs is to break the surface into tiles that are small enough for hardware to handle.</span></span> <span data-ttu-id="ce606-132">Die Anwendung muss herausfinden, welche der Kacheln erforderlich sein könnten und diese in einen Zwischenspeicher von Texturen auf dem Grafikprozessor zu laden – ein Softwareauslagerungssystem.</span><span class="sxs-lookup"><span data-stu-id="ce606-132">The application must figure out which tiles might be needed and load them into a cache of textures on the GPU - a software paging system.</span></span>

<span data-ttu-id="ce606-133">Ein erheblicher Nachteil dieses Ansatzes besteht darin, dass die Hardware keine Kenntnisse über die Auslagerungsprozesse hat. Wenn ein Teil eines Bildes auf dem Bildschirm angezeigt werden muss, der Kacheln überspannt, dann weiß die Hardware nicht, wie die feste Filterfunktion (effizient) auf allen Kacheln ausgeführt werden muss.</span><span class="sxs-lookup"><span data-stu-id="ce606-133">A significant downside to that approach comes from the hardware not knowing anything about the paging that is going on: When a part of an image needs to be shown on screen that straddles tiles, the hardware does not know how to perform fixed function (that is, efficient) filtering across tiles.</span></span> <span data-ttu-id="ce606-134">Dies bedeutet, dass die Anwendung, die ihre eigene Software-Kachelunterteilung handhabt, zur manuellen Texturfilterung im Shader-Code greifen muss (dies kann sehr teuer werden, wenn ein hochwertiger anisotropischer Filter gewünscht wird); weiterhin wird möglicherweise Speicherplatz für die Erstellung von Rinnen rund um die Kacheln verschwendet, die Daten benachbarter Kacheln enthalten, damit die Hardwarefilterung mit festen Funktionen weiterhin nützlich sein kann.</span><span class="sxs-lookup"><span data-stu-id="ce606-134">This means the application managing its own software tiling must resort to manual texture filtering in shader code (which becomes very expensive if a good quality anisotropic filter is desired) and/or waste memory authoring gutters around tiles that contain data from neighboring tiles so that fixed function hardware filtering can continue to provide some assistance.</span></span>

## <a name="span-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanspan-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanspan-idmakingtiledrepresentationofsurfaceallocationsafirst-classfeaturespanmaking-tiled-representation-of-surface-allocations-a-first-class-feature"></a><span data-ttu-id="ce606-135"><span id="Making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="MAKING_TILED_REPRESENTATION_OF_SURFACE_ALLOCATIONS_A_FIRST-CLASS_FEATURE"></span>Gekachelte Repräsentationen von Oberflächenzuordnungen als First-Class-Feature</span><span class="sxs-lookup"><span data-stu-id="ce606-135"><span id="Making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="making_tiled_representation_of_surface_allocations_a_first-class_feature"></span><span id="MAKING_TILED_REPRESENTATION_OF_SURFACE_ALLOCATIONS_A_FIRST-CLASS_FEATURE"></span>Making tiled representation of surface allocations a first-class feature</span></span>


<span data-ttu-id="ce606-136">Wenn eine gekachelte Repräsentation von Oberflächenzuordnungen ein First-Class-Feature des Grafiksystems ist, kann die Anwendung der Hardware mitteilen, welche Kacheln verfügbar gemacht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="ce606-136">If a tiled representation of surface allocations is a first-class feature in the graphics system, the application could tell the hardware which tiles to make available.</span></span> <span data-ttu-id="ce606-137">Auf diese Weise wird weniger Grafikprozessorspeicher für die Speicherung von Oberflächenregionen verschwendet, von denen die Anwendung weiß, dass auf sie nicht zugegriffen wird, und die Hardware kann die Filterung über benachbarte Kacheln durchführen und so das Leben für Entwickler vereinfachen, die die Software-Kachelunterteilung selbst durchführen.</span><span class="sxs-lookup"><span data-stu-id="ce606-137">In this way, less GPU memory is wasted storing regions of surfaces that the application knows will not be accessed, and the hardware can understand how to filter across adjacent tiles, alleviating some of the pain experienced by developers who perform software tiling on their own.</span></span>

<span data-ttu-id="ce606-138">Für eine vollständige Lösung ist es jedoch erforderlich, die Tatsache zu berücksichtigen, dass die maximale Oberflächengröße unabhängig davon, ob auf einer Oberfläche Kacheln unterstützt werden, derzeit bei 16384 liegt – weit von den mehr als 128 K entfernt, die Anwendungen wirklich verlangen.</span><span class="sxs-lookup"><span data-stu-id="ce606-138">But to provide a complete solution, something must be done to deal with the fact that, independent of whether tiling within a surface is supported, the maximum surface dimension is currently 16384 - nowhere near the 128K+ that applications already want.</span></span> <span data-ttu-id="ce606-139">Eine Möglichkeit dafür besteht darin, zu verlangen, dass die Hardware größere Texturen unterstützt, dies ist aber mit erheblichen Kosten und/oder Nachteilen verbunden.</span><span class="sxs-lookup"><span data-stu-id="ce606-139">Just requiring the hardware to support larger texture sizes is one approach, however there are significant costs and/or tradeoffs to going this route.</span></span>

<span data-ttu-id="ce606-140">Der Texturfilter- und der Renderingpfad von Direct3D sind bereits hinsichtlich der präzisen Unterstützung von 16 K-Texturen zusammen mit den anderen Anforderungen ausgelastet, wie etwa der Unterstützung von Viewport-Erweiterungen über die Oberfläche hinaus beim Rendern oder der Unterstützung des Texturumbruchs über den Rand der Oberfläche hinaus beim Filtern.</span><span class="sxs-lookup"><span data-stu-id="ce606-140">Direct3D's texture filter path and rendering path are already saturated in terms of precision in supporting 16K textures with the other requirements, such as supporting viewport extents falling off the surface during rendering, or supporting texture wrapping off the surface edge during filtering.</span></span> <span data-ttu-id="ce606-141">Eine Möglichkeit besteht darin, einen Kompromiss zu definieren, der etwa so aussieht, dass die Texturgröße über 16 K hinaus wächst, während dann Funktionalität und oder Präzision in bestimmtem Maße beeinträchtigt werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-141">A possibility is to define a tradeoff such that as the texture size increases beyond 16K, functionality/precision is given up in some manner.</span></span> <span data-ttu-id="ce606-142">Aber selbst bei einem solchen Kompromiss fallen möglicherweise höhere Hardwarekosten für Adressierungsfunktionen im gesamten Hardwaresystem an, um größere Texturen zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="ce606-142">Even with this concession however, additional hardware costs might be required in terms of addressing capability throughout the hardware system to go to larger texture sizes.</span></span>

## <a name="span-idissuewithlargetexturesprecisionforlocationsonsurfacespanspan-idissuewithlargetexturesprecisionforlocationsonsurfacespanspan-idissuewithlargetexturesprecisionforlocationsonsurfacespanissue-with-large-textures-precision-for-locations-on-surface"></a><span data-ttu-id="ce606-143"><span id="Issue_with_large_textures__precision_for_locations_on_surface"></span><span id="issue_with_large_textures__precision_for_locations_on_surface"></span><span id="ISSUE_WITH_LARGE_TEXTURES__PRECISION_FOR_LOCATIONS_ON_SURFACE"></span>Problem mit umfangreichen Texturen: Präzision für Orte auf Oberflächen</span><span class="sxs-lookup"><span data-stu-id="ce606-143"><span id="Issue_with_large_textures__precision_for_locations_on_surface"></span><span id="issue_with_large_textures__precision_for_locations_on_surface"></span><span id="ISSUE_WITH_LARGE_TEXTURES__PRECISION_FOR_LOCATIONS_ON_SURFACE"></span>Issue with large textures: precision for locations on surface</span></span>


<span data-ttu-id="ce606-144">Eines der Probleme mit großen Texturen besteht darin, dass Fließkomma-Texturkoordinaten mit eindeutiger Präzision (und die zugehörigen Interpolatoren für die Unterstützung der Rasterisierung) nicht präzise genug sind, um Orte auf der Oberfläche korrekt angeben zu können.</span><span class="sxs-lookup"><span data-stu-id="ce606-144">One issue that comes into play as textures get very large is that single precision floating point texture coordinates (and the associated interpolators to support rasterization) run out of precision to specify locations on the surface accurately.</span></span> <span data-ttu-id="ce606-145">Dies führt zu einer „flackernden“ Texturfilterung.</span><span class="sxs-lookup"><span data-stu-id="ce606-145">Jittery texture filtering would ensue.</span></span> <span data-ttu-id="ce606-146">Eine kostspielige Option würde darin bestehen, die Unterstützung von Interpolatoren mit doppelter Präzision zu fordern, dies wäre jedoch ein zu großer Aufwand angesichts einer sinnvollen Alternative.</span><span class="sxs-lookup"><span data-stu-id="ce606-146">One expensive option would be to require double precision interpolator support, though that could be overkill given a reasonable alternative.</span></span>

## <a name="span-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanspan-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanspan-idenablingmultipleresourcesofdifferentdimensionstosharememoryspanenabling-multiple-resources-of-different-dimensions-to-share-memory"></a><span data-ttu-id="ce606-147"><span id="Enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="ENABLING_MULTIPLE_RESOURCES_OF_DIFFERENT_DIMENSIONS_TO_SHARE_MEMORY"></span>Aktivieren mehrerer Ressourcen unterschiedlicher Abmessungen für die gemeinsame Speicherverwendung</span><span class="sxs-lookup"><span data-stu-id="ce606-147"><span id="Enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="enabling_multiple_resources_of_different_dimensions_to_share_memory"></span><span id="ENABLING_MULTIPLE_RESOURCES_OF_DIFFERENT_DIMENSIONS_TO_SHARE_MEMORY"></span>Enabling multiple resources of different dimensions to share memory</span></span>


<span data-ttu-id="ce606-148">Ein weiteres Szenario für Streamingressourcen ist die Aktivierung mehrerer Ressourcen unterschiedlicher Abmessungen/Formate für die gemeinsame Nutzung desselben Speichers.</span><span class="sxs-lookup"><span data-stu-id="ce606-148">Another scenario that could be served by streaming resources is enabling multiple resources of different dimensions/formats to share the same memory.</span></span> <span data-ttu-id="ce606-149">Manchmal verfügen Anwendungen über exklusive Sätze von Ressourcen, von denen bekannt ist, dass sie nie zur selben Zeit verwendet werden müssen, oder über Ressourcen, die nur sehr kurzzeitig verwendet und dann zerstört werden, worauf dann andere Ressourcen erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="ce606-149">Sometimes applications have exclusive sets of resources that are known not to be used at the same time, or resources that are created only for very brief use and then destroyed, followed by creation of other resources.</span></span> <span data-ttu-id="ce606-150">Eine allgemeine Tatsache außerhalb des Bereiches von „Streamingressourcen“ ist, dass es möglich ist, Benutzern zu gestatten, auf mehrere Ressourcen im selben (überlappenden) Speicher zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="ce606-150">A form of generality that can fall out of "streaming resources" is that it is possible to allow the user to point multiple different resources at the same (overlapping) memory.</span></span> <span data-ttu-id="ce606-151">Anders ausgedrückt: Die Erstellung und Zerstörung von „Ressourcen“ (die eine Abmessung, ein Format o. dgl. definieren) kann von der Verwaltung des Speichers getrennt werden, die den Ressourcen aus Sicht der Anwendung unterliegt.</span><span class="sxs-lookup"><span data-stu-id="ce606-151">In other words, the creation and destruction of "resources" (which define a dimension/format and so on) can be decoupled from the management of the memory underlying the resources from the application's point of view.</span></span>

## <a name="span-idrelated-topicsspanrelated-topics"></a><span data-ttu-id="ce606-152"><span id="related-topics"></span>Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="ce606-152"><span id="related-topics"></span>Related topics</span></span>


[<span data-ttu-id="ce606-153">Streamingressourcen</span><span class="sxs-lookup"><span data-stu-id="ce606-153">Streaming resources</span></span>](streaming-resources.md)

 

 




