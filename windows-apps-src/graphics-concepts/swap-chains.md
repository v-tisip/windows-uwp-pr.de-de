---
title: Swapchains
description: Eine Swapchain ist eine Sammlung von Puffern, die zum Anzeigen von Frames für den Benutzer verwendet werden.
ms.assetid: A38E8BB7-1E77-4D93-B321-D3572A80D5DD
keywords:
- Swapchains
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: b38dc50f38276fb367402b230e6199fbabdcef80
ms.sourcegitcommit: e38b334edb82bf2b1474ba686990f4299b8f59c7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/15/2018
ms.locfileid: "6843922"
---
# <a name="swap-chains"></a><span data-ttu-id="b691b-104">Swapchains</span><span class="sxs-lookup"><span data-stu-id="b691b-104">Swap chains</span></span>


<span data-ttu-id="b691b-105">Eine Swapchain ist eine Sammlung von Puffern, die zum Anzeigen von Frames für den Benutzer verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="b691b-105">A swap chain is a collection of buffers that are used for displaying frames to the user.</span></span> <span data-ttu-id="b691b-106">Bei jeder Darstellung eines neuen Frames für eine Anzeige durch eine Anwendung wird der erste Puffer der Swapchain zum Anzeigepuffer.</span><span class="sxs-lookup"><span data-stu-id="b691b-106">Each time an application presents a new frame for display, the first buffer in the swap chain takes the place of the displayed buffer.</span></span> <span data-ttu-id="b691b-107">Dieser Prozess wird *Austauschen* oder *Kippen* genannt.</span><span class="sxs-lookup"><span data-stu-id="b691b-107">This process is called *swapping* or *flipping*.</span></span>

<span data-ttu-id="b691b-108">Eine Grafikkarte enthält einen Zeiger auf eine als Frontpuffer bezeichnete Oberfläche, die das auf dem Monitor anzuzeigende Bild darstellt.</span><span class="sxs-lookup"><span data-stu-id="b691b-108">A graphics adapter holds a pointer to a surface that represents the image being displayed on the monitor, called a front buffer.</span></span> <span data-ttu-id="b691b-109">Wenn der Monitor aktualisiert wird, sendet die Grafikkarte den Inhalt des Frontpuffers zur Anzeige an dem Monitor.</span><span class="sxs-lookup"><span data-stu-id="b691b-109">As the monitor is refreshed, the graphics card sends the contents of the front buffer to the monitor to be displayed.</span></span> <span data-ttu-id="b691b-110">Dies führt aber beim Rendern von Grafiken in Echtzeit zu dem Problem des „Abreißens”.</span><span class="sxs-lookup"><span data-stu-id="b691b-110">However, this leads to a "tearing" problem when rendering real-time graphics.</span></span> <span data-ttu-id="b691b-111">Im Wesentlichen besteht das Problem darin, dass die Aktualisierungsrate des Monitors im Vergleich zum Rest des Computers sehr langsam ist.</span><span class="sxs-lookup"><span data-stu-id="b691b-111">The heart of the problem is that monitor refresh rates are very slow in comparison to the rest of the computer.</span></span> <span data-ttu-id="b691b-112">Übliche Aktualisierungsraten liegen zwischen 60Hz (60Mal pro Sekunde) und 100Hz.</span><span class="sxs-lookup"><span data-stu-id="b691b-112">Common refresh rates range from 60 Hz (60 times per second) to 100 Hz.</span></span>

<span data-ttu-id="b691b-113">Wenn Ihre Anwendung den Frontpuffer aktualisiert, während der Monitor sich mitten in einer Aktualisierung befindet, wird das angezeigte Bild in der Mitte abgerissen. Die obere Hälfte des Bildschirms enthält das alte Bild und die untere Hälfte das neue Bild.</span><span class="sxs-lookup"><span data-stu-id="b691b-113">If your application is updating the front buffer while the monitor is in the middle of a refresh, the image that is displayed will be cut in half with the upper half of the display containing the old image and the lower half containing the new image.</span></span> <span data-ttu-id="b691b-114">Dieses Problem wird als *Abreißen* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="b691b-114">This problem is referred to as *tearing*.</span></span>

## <a name="span-idavoidingtearingspanspan-idavoidingtearingspanspan-idavoidingtearingspanavoiding-tearing"></a><span data-ttu-id="b691b-115"><span id="Avoiding_tearing"></span><span id="avoiding_tearing"></span><span id="AVOIDING_TEARING"></span>Vermeiden des Abreißens</span><span class="sxs-lookup"><span data-stu-id="b691b-115"><span id="Avoiding_tearing"></span><span id="avoiding_tearing"></span><span id="AVOIDING_TEARING"></span>Avoiding tearing</span></span>


<span data-ttu-id="b691b-116">Direct3D implementiert zwei Optionen, um ein Abreißen zu vermeiden:</span><span class="sxs-lookup"><span data-stu-id="b691b-116">Direct3D implements two options to avoid tearing:</span></span>

-   <span data-ttu-id="b691b-117">Eine Option, um nur Aktualisierungen des Monitors bei der vertikalen Synchronisierung zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="b691b-117">An option to only allow updates of the monitor on the vertical retrace (or vertical sync) operation.</span></span> <span data-ttu-id="b691b-118">Ein Monitor aktualisiert das Bild in der Regel durch einen Lichtpunkt, der horizontal in Zickzacklinien von links oben nach rechts unten verläuft.</span><span class="sxs-lookup"><span data-stu-id="b691b-118">A monitor typically refreshes its image by moving a light pin horizontally, zigzagging from the top left of the monitor and ending at the bottom right.</span></span> <span data-ttu-id="b691b-119">Wenn der Lichtpunkt unten angekommen ist, setzt der Monitor den Lichtpunkt wieder zurück nach links oben, sodass der Vorgang erneut beginnen kann.</span><span class="sxs-lookup"><span data-stu-id="b691b-119">When the light pin reaches the bottom, the monitor recalibrates the light pin by moving it back to the upper left so that the process can start again.</span></span>

    <span data-ttu-id="b691b-120">Diese Neukalibrierung wird vertikale Synchronisierung genannt. Bei einer vertikalen Synchronisierung ist der Monitor nicht nichts, zeichnen daher werden Aktualisierungen des Frontpuffers nicht angezeigt, bis der Monitor erneut zu zeichnen beginnt.</span><span class="sxs-lookup"><span data-stu-id="b691b-120">This recalibration is called a vertical sync. During a vertical sync, the monitor is not drawing anything, so any update to the front buffer will not be seen until the monitor starts to draw again.</span></span> <span data-ttu-id="b691b-121">Die vertikale Synchronisierung ist relativ langsam. Allerdings nicht langsam genug, um eine komplexe Szenen beim Warten zu rendern.</span><span class="sxs-lookup"><span data-stu-id="b691b-121">The vertical sync is relatively slow; however, not slow enough to render a complex scene while waiting.</span></span> <span data-ttu-id="b691b-122">Um ein Abreißen zu vermeiden und komplexe Szenen zu rendern, wird ein Prozess benötigt, der als Hintergrundpufferung bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="b691b-122">What is needed to avoid tearing and be able to render complex scenes is a process called back buffering.</span></span>

-   <span data-ttu-id="b691b-123">Eine Option, um die als Hintergrundpufferung bezeichnete Technik zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="b691b-123">An option to use a technique called back buffering.</span></span> <span data-ttu-id="b691b-124">Hintergrundpufferung ist der Prozess des Zeichnens einer Szene auf eine Offscreenoberfläche, die Hintergrundpuffer genannt wird.</span><span class="sxs-lookup"><span data-stu-id="b691b-124">Back buffering is the process of drawing a scene to an off-screen surface, called a back buffer.</span></span> <span data-ttu-id="b691b-125">Jede Oberfläche mit Ausnahme des Frontpuffers wird als Offscreenoberfläche bezeichnet, weil diese nie direkt vom Monitor angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="b691b-125">Any surface other than the front buffer is called an off-screen surface because it is never directly viewed by the monitor.</span></span>

    <span data-ttu-id="b691b-126">Mit einem Hintergrundpuffer hat eine Anwendung die Möglichkeit, eine Szene zu rendern, wenn das System sich im Leerlauf befindet (d.h. keine Windows-Meldungen warten), ohne dass die Aktualisierungsrate des Monitors berücksichtigt werden muss.</span><span class="sxs-lookup"><span data-stu-id="b691b-126">By using a back buffer, an application has the freedom to render a scene whenever the system is idle (that is, no windows messages are waiting) without having to consider the monitor's refresh rate.</span></span> <span data-ttu-id="b691b-127">Hintergrundpufferung führt eine zusätzliche Schwierigkeit ein, nämlich die Frage, wie und wann der Hintergrundpuffer in den Frontpuffer verschoben werden soll.</span><span class="sxs-lookup"><span data-stu-id="b691b-127">Back buffering brings in an additional complication of how and when to move the back buffer to the front buffer.</span></span>

## <a name="span-idsurfaceflippingspanspan-idsurfaceflippingspanspan-idsurfaceflippingspansurface-flipping"></a><span data-ttu-id="b691b-128"><span id="Surface_flipping"></span><span id="surface_flipping"></span><span id="SURFACE_FLIPPING"></span>Kippen von Oberflächen</span><span class="sxs-lookup"><span data-stu-id="b691b-128"><span id="Surface_flipping"></span><span id="surface_flipping"></span><span id="SURFACE_FLIPPING"></span>Surface flipping</span></span>


<span data-ttu-id="b691b-129">Der Prozess des Verschiebens des Hintergrundpuffers in den Frontpuffer wird „Kippen der Oberfläche” genannt.</span><span class="sxs-lookup"><span data-stu-id="b691b-129">The process of moving the back buffer to the front buffer is called surface flipping.</span></span> <span data-ttu-id="b691b-130">Da die Grafikkarte einfach einen Zeiger auf eine Oberfläche verwendet, um den Frontpuffer darzustellen, ist eine Änderung des Zeigers alles, was erforderlich ist, um den Hintergrundpuffer auf den Frontpuffer festzulegen.</span><span class="sxs-lookup"><span data-stu-id="b691b-130">Because the graphics card simply uses a pointer to a surface to represent the front buffer, a simple pointer change is all that is needed to set the back buffer to the front buffer.</span></span> <span data-ttu-id="b691b-131">Wenn eine Anwendung Direct3D auffordert, den Hintergrundpuffer in den Frontpuffer zu verschieben, vertauscht Direct3D einfach die beiden Oberflächenzeiger.</span><span class="sxs-lookup"><span data-stu-id="b691b-131">When an application asks Direct3D to present the back buffer to the front buffer, Direct3D simply "flips" the two surface pointers.</span></span> <span data-ttu-id="b691b-132">Das Ergebnis ist, dass der Hintergrundpuffer jetzt der neue Frontpuffer ist und der alte Frontpuffer der neue Hintergrundpuffer.</span><span class="sxs-lookup"><span data-stu-id="b691b-132">The result is that the back buffer is now the new front buffer, and the old front buffer is the new back buffer.</span></span>

<span data-ttu-id="b691b-133">Das Kippen der Oberfläche wird immer aufgerufen, wenn eine Anwendung das Direct3D-Gerät auffordert, den Hintergrundpuffer darzustellen. Direct3D kann aber auch so eingerichtet werden, dass die Anforderungen in eine Warteschlange gestellt werden, bis eine vertikale Synchronisierung erfolgt.</span><span class="sxs-lookup"><span data-stu-id="b691b-133">A surface flip is invoked whenever an application asks the Direct3D device to present the back buffer; however, Direct3D can be set up to queue the requests until a vertical sync occurs.</span></span> <span data-ttu-id="b691b-134">Diese Option wird als das Darstellungsintervall des Direct3D-Geräts bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="b691b-134">This option is referred to as the Direct3D device's presentation interval.</span></span> <span data-ttu-id="b691b-135">Die Daten in dem neuen Hintergrundpuffer sind möglicherweise nicht wiederverwendbar. Das hängt davon ab, wie eine Anwendung die Behandlung des Kippens der Oberfläche durch Direct3D festlegt.</span><span class="sxs-lookup"><span data-stu-id="b691b-135">The data in the new back buffer may not be reusable, depending on how an application specifies how Direct3D should handle surface flipping.</span></span>

<span data-ttu-id="b691b-136">Das Kippen der Oberfläche ist in Multimedia-, Animations- und Spielesoftware wichtig. Es entspricht der Art und Weise, wie Sie Animationen mit einem Notizblock (Daumenkino) ausführen können.</span><span class="sxs-lookup"><span data-stu-id="b691b-136">Surface flipping is key in multimedia, animation, and game software; it is equivalent to the way you can do animation with a pad of paper.</span></span> <span data-ttu-id="b691b-137">Auf jeder Seite ändert der Zeichner die Figuren etwas, sodass beim schnellen Durchblättern der Seiten die Zeichnung animiert erscheint.</span><span class="sxs-lookup"><span data-stu-id="b691b-137">On each page, the artist changes the figures slightly, so that when you flip rapidly between sheets, the drawing appears animated.</span></span>

## <a name="span-idrelated-topicsspanrelated-topics"></a><span data-ttu-id="b691b-138"><span id="related-topics"></span>Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="b691b-138"><span id="related-topics"></span>Related topics</span></span>


[<span data-ttu-id="b691b-139">Geräte</span><span class="sxs-lookup"><span data-stu-id="b691b-139">Devices</span></span>](devices.md)

 

 




