---
title: Regeln für die Rasterung
description: Regeln für die Rasterung definieren, wie Vektordaten Rasterdaten zugeordnet werden.
ms.assetid: B604725F-96A5-4DB6-B597-9EC57FBBC024
keywords:
- Regeln für die Rasterung
author: michaelfromredmond
ms.author: mithom
ms.date: 02/08/2017
ms.topic: article
ms.localizationpriority: medium
ms.openlocfilehash: 72be66c3bf7b0e58092ae3a7e1baf82c9e686f0c
ms.sourcegitcommit: 753e0a7160a88830d9908b446ef0907cc71c64e7
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/30/2018
ms.locfileid: "5758170"
---
# <a name="rasterization-rules"></a><span data-ttu-id="33943-104">Regeln für die Rasterung</span><span class="sxs-lookup"><span data-stu-id="33943-104">Rasterization rules</span></span>


<span data-ttu-id="33943-105">Die Regeln für die Rasterung legen fest, wie Vektordaten Rasterdaten zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="33943-105">Rasterization rules define how vector data is mapped into raster data.</span></span> <span data-ttu-id="33943-106">Das Rasterdaten werden an Positionen ganzer Zahlen angedockt, die dann entfernt und abgeschnitten werden (um die minimale Anzahl an Pixeln zu zeichnen), und Pro-Pixel-Attribute werden (aus den Vertex-Attributen) vor der Übergabe an einen Pixel-Shader interpoliert.</span><span class="sxs-lookup"><span data-stu-id="33943-106">The raster data is snapped to integer locations that are then culled and clipped (to draw the minimum number of pixels), and per-pixel attributes are interpolated (from per-vertex attributes) before being passed to a pixel shader.</span></span>

<span data-ttu-id="33943-107">Es gibt verschiedene Arten von Regeln, die vom Typ des Grundtyps abhängen, der zugeordnet wird, und davon, ob die Daten Multisampling verwenden, um Aliase zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="33943-107">There are several types of rules, which depend on the type of primitive that is being mapped, as well as whether or not the data uses multisampling to reduce aliasing.</span></span> <span data-ttu-id="33943-108">Die folgenden Abbildungenveranschaulichen, wie die Ausnahmefälle behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="33943-108">The following illustrations demonstrate how the corner cases are handled.</span></span>

## <a name="span-idtrianglespanspan-idtrianglespanspan-idtrianglespantriangle-rasterization-rules-without-multisampling"></a><span data-ttu-id="33943-109"><span id="Triangle"></span><span id="triangle"></span><span id="TRIANGLE"></span>Regeln für die Dreiecksrasterung (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="33943-109"><span id="Triangle"></span><span id="triangle"></span><span id="TRIANGLE"></span>Triangle Rasterization Rules (Without Multisampling)</span></span>


<span data-ttu-id="33943-110">Jedes Pixelzentrum innerhalb eines Dreiecks wird gezeichnet. Ein Pixel wird als innerhalb angenommen, wenn es die Links-oben-Regel erfüllt.</span><span class="sxs-lookup"><span data-stu-id="33943-110">Any pixel center which falls inside a triangle is drawn; a pixel is assumed to be inside if it passes the top-left rule.</span></span> <span data-ttu-id="33943-111">Die Links-oben-Regel besagt, dass ein Pixelzentrum als innerhalb eines Dreiecks definiert wird, wenn es sich auf dem oberen oder linken Rand eines Dreiecks befindet.</span><span class="sxs-lookup"><span data-stu-id="33943-111">The top-left rule is that a pixel center is defined to lie inside of a triangle if it lies on the top edge or the left edge of a triangle.</span></span>

<span data-ttu-id="33943-112">wobei gilt:</span><span class="sxs-lookup"><span data-stu-id="33943-112">where:</span></span>

-   <span data-ttu-id="33943-113">Ein oberer Rand ist ein Rand, der genau horizontal und oberhalb der anderen Ränder liegt.</span><span class="sxs-lookup"><span data-stu-id="33943-113">A top edge, is an edge that is exactly horizontal and is above the other edges.</span></span>
-   <span data-ttu-id="33943-114">Ein linker Rand ist ein Rand, der nicht genau horizontal liegt und sich auf der linken Seite des Dreiecks befindet. Ein Dreieck kann einen oder zwei linke Rändern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="33943-114">A left edge, is an edge that is not exactly horizontal and is on the left side of the triangle A triangle can have one or two left edges.</span></span>

<span data-ttu-id="33943-115">Die Oben-links-Regel stellt sicher, dass angrenzende Dreiecke ein Mal gezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="33943-115">The top-left rule ensures that adjacent triangles are drawn once.</span></span>

<span data-ttu-id="33943-116">Diese Abbildungzeigt Beispiele für Pixel, die gezeichnet werden, weil sie innerhalb eines Dreiecks liegen oder die Oben-links-Regel erfüllen.</span><span class="sxs-lookup"><span data-stu-id="33943-116">This illustration shows examples of pixels that are drawn because they either lie inside a triangle or follow the top-left rule.</span></span>

![Beispiele für die Oben-Links-Dreiecksrasterung](images/d3d10-rasterrulestriangle.png)

<span data-ttu-id="33943-118">Die hell- und dunkelgrauen Abdeckungen der Pixel zeigen sie als Pixelgruppen an, um anzugeben, in welchem Dreieck sie sich befinden.</span><span class="sxs-lookup"><span data-stu-id="33943-118">The light and dark gray covering of the pixels show them as groups of the pixels to indicate which triangle they are inside.</span></span>

## <a name="span-idline1spanspan-idline1spanspan-idline1spanline-rasterization-rules-aliased-without-multisampling"></a><span data-ttu-id="33943-119"><span id="Line_1"></span><span id="line_1"></span><span id="LINE_1"></span>Regeln für die Linienrasterung (mit Alias, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="33943-119"><span id="Line_1"></span><span id="line_1"></span><span id="LINE_1"></span>Line Rasterization Rules (Aliased, Without Multisampling)</span></span>


<span data-ttu-id="33943-120">Regeln für die Linienrasterung verwenden einen rautenförmigen Testbereich, um zu bestimmen, ob eine Linie einen Pixel abdeckt.</span><span class="sxs-lookup"><span data-stu-id="33943-120">Line rasterization rules use a diamond test area to determine if a line covers a pixel.</span></span> <span data-ttu-id="33943-121">Für X-Major-Linien (Linien mit -1 &lt;= Neigung &lt;= +1) umfasst der rautenförmige Testbereich (ausgefüllt angezeigt) den unteren linken Rand, den unteren rechten Rand und die untere Ecke. Die Raute umfasst nicht (gepunktet angezeigt) den oberen linken Rand, den oberen rechten Rand, die obere Ecke, die linke Ecke und die rechte Ecke.</span><span class="sxs-lookup"><span data-stu-id="33943-121">For x-major lines (lines with -1 &lt;= slope &lt;= +1), the diamond test area includes (shown solid) the lower-left edge, lower-right edge, and bottom corner; the diamond excludes (shown dotted) the upper-left edge, upper-right edge, the top corder, the left corner, and the right corner.</span></span> <span data-ttu-id="33943-122">Eine Y-Major-Linie ist jede Linie, die keine X-Major-Linie ist. Der rautenförmige Testbereich ist mit dem für die X-Major-Linie beschriebenen identisch, mit der Ausnahme, dass die rechte Ecke ebenfalls enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="33943-122">A y-major line is any line that is not an x-major line; the test diamond area is the same as described for the x-major line except the right corner is also included.</span></span>

<span data-ttu-id="33943-123">Im rautenförmigen Bereich deckt eine Linie einen Pixel ab, wenn die Linie den rautenförmigen Testbereich des Pixels verlässt, wenn sie vom Start in Richtung Ende daran entlang verläuft.</span><span class="sxs-lookup"><span data-stu-id="33943-123">Given the diamond area, a line covers a pixel if the line exits the pixel's diamond test area when traveling along the line from the start towards the end.</span></span> <span data-ttu-id="33943-124">Ein Linienstreifen verhält sich ebenfalls so, wenn er als Abfolge von Linien gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="33943-124">A line strip behaves the same, as it is drawn as a sequence of lines.</span></span>

<span data-ttu-id="33943-125">Die folgende Abbildung zeigt einige Beispiele.</span><span class="sxs-lookup"><span data-stu-id="33943-125">The following illustration shows some examples.</span></span>

![Beispiele für eine Linienrasterung mit Aliasing](images/d3d10-rasterrulesline.png)

## <a name="span-idline2spanspan-idline2spanspan-idline2spanline-rasterization-rules-antialiased-without-multisampling"></a><span data-ttu-id="33943-127"><span id="Line_2"></span><span id="line_2"></span><span id="LINE_2"></span>Regeln für die Linienrasterung (mit Antialiasing, ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="33943-127"><span id="Line_2"></span><span id="line_2"></span><span id="LINE_2"></span>Line Rasterization Rules (Antialiased, Without Multisampling)</span></span>


<span data-ttu-id="33943-128">Eine Linie mit Antialiasing ist wie ein Rechteck gerastert (mit Breite = 1).</span><span class="sxs-lookup"><span data-stu-id="33943-128">An antialiased line is rasterized as if it were a rectangle (with width = 1).</span></span> <span data-ttu-id="33943-129">Das Rechteck überschneidet sich mit einem Renderziel und erzeugt Pro-Pixel-Abdeckungswerte, die in Pixel-Shader-Ausgabe-Alphakomponenten multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="33943-129">The rectangle intersects with a render target producing per-pixel coverage values, which are multiplied into pixel shader output alpha components.</span></span> <span data-ttu-id="33943-130">Es wird kein Antialiasing beim Zeichnen von Linien auf einem Renderziel mit Multisampling durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="33943-130">There is no antialiasing preformed when drawing lines on a multisampled render target.</span></span>

<span data-ttu-id="33943-131">Es gilt, dass es keine einzelne "beste" Methode zum Durchführen eines Linienrenderings mit Antialiasing gibt.</span><span class="sxs-lookup"><span data-stu-id="33943-131">It is deemed that there is no single "best" way to perform antialiased line rendering.</span></span> <span data-ttu-id="33943-132">Direct3D verwendet als Richtlinie die in der folgenden Abbildungdargestellte Methode.</span><span class="sxs-lookup"><span data-stu-id="33943-132">Direct3D adopts as a guideline the method shown in the following illustration.</span></span> <span data-ttu-id="33943-133">Diese Methode wurde empirisch abgeleitet ist und zeigt eine Reihe von visuellen Eigenschaften, die als wünschenswert angesehen werden.</span><span class="sxs-lookup"><span data-stu-id="33943-133">This method was derived empirically, exhibiting a number of visual properties deemed desirable.</span></span>

<span data-ttu-id="33943-134">Hardware muss diesem Algorithmus nicht exakt entsprechen. Tests für diesen Verweis sollten "angemessene" Toleranzen haben, die auf einigen der weiter unten aufgelisteten Prinzipien basieren, sodass verschiedene Hardwareimplementierungen und Filter-Kernel-Größen ermöglicht werden.</span><span class="sxs-lookup"><span data-stu-id="33943-134">Hardware need not exactly match this algorithm; tests against this reference shall have "reasonable" tolerances, guided by some of the principles listed further below, permitting various hardware implementations and filter kernel sizes.</span></span> <span data-ttu-id="33943-135">Diese bei der Hardwareimplementierung zulässige Flexibilität kann jedoch nicht über Direct3D zu Anwendungen kommuniziert werden. Es können lediglich Linien gezeichnet und ihr Aussehen beobachten/gemessen werden.</span><span class="sxs-lookup"><span data-stu-id="33943-135">None of this flexibility permitted in hardware implementation, however, can be communicated up through Direct3D to applications, beyond simply drawing lines and observing/measuring how they look.</span></span>

![Beispiele für eine Linienrasterung mit Antialiasing](images/d3d10-rasterruleslineaa.png)

<span data-ttu-id="33943-137">Dieser Algorithmus generiert relativ weiche Linien mit einheitlicher Intensität und mit minimalen ausgefransten Rändern sowie minimalem Braiding.</span><span class="sxs-lookup"><span data-stu-id="33943-137">This algorithm generates relatively smooth lines, with uniform intensity, with minimal jagged edges or braiding.</span></span> <span data-ttu-id="33943-138">Moiremuster für abschließende Linien werden minimiert.</span><span class="sxs-lookup"><span data-stu-id="33943-138">Moire patterning for close lines is minimized.</span></span> <span data-ttu-id="33943-139">Es gibt eine gute Abdeckung für Verbindungen zwischen Liniensegmenten, die End-to-End platziert werden.</span><span class="sxs-lookup"><span data-stu-id="33943-139">There is good coverage for junctions between line segments placed end-to-end.</span></span>

<span data-ttu-id="33943-140">Der Filter-Kernel ist ein angemessener Kompromiss zwischen der Weichzeichnung des Rands und den Intensitätsänderungen, die durch Gammakorrekturen verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="33943-140">The filter kernel is a reasonable tradeoff between the amount of edge blurring and the changes in intensity caused by gamma corrections.</span></span> <span data-ttu-id="33943-141">Der Abdeckungswert wird in Pixel-Shader o0.a (srcAlpha) durch die folgende Formel von der [OM-Phase (Output Merger)](output-merger-stage--om-.md) multipliziert :</span><span class="sxs-lookup"><span data-stu-id="33943-141">The coverage value is multiplied into pixel shader o0.a (srcAlpha) per the following formula by the [Output Merger (OM) stage](output-merger-stage--om-.md):</span></span>

<span data-ttu-id="33943-142">srcColor \* srcAlpha + destColor \* (1-srcAlpha)</span><span class="sxs-lookup"><span data-stu-id="33943-142">srcColor \* srcAlpha + destColor \* (1-srcAlpha)</span></span>

## <a name="span-idpointspanspan-idpointspanspan-idpointspanpoint-rasterization-rules-without-multisampling"></a><span data-ttu-id="33943-143"><span id="Point"></span><span id="point"></span><span id="POINT"></span>Regeln für die Punktrasterung (ohne Multisampling)</span><span class="sxs-lookup"><span data-stu-id="33943-143"><span id="Point"></span><span id="point"></span><span id="POINT"></span>Point Rasterization Rules (Without Multisampling)</span></span>


<span data-ttu-id="33943-144">Ein Punkt wird so interpretiert, als würde er aus zwei Dreiecken in einem Z-Muster bestehen, die Regeln für die Dreiecksrasterung verwenden.</span><span class="sxs-lookup"><span data-stu-id="33943-144">A point is interpreted as though it were composed of two triangles in a Z pattern, which use triangle rasterization rules.</span></span> <span data-ttu-id="33943-145">Die Koordinate identifiziert die Mitte eines einen Pixel breiten Quadrats.</span><span class="sxs-lookup"><span data-stu-id="33943-145">The coordinate identifies the center of a one pixel wide square.</span></span> <span data-ttu-id="33943-146">Für Punkte gibt es kein Culling.</span><span class="sxs-lookup"><span data-stu-id="33943-146">There is no culling for points.</span></span>

<span data-ttu-id="33943-147">Die folgende Abbildung zeigt einige Beispiele.</span><span class="sxs-lookup"><span data-stu-id="33943-147">The following illustration shows some examples.</span></span>

![Beispiele für Punktrasterung](images/d3d10-rasterrulespoint.png)

## <a name="span-idmultisamplespanspan-idmultisamplespanspan-idmultisamplespanmultisample-anti-aliasing-rasterization-rules"></a><span data-ttu-id="33943-149"><span id="Multisample"></span><span id="multisample"></span><span id="MULTISAMPLE"></span>Regeln für die Multisample-Antialiasing-Rasterung</span><span class="sxs-lookup"><span data-stu-id="33943-149"><span id="Multisample"></span><span id="multisample"></span><span id="MULTISAMPLE"></span>Multisample Anti-Aliasing Rasterization Rules</span></span>


<span data-ttu-id="33943-150">Multisample-Antialiasing (MSAA) reduziert Geometrie-Aliasing mit Pixelabdeckung und Tiefenschablonentests an mehreren untergeordneten Beispielpositionen.</span><span class="sxs-lookup"><span data-stu-id="33943-150">Multisample antialiasing (MSAA) reduces geometry aliasing using pixel coverage and depth-stencil tests at multiple sub-sample locations.</span></span> <span data-ttu-id="33943-151">Zum Verbessern der Leistung werden Pro-Pixel-Berechnungen einmal für jedes abgedeckte Pixel ausgeführt, indem Shaderausgaben über abgedeckte Teilpixel hinweg gemeinsam genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="33943-151">To improve performance, per-pixel calculations are performed once for each covered pixel, by sharing shader outputs across covered sub-pixels.</span></span> <span data-ttu-id="33943-152">Multisample-Antialiasing reduziert nicht das Oberflächen-Aliasing.</span><span class="sxs-lookup"><span data-stu-id="33943-152">Multisample antialiasing does not reduce surface aliasing.</span></span> <span data-ttu-id="33943-153">Beispielpositionen und Wiederherstellungsfunktionen hängen von der Hardwareimplementierung ab.</span><span class="sxs-lookup"><span data-stu-id="33943-153">Sample locations and reconstruction functions are dependent on the hardware implementation.</span></span>

<span data-ttu-id="33943-154">Die folgende Abbildung zeigt einige Beispiele.</span><span class="sxs-lookup"><span data-stu-id="33943-154">The following illustration shows some examples.</span></span>

![Beispiele für Multisample-Antialiasing-Rasterung](images/d3d10-rasterrulesmsaa.png)

<span data-ttu-id="33943-156">Die Anzahl der Beispielpositionen ist vom Multisample-Modus abhängig.</span><span class="sxs-lookup"><span data-stu-id="33943-156">The number of sample locations is dependent on the multisample mode.</span></span> <span data-ttu-id="33943-157">Vertexattribute werden in der Pixelmitte interpoliert, da dort der Pixel-Shader aufgerufen wird (dies wird zur Extrapolation, wenn die Mitte nicht abgedeckt ist).</span><span class="sxs-lookup"><span data-stu-id="33943-157">Vertex attributes are interpolated at pixel centers, since this is where the pixel shader is invoked (this becomes extrapolation if the center is not covered).</span></span> <span data-ttu-id="33943-158">Attribute können im Pixel-Shader als mittig gesampelt markiert werden, sodass nicht abgedeckte Pixel das Attribut am Schnittpunkt zwischen dem Bereich und dem Grundtyp des Pixels interpolieren.</span><span class="sxs-lookup"><span data-stu-id="33943-158">Attributes can be flagged in the pixel shader to be centroid sampled, which causes non-covered pixels to interpolate the attribute at intersection of the pixel's area and the primitive.</span></span>

<span data-ttu-id="33943-159">Ein Pixel-Shader wird für jeden 2x2-Pixelbereich ausgeführt, um abgeleitete Berechnungen (die x- und y-Deltas verwenden) zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="33943-159">A pixel shader runs for each 2x2 pixel area to support derivative calculations (which use x and y deltas).</span></span> <span data-ttu-id="33943-160">Das heißt, dass Shader-Aufrufe mehr als gezeigt auftreten, um mindestens 2x2 Quanten (was unabhängig vom Multisampling ist) auszufüllen.</span><span class="sxs-lookup"><span data-stu-id="33943-160">This means that shader invocations occur more than is shown to fill out the minimum 2x2 quanta (which is independent of multisampling).</span></span> <span data-ttu-id="33943-161">Das Shader-Ergebnis wird für jedes abgedeckte Beispiel geschrieben, das den Pro-Beispiel-Tiefenschablonentest besteht.</span><span class="sxs-lookup"><span data-stu-id="33943-161">The shader result is written out for each covered sample that passes the per-sample depth-stencil test.</span></span>

<span data-ttu-id="33943-162">Regeln für die Grundtypenrasterung werden normalerweise durch Multisample-Antialiasing nicht geändert. Ausnahmen:</span><span class="sxs-lookup"><span data-stu-id="33943-162">Rasterization rules for primitives are, in general, unchanged by multisample antialiasing, except:</span></span>

-   <span data-ttu-id="33943-163">Für ein Dreieck wird ein Abdeckungstest für jede Beispielposition (nicht für eine Pixelmitte) ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="33943-163">For a triangle, a coverage test is performed for each sample location (not for a pixel center).</span></span> <span data-ttu-id="33943-164">Wenn mehr als eine Beispielposition abgedeckt wird, wird ein Pixel-Shader einmal mit Attributen ausgeführt, die in der Pixelmitte interpoliert werden.</span><span class="sxs-lookup"><span data-stu-id="33943-164">If more than one sample location is covered, a pixel shader runs once with attributes interpolated at the pixel center.</span></span> <span data-ttu-id="33943-165">Das Ergebnis wird für jede abgedeckte Beispielposition im Pixel, der den Tiefenschablonentest besteht, gespeichert (repliziert).</span><span class="sxs-lookup"><span data-stu-id="33943-165">The result is stored (replicated) for each covered sample location in the pixel that passes the depth/stencil test.</span></span>

    <span data-ttu-id="33943-166">Eine Linie wird als ein Rechteck, das aus zwei Dreiecken besteht, mit einer Linienbreite von 1,4 behandelt.</span><span class="sxs-lookup"><span data-stu-id="33943-166">A line is treated as a rectangle made up of two triangles, with a line width of 1.4.</span></span>

-   <span data-ttu-id="33943-167">Für einen Punkt wird ein Abdeckungstest für jede Beispielposition (nicht für eine Pixelmitte) ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="33943-167">For a point, a coverage test is performed for each sample location (not for a pixel center).</span></span>

<span data-ttu-id="33943-168">Multisampling-Formate können in Renderzielen verwendet werden, die wieder in Shader mithilfe von [load](https://msdn.microsoft.com/library/windows/desktop/bb509694) gelesen werden können, da für einzelne Beispiele, auf die der Shader zugreift, keine Lösung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="33943-168">Multisampling formats can be used in render targets which can be read back into shaders using [load](https://msdn.microsoft.com/library/windows/desktop/bb509694), since no resolve is required for individual samples accessed by the shader.</span></span> <span data-ttu-id="33943-169">Tiefenformate werden für Multisample-Ressourcen nicht unterstützt. Daher sind Tiefenformate auf Renderziele beschränkt.</span><span class="sxs-lookup"><span data-stu-id="33943-169">Depth formats are not supported for multisample resource, therefore, depth formats are restricted to render targets only.</span></span>

<span data-ttu-id="33943-170">Formate ohne Typ unterstützen Multisampling, um einer Ressourcenansicht das Interpretieren von Daten auf unterschiedliche Weise zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="33943-170">Typeless formats support multisampling to allow a resource view to interpret data in different ways.</span></span> <span data-ttu-id="33943-171">Sie können z.B. eine Multisample-Ressource mit R8G8B8A8\_TYPELESS erstellen, sie mithilfe einer Renderzielansichts-Ressource mit einem R8G8B8A8\_UINT-Format rendern und dann den Inhalt in eine andere Ressource mit einem R8G8B8A8\_UNORM-Datenformat auflösen.</span><span class="sxs-lookup"><span data-stu-id="33943-171">For instance, you could create a multisample resource using R8G8B8A8\_TYPELESS, render to it using a render-target-view resource with a R8G8B8A8\_UINT format, then resolve the contents to another resource with a R8G8B8A8\_UNORM data format.</span></span>

### <a name="span-idhardwaresupportspanspan-idhardwaresupportspanspan-idhardwaresupportspanhardware-support"></a><span data-ttu-id="33943-172"><span id="Hardware_Support"></span><span id="hardware_support"></span><span id="HARDWARE_SUPPORT"></span>Hardwareunterstützung</span><span class="sxs-lookup"><span data-stu-id="33943-172"><span id="Hardware_Support"></span><span id="hardware_support"></span><span id="HARDWARE_SUPPORT"></span>Hardware Support</span></span>

<span data-ttu-id="33943-173">Die API meldet Hardwareunterstützung für das Multisampling durch die Anzahl der Qualitätsstufen.</span><span class="sxs-lookup"><span data-stu-id="33943-173">The API reports hardware support for multisampling through the number of quality levels.</span></span> <span data-ttu-id="33943-174">Die Qualitätsstufe 0 bedeutet beispielsweise, dass die Hardware Multisampling (in einem bestimmten Format und auf einer bestimmten Qualitätsstufe) nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="33943-174">For example, a 0 quality level means the hardware does not support multisampling (at a particular format and quality level).</span></span> <span data-ttu-id="33943-175">Die Qualitätsstufe 3 bedeutet, dass die Hardware drei verschiedene Beispiellayouts und/oder -algorithmen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="33943-175">A 3 for quality levels means that the hardware supports three different sample layouts and/or resolve algorithms.</span></span> <span data-ttu-id="33943-176">Sie können auch Folgendes annehmen:</span><span class="sxs-lookup"><span data-stu-id="33943-176">You can also assume the following:</span></span>

-   <span data-ttu-id="33943-177">Jedes Format, das Multisampling unterstützt, unterstützt die gleiche Anzahl von Qualitätsstufen für jedes Format in dieser Familie.</span><span class="sxs-lookup"><span data-stu-id="33943-177">Any format that supports multisampling, supports the same number of quality levels for every format in that family.</span></span>
-   <span data-ttu-id="33943-178">Jedes Format, das Multisampling unterstützt und die Formate \_UNORM, \_SRGB, \_SNORM oder \_FLOAT aufweist, unterstützt auch das Auflösen.</span><span class="sxs-lookup"><span data-stu-id="33943-178">Every format that supports multisampling, and has the \_UNORM, \_SRGB, \_SNORM or \_FLOAT formats, also supports resolving.</span></span>

### <a name="span-idcentroidsamplingspanspan-idcentroidsamplingspanspan-idcentroidsamplingspancentroid-sampling-of-attributes-when-multisample-antialiasing"></a><span data-ttu-id="33943-179"><span id="Centroid_Sampling"></span><span id="centroid_sampling"></span><span id="CENTROID_SAMPLING"></span>Schwerpunkt-Sampling von Attributen beim Multisample-Antialiasing</span><span class="sxs-lookup"><span data-stu-id="33943-179"><span id="Centroid_Sampling"></span><span id="centroid_sampling"></span><span id="CENTROID_SAMPLING"></span>Centroid Sampling of Attributes when Multisample Antialiasing</span></span>

<span data-ttu-id="33943-180">Standardmäßig werden Vertexattribute während des Multisample-Antialiasing zu einer Pixelmitte interpoliert. Wenn die Pixelmitte nicht abgedeckt ist, werden die Attribute zu einer Pixelmitte extrapoliert.</span><span class="sxs-lookup"><span data-stu-id="33943-180">By default, vertex attributes are interpolated to a pixel center during multisample antialiasing; if the pixel center is not covered, attributes are extrapolated to a pixel center.</span></span> <span data-ttu-id="33943-181">Eine Pixel-Shader-Eingabe, die die Schwerpunktsemantik enthält (vorausgesetzt, dass das Pixel nicht vollständig abgedeckt ist), wird an einer beliebigen Stelle innerhalb des abgedeckten Bereichs des Pixels gesampelt, möglicherweise an einer der abgedeckten Beispielpositionen.</span><span class="sxs-lookup"><span data-stu-id="33943-181">If a pixel shader input that contains the centroid semantic (assuming the pixel is not fully covered) will be sampled somewhere within the covered area of the pixel, possibly at one of the covered sample locations.</span></span> <span data-ttu-id="33943-182">Eine Beispielmaske (angegeben durch den Rasterizer-Zustand) wird vor der Schwerpunktberechnung angewendet.</span><span class="sxs-lookup"><span data-stu-id="33943-182">A sample mask (specified by the rasterizer state) is applied prior to centroid computation.</span></span> <span data-ttu-id="33943-183">Aus diesem Grund wird ein Beispiel außerhalb der Maske nicht als Schwerpunktposition verwendet.</span><span class="sxs-lookup"><span data-stu-id="33943-183">Therefore, a sample that is masked out will not be used as a centroid location.</span></span>

<span data-ttu-id="33943-184">Der Referenz-Rasterizer wählt eine Beispielposition für das Schwerpunkt-Sampling ähnlich wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="33943-184">The reference rasterizer chooses a sample location for centroid sampling similar to this:</span></span>

-   <span data-ttu-id="33943-185">Die Beispielmaske lässt alle Beispiele zu.</span><span class="sxs-lookup"><span data-stu-id="33943-185">The sample mask allows all samples.</span></span> <span data-ttu-id="33943-186">Verwenden Sie eine Pixelmitte, falls das Pixel abgedeckt ist oder falls keines der Beispiele abgedeckt ist.</span><span class="sxs-lookup"><span data-stu-id="33943-186">Use a pixel center if the pixel is covered or if none of the samples are covered.</span></span> <span data-ttu-id="33943-187">Andernfalls wird das erste abgedeckte Beispiel ausgewählt, beginnend in der Pixelmitte und von dort nach außen.</span><span class="sxs-lookup"><span data-stu-id="33943-187">Otherwise, the first covered sample is chosen, starting from the pixel center and moving outward.</span></span>
-   <span data-ttu-id="33943-188">Die Beispielmaske deaktiviert alle Beispiele außer eins (ein häufiges Szenario).</span><span class="sxs-lookup"><span data-stu-id="33943-188">The sample mask turns off all samples but one (a common scenario).</span></span> <span data-ttu-id="33943-189">Eine Anwendung kann Multipass-Supersampling durch Durchlaufen von Einzelbit-Beispielmaskenwerte und erneutes Rendern der Szene für jedes Beispiel mithilfe des Schwerpunkt-Samplings implementieren.</span><span class="sxs-lookup"><span data-stu-id="33943-189">An application can implement multipass supersampling by cycling through single-bit sample-mask values and re-rendering the scene for each sample using centroid sampling.</span></span> <span data-ttu-id="33943-190">Dies würde erfordern, dass eine Anwendung Ableitungen anpasst, um entsprechend detailliertere Textur-Mips für die höhere Textur-Samplingdichte auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="33943-190">This would require that an application adjust derivatives to select appropriately more detailed texture mips for the higher texture sampling density.</span></span>

### <a name="span-idderivativecalculationsspanspan-idderivativecalculationsspanspan-idderivativecalculationsspanderivative-calculations-when-multisampling"></a><span data-ttu-id="33943-191"><span id="Derivative_Calculations"></span><span id="derivative_calculations"></span><span id="DERIVATIVE_CALCULATIONS"></span>Abgeleitete Berechnungen beim Multisampling</span><span class="sxs-lookup"><span data-stu-id="33943-191"><span id="Derivative_Calculations"></span><span id="derivative_calculations"></span><span id="DERIVATIVE_CALCULATIONS"></span>Derivative Calculations When Multisampling</span></span>

<span data-ttu-id="33943-192">Pixel-Shader werden immer mindestens mithilfe eines 2x2-Pixelbereichs ausgeführt, um abgeleitete Berechnungen zu unterstützen, die mit Deltas zwischen Daten aus benachbarten Pixeln berechnet werden (unter der Annahme, dass die Daten in jedem Pixel mit horizontalem oder vertikalem Einheitenabstand gesampelt wurden).</span><span class="sxs-lookup"><span data-stu-id="33943-192">Pixel shaders always run using a minimum 2x2 pixel area to support derivative calculations, which are calculated by taking deltas between data from adjacent pixels (making the assumption that the data in each pixel has been sampled with unit spacing horizontally or vertically).</span></span> <span data-ttu-id="33943-193">Multisampling hat darauf keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="33943-193">This is unaffected by multisampling.</span></span>

<span data-ttu-id="33943-194">Wenn Ableitungen für ein Attribut angefordert werden, das mir Schwerpunkt gesampelt wurde, wird die Berechnung der Hardware nicht angepasst, was zu ungenauen Ableitungen führen kann.</span><span class="sxs-lookup"><span data-stu-id="33943-194">If derivatives are requested on an attribute that has been centroid sampled, the hardware calculation is not adjusted, which can cause inaccurate derivatives.</span></span> <span data-ttu-id="33943-195">Ein Shader erwartet einen Einheitenvektor im Renderzielraum, erhält jedoch unter Umständen einen Vektor ohne Einheit mit Bezug auf einen anderen Vektorraum.</span><span class="sxs-lookup"><span data-stu-id="33943-195">A shader will expect a unit vector in render-target space but may get a non-unit vector with respect to some other vector space.</span></span> <span data-ttu-id="33943-196">Daher liegt es in der Verantwortung der Anwendung, Vorsicht walten zu lassen, wenn Ableitungen von Attributen angefordert werden, die mit Schwerpunkt gesampelt werden.</span><span class="sxs-lookup"><span data-stu-id="33943-196">Therefore, it is an application's responsibility to exhibit caution when requesting derivatives from attributes that are centroid sampled.</span></span>

<span data-ttu-id="33943-197">Tatsächlich empfiehlt es sich, Ableitungen und Schwerpunkt-Sampling nicht miteinander zu kombinieren.</span><span class="sxs-lookup"><span data-stu-id="33943-197">In fact, it is recommended that you do not combine derivatives and centroid sampling.</span></span> <span data-ttu-id="33943-198">Schwerpunkt-Sampling ist in Situationen hilfreich, in denen es wichtig ist, das interpolierte Attribute eines Grundtyps nicht extrapoliert werden, was aber Nachteile mit sich bringt, z.B. dass Attribute anscheinend springen, wenn der Rand eines Grundtyps einen Pixel kreuzt (anstatt sich kontinuierlich zu ändern) oder dass Ableitungen nicht von Textur-Sampling-Vorgängen verwendet werden können, die LOD ableiten.</span><span class="sxs-lookup"><span data-stu-id="33943-198">Centroid sampling can be useful for situations where it is critical that a primitive's interpolated attributes are not extrapolated, but this comes with tradeoffs such as attributes that appear to jump where a primitive edge crosses a pixel (rather than change continuously) or derivatives that cannot be used by texture sampling operations that derive LOD.</span></span>

## <a name="span-idrelated-topicsspanrelated-topics"></a><span data-ttu-id="33943-199"><span id="related-topics"></span>Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="33943-199"><span id="related-topics"></span>Related topics</span></span>


[<span data-ttu-id="33943-200">Anhänge</span><span class="sxs-lookup"><span data-stu-id="33943-200">Appendices</span></span>](appendix.md)

[<span data-ttu-id="33943-201">Rasterizerphase (RS)</span><span class="sxs-lookup"><span data-stu-id="33943-201">Rasterizer (RS) stage</span></span>](rasterizer-stage--rs-.md)

 

 




