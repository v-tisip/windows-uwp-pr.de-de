---
title: Erstellen von Komponenten für Windows-Runtime in C# und Visual Basic
description: Ab .NET Framework4.5 können Sie mit verwaltetem Code eigene Windows-Runtime-Typen erstellen, die in einer Komponente für Windows-Runtime gepackt sind.
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.date: 02/08/2017
ms.topic: article
keywords: Windows10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 52745a4fcd6b5a6b33982595f8c7c65c0bee3c32
ms.sourcegitcommit: b11f305dbf7649c4b68550b666487c77ea30d98f
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/28/2018
ms.locfileid: "7842313"
---
# <a name="creating-windows-runtime-components-in-c-and-visual-basic"></a><span data-ttu-id="d9945-104">Erstellen von Komponenten für Windows-Runtime in C# und Visual Basic</span><span class="sxs-lookup"><span data-stu-id="d9945-104">Creating Windows Runtime Components in C# and Visual Basic</span></span>
<span data-ttu-id="d9945-105">Ab .NET Framework4.5 können Sie mit verwaltetem Code eigene Windows-Runtime-Typen erstellen, die in einer Komponente für Windows-Runtime gepackt sind.</span><span class="sxs-lookup"><span data-stu-id="d9945-105">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</span></span> <span data-ttu-id="d9945-106">Diese Komponente können Sie in UWP-Apps (Universelle Windows-Plattform) mit C++, JavaScript, Visual Basic oder C# verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-106">You can use your component in Universal Windows Platform (UWP) apps with C++, JavaScript, Visual Basic, or C#.</span></span> <span data-ttu-id="d9945-107">In diesem Thema wird beschrieben, die Regeln zum Erstellen einer Komponente, und einige Aspekte der .NET Framework-Unterstützung für die Windows-Runtime erläutert.</span><span class="sxs-lookup"><span data-stu-id="d9945-107">This topic outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</span></span> <span data-ttu-id="d9945-108">Im Allgemeinen ist diese Unterstützung allen .NET Framework-Programmierern klar.</span><span class="sxs-lookup"><span data-stu-id="d9945-108">In general, that support is designed to be transparent to the .NET Framework programmer.</span></span> <span data-ttu-id="d9945-109">Wenn Sie aber eine Komponente erstellen, die mit JavaScript oder C++ verwendet werden soll, müssen Sie auf die Unterschiede bei der Unterstützung der Windows-Runtime durch diese Sprachen achten.</span><span class="sxs-lookup"><span data-stu-id="d9945-109">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</span></span>

<span data-ttu-id="d9945-110">Wenn Sie eine Komponente nur für die Verwendung in UWP-Apps mit Visual Basic oder C# erstellen und die Komponente keine UWP-Steuerelemente enthält, sollten Sie die Verwendung der Vorlage **Klassenbibliothek** anstelle der Vorlage **Komponente für Windows-Runtime** in Betracht ziehen.</span><span class="sxs-lookup"><span data-stu-id="d9945-110">If you are creating a component for use only in UWP apps with Visual Basic or C#, and the component does not contain UWP controls, consider using the **Class Library** template instead of the **Windows Runtime Component** template.</span></span> <span data-ttu-id="d9945-111">Eine einfache Klassenbibliothek weist weniger Einschränkungen auf.</span><span class="sxs-lookup"><span data-stu-id="d9945-111">There are fewer restrictions on a simple class library.</span></span>

<span data-ttu-id="d9945-112">Dieses Thema enthält die folgenden Abschnitte:</span><span class="sxs-lookup"><span data-stu-id="d9945-112">This topic contains the following sections:</span></span>

## <a name="declaring-types-in-windows-runtime-components"></a><span data-ttu-id="d9945-113">Deklarieren von Typen in Komponenten für Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="d9945-113">Declaring types in Windows Runtime Components</span></span>
<span data-ttu-id="d9945-114">Intern können die Windows-Runtime-Typen in Ihrer Komponente alle .NET Framework-Funktionen verwenden, die in einer universellen Windows-App zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="d9945-114">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a Universal Windows app.</span></span> <span data-ttu-id="d9945-115">(Weitere Informationen finden Sie unter [.NET für UWP-Apps](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx).) Extern können die Member Ihrer Typen nur Windows-Runtime-Typen für ihre Parameter und Rückgabewerte verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="d9945-115">(See [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx) overview for more information.) Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</span></span> <span data-ttu-id="d9945-116">In der folgenden Liste sind die Einschränkungen für .NET Framework-Typen aufgeführt, die von Komponenten für Windows-Runtime verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-116">The following list describes the limitations on .NET Framework types that are exposed from Windows Runtime Components.</span></span>

-   <span data-ttu-id="d9945-117">Die Felder, Parameter und Rückgabewerte aller öffentlichen Typen und Member in der Komponente müssen Windows-Runtime-Typen sein.</span><span class="sxs-lookup"><span data-stu-id="d9945-117">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</span></span>

    <span data-ttu-id="d9945-118">Diese Einschränkung betrifft die von Ihnen erstellten Windows-Runtime-Typen und die Typen, die von der Windows-Runtime bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-118">This restriction includes the Windows Runtime types that you create as well as types that are provided by the Windows Runtime itself.</span></span> <span data-ttu-id="d9945-119">Außerdem trifft sie auf einige .NET Framework-Typen zu.</span><span class="sxs-lookup"><span data-stu-id="d9945-119">It also includes a number of .NET Framework types.</span></span> <span data-ttu-id="d9945-120">Die Aufnahme dieser Typen ist Teil der Unterstützung, die das .NET Framework bietet, um die natürliche Verwendung der Windows-Runtime in verwaltetem Code zu ermöglichen: Es scheint, als verwende der Code bekannte .NET Framework-Typen anstelle der zugrunde liegenden Windows-Runtime-Typen.</span><span class="sxs-lookup"><span data-stu-id="d9945-120">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code: Your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</span></span> <span data-ttu-id="d9945-121">Beispielsweise können Sie primitive .NET Framework-Typen wie Int32 und Double, bestimmte grundlegende Typen wie DateTimeOffset und Uri sowie einige häufig verwendete generische Schnittstellentypen wie IEnumerable&lt;T&gt; (IEnumerable(Of T) in Visual Basic) und IDictionary&lt;TKey,TValue&gt; verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-121">For example, you can use .NET Framework primitive types such as Int32 and Double, certain fundamental types such as DateTimeOffset and Uri, and some commonly used generic interface types such as IEnumerable&lt;T&gt; (IEnumerable(Of T) in Visual Basic) and IDictionary&lt;TKey,TValue&gt;.</span></span> <span data-ttu-id="d9945-122">(Beachten Sie, dass die Typargumente dieser generischen Typen Windows-Runtime-Typen sein müssen.) Dies wird in den Abschnitten übergeben von Windows-Runtime-Typen an verwalteten Code und übergeben von verwalteten Typen an die Windows-Runtime, später in diesem Thema.</span><span class="sxs-lookup"><span data-stu-id="d9945-122">(Note that the type arguments of these generic types must be Windows Runtime types.) This is discussed in the sections Passing Windows Runtime types to managed code and Passing managed types to the Windows Runtime, later in this topic.</span></span>

-   <span data-ttu-id="d9945-123">Öffentliche Klassen und Schnittstellen können Methoden, Eigenschaften und Ereignisse enthalten.</span><span class="sxs-lookup"><span data-stu-id="d9945-123">Public classes and interfaces can contain methods, properties, and events.</span></span> <span data-ttu-id="d9945-124">Sie können Delegaten für Ereignisse deklarieren oder den EventHandler&lt;T&gt;-Delegaten verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-124">You can declare delegates for your events, or use the EventHandler&lt;T&gt; delegate.</span></span> <span data-ttu-id="d9945-125">Eine öffentliche Klasse oder Schnittstelle kann nicht:</span><span class="sxs-lookup"><span data-stu-id="d9945-125">A public class or interface cannot:</span></span>

    -   <span data-ttu-id="d9945-126">generisch sein.</span><span class="sxs-lookup"><span data-stu-id="d9945-126">Be generic.</span></span>
    -   <span data-ttu-id="d9945-127">eine Schnittstelle implementieren, die keine Windows-Runtime-Schnittstelle ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-127">Implement an interface that is not a Windows Runtime interface.</span></span> <span data-ttu-id="d9945-128">(Sie können aber eigene Windows-Runtime-Schnittstellen erstellen und implementieren.)</span><span class="sxs-lookup"><span data-stu-id="d9945-128">(However, you can create your own Windows Runtime interfaces and implement them.)</span></span>
    -   <span data-ttu-id="d9945-129">von Typen abgeleitet sein, die nicht in der Windows-Runtime vorkommen, wie System.Exception und System.EventArgs.</span><span class="sxs-lookup"><span data-stu-id="d9945-129">Derive from types that are not in the Windows Runtime, such as System.Exception and System.EventArgs.</span></span>
-   <span data-ttu-id="d9945-130">Alle öffentliche Typen müssen über einen Stammnamespace verfügen, der mit dem Assemblynamen übereinstimmt, und der Assemblyname darf nicht mit „Windows” beginnen.</span><span class="sxs-lookup"><span data-stu-id="d9945-130">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</span></span>

    > <span data-ttu-id="d9945-131">**Tipp:** standardmäßig verfügen Visual Studio-Projekten den Assemblynamen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="d9945-131">**Tip**By default, Visual Studio projects have namespace names that match the assembly name.</span></span> <span data-ttu-id="d9945-132">In Visual Basic wird die Namespace-Anweisung für diesen Standardnamespace nicht im Code angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d9945-132">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</span></span>

-   <span data-ttu-id="d9945-133">Öffentliche Strukturen können nur öffentliche Felder als Member enthalten, und diese Felder müssen Werttypen oder Zeichenfolgen sein.</span><span class="sxs-lookup"><span data-stu-id="d9945-133">Public structures can't have any members other than public fields, and those fields must be value types or strings.</span></span>
-   <span data-ttu-id="d9945-134">Öffentliche Klassen müssen **versiegelt** (**NotInheritable** in Visual Basic) sein.</span><span class="sxs-lookup"><span data-stu-id="d9945-134">Public classes must be **sealed** (**NotInheritable** in Visual Basic).</span></span> <span data-ttu-id="d9945-135">Wenn das Programmiermodell Polymorphie erfordert, können Sie eine öffentliche Schnittstelle erstellen und diese in den Klassen implementieren, die polymorph sein müssen.</span><span class="sxs-lookup"><span data-stu-id="d9945-135">If your programming model requires polymorphism, you can create a public interface and implement that interface on the classes that must be polymorphic.</span></span>

## <a name="debugging-your-component"></a><span data-ttu-id="d9945-136">Debuggen der Komponente</span><span class="sxs-lookup"><span data-stu-id="d9945-136">Debugging your component</span></span>
<span data-ttu-id="d9945-137">Wenn Ihre universelle Windows-App und Ihre Komponente mit verwaltetem Code erstellt wurden, können Sie sie gleichzeitig debuggen.</span><span class="sxs-lookup"><span data-stu-id="d9945-137">If both your Universal Windows app and your component are built with managed code, you can debug them at the same time.</span></span>

<span data-ttu-id="d9945-138">Wenn Sie Ihre Komponente als Teil einer universellen Windows-App mit C++ testen, können Sie verwalteten und systemeigenen Code gleichzeitig debuggen.</span><span class="sxs-lookup"><span data-stu-id="d9945-138">When you're testing your component as part of a Universal Windows app using C++, you can debug managed and native code at the same time.</span></span> <span data-ttu-id="d9945-139">Die Vorgabe ist nur systemeigener Code.</span><span class="sxs-lookup"><span data-stu-id="d9945-139">The default is native code only.</span></span>

## **<a name="to-debug-both-native-c-code-and-managed-code"></a><span data-ttu-id="d9945-140">So debuggen Sie systemeigenen C++-Code und verwalteten Code</span><span class="sxs-lookup"><span data-stu-id="d9945-140">To debug both native C++ code and managed code</span></span>**
1.  <span data-ttu-id="d9945-141">Öffnen Sie das Kontextmenü für das Visual C++-Projekt, und wählen Sie **Eigenschaften** aus.</span><span class="sxs-lookup"><span data-stu-id="d9945-141">Open the shortcut menu for your Visual C++ project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="d9945-142">Wählen Sie auf den Eigenschaftenseiten unter **Konfigurationseigenschaften** die Option **Debuggen** aus.</span><span class="sxs-lookup"><span data-stu-id="d9945-142">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="d9945-143">Wählen Sie **Debuggertyp** aus, und ändern Sie dann in der Dropdownliste **Nur systemeigen** in **Gemischt (verwaltet und systemeigen)**.</span><span class="sxs-lookup"><span data-stu-id="d9945-143">Choose **Debugger Type**, and in the drop-down list box change **Native Only** to **Mixed (Managed and Native)**.</span></span> <span data-ttu-id="d9945-144">Klicken Sie auf **OK**.</span><span class="sxs-lookup"><span data-stu-id="d9945-144">Choose **OK**.</span></span>
4.  <span data-ttu-id="d9945-145">Legen Sie Haltepunkte im systemeigenen und verwalteten Code fest.</span><span class="sxs-lookup"><span data-stu-id="d9945-145">Set breakpoints in native and managed code.</span></span>

<span data-ttu-id="d9945-146">Wenn Sie die Komponenten als Teil einer universellen Windows-App mit JavaScript testen, befindet sich die Projektmappe standardmäßig im JavaScript-Debugmodus.</span><span class="sxs-lookup"><span data-stu-id="d9945-146">When you're testing your component as part of a Universal Windows app using JavaScript, by default the solution is in JavaScript debugging mode.</span></span> <span data-ttu-id="d9945-147">In Visual Studio ist das gleichzeitige Debuggen von JavaScript und verwaltetem Code nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="d9945-147">In Visual Studio, you can't debug JavaScript and managed code at the same time.</span></span>

## **<a name="to-debug-managed-code-instead-of-javascript"></a><span data-ttu-id="d9945-148">So debuggen Sie verwalteten Code anstelle von JavaScript</span><span class="sxs-lookup"><span data-stu-id="d9945-148">To debug managed code instead of JavaScript</span></span>**
1.  <span data-ttu-id="d9945-149">Öffnen Sie das Kontextmenü für das JavaScript-Projekt, und wählen Sie **Eigenschaften** aus.</span><span class="sxs-lookup"><span data-stu-id="d9945-149">Open the shortcut menu for your JavaScript project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="d9945-150">Wählen Sie auf den Eigenschaftenseiten unter **Konfigurationseigenschaften** die Option **Debuggen** aus.</span><span class="sxs-lookup"><span data-stu-id="d9945-150">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="d9945-151">Wählen Sie **Debuggertyp** aus, und ändern Sie in der Dropdownliste **Nur Skript** in **Nur verwaltet**.</span><span class="sxs-lookup"><span data-stu-id="d9945-151">Choose **Debugger Type**, and in the drop-down list box change **Script Only** to **Managed Only**.</span></span> <span data-ttu-id="d9945-152">Klicken Sie auf **OK**.</span><span class="sxs-lookup"><span data-stu-id="d9945-152">Choose **OK**.</span></span>
4.  <span data-ttu-id="d9945-153">Legen Sie Haltepunkte im verwaltetem Code fest, und debuggen Sie wie gewohnt.</span><span class="sxs-lookup"><span data-stu-id="d9945-153">Set breakpoints in managed code and debug as usual.</span></span>

## <a name="passing-windows-runtime-types-to-managed-code"></a><span data-ttu-id="d9945-154">Übergeben von Windows-Runtime Typen an verwalteten Code</span><span class="sxs-lookup"><span data-stu-id="d9945-154">Passing Windows Runtime types to managed code</span></span>
<span data-ttu-id="d9945-155">Wie bereits im Abschnitt „Deklarieren von Typen in Komponenten für Windows-Runtime” erwähnt, können bestimmte .NET Framework-Typen in den Signaturen von Membern öffentlicher Klassen erscheinen.</span><span class="sxs-lookup"><span data-stu-id="d9945-155">As mentioned previously in the section Declaring types in Windows Runtime Components, certain .NET Framework types can appear in the signatures of members of public classes.</span></span> <span data-ttu-id="d9945-156">Dies ist Teil der Unterstützung, die .NET Framework bietet, um die natürliche Verwendung der Windows-Runtime in verwaltetem Code zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="d9945-156">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</span></span> <span data-ttu-id="d9945-157">Darin sind primitive Typen und einige Klassen und Schnittstellen enthalten.</span><span class="sxs-lookup"><span data-stu-id="d9945-157">It includes primitive types and some classes and interfaces.</span></span> <span data-ttu-id="d9945-158">Wenn eine Komponente von JavaScript oder C++-Code verwendet wird, müssen Sie wissen, wie die .NET Framework-Typen für den Aufrufer angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-158">When your component is used from JavaScript or from C++ code, it's important to know how your .NET Framework types appear to the caller.</span></span> <span data-ttu-id="d9945-159">Beispiele mit JavaScript finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="d9945-159">See [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) for examples with JavaScript.</span></span> <span data-ttu-id="d9945-160">In diesem Abschnitt werden häufig verwendete Typen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="d9945-160">This section discusses commonly used types.</span></span>

<span data-ttu-id="d9945-161">Im .NET Framework haben primitive Typen wie die Int32-Struktur viele nützliche Eigenschaften und Methoden, z.B. die TryParse-Methode.</span><span class="sxs-lookup"><span data-stu-id="d9945-161">In the .NET Framework, primitive types like the Int32 structure have many useful properties and methods, such as the TryParse method.</span></span> <span data-ttu-id="d9945-162">Im Gegensatz dazu haben primitive Typen und Strukturen in der Windows-Runtime nur Felder.</span><span class="sxs-lookup"><span data-stu-id="d9945-162">By contrast, primitive types and structures in the Windows Runtime only have fields.</span></span> <span data-ttu-id="d9945-163">Wenn Sie diese Typen an verwalteten Code übergeben, verhalten sie sich wie .NET Framework-Typen, und Sie können die Eigenschaften und Methoden der .NET Framework-Typen wie gewohnt verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-163">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</span></span> <span data-ttu-id="d9945-164">Die folgende Liste fasst die Ersetzungen zusammen, die automatisch in der IDE vorgenommen werden:</span><span class="sxs-lookup"><span data-stu-id="d9945-164">The following list summarizes the substitutions that are made automatically in the IDE:</span></span>

-   <span data-ttu-id="d9945-165">Verwenden Sie für die primitiven Windows-Runtime Int32, Int64, Single, Double, Boolean, String (eine unveränderliche Sammlung von Unicode-Zeichen), Enum, UInt32, UInt64 und Guid den Typ mit dem gleichen Namen im System-Namespace.</span><span class="sxs-lookup"><span data-stu-id="d9945-165">For the Windows Runtime primitives Int32, Int64, Single, Double, Boolean, String (an immutable collection of Unicode characters), Enum, UInt32, UInt64, and Guid, use the type of the same name in the System namespace.</span></span>
-   <span data-ttu-id="d9945-166">Verwenden Sie für UInt8 den Typ System.Byte.</span><span class="sxs-lookup"><span data-stu-id="d9945-166">For UInt8, use System.Byte.</span></span>
-   <span data-ttu-id="d9945-167">Verwenden Sie für Char16 den Typ System.Char.</span><span class="sxs-lookup"><span data-stu-id="d9945-167">For Char16, use System.Char.</span></span>
-   <span data-ttu-id="d9945-168">Verwenden Sie für die IInspectable-Schnittstelle System.Object.</span><span class="sxs-lookup"><span data-stu-id="d9945-168">For the IInspectable interface, use System.Object.</span></span>

<span data-ttu-id="d9945-169">Wenn C# oder Visual Basic ein Schlüsselwort für einen dieser Typen bereitstellt, können Sie stattdessen das Schlüsselwort verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-169">If C# or Visual Basic provides a language keyword for any of these types, you can use the language keyword instead.</span></span>

<span data-ttu-id="d9945-170">Zusätzlich zu primitiven Typen erscheinen einige grundlegende, häufig verwendete Windows-Runtime-Typen in verwaltetem Code als ihre .NET Framework-Entsprechung.</span><span class="sxs-lookup"><span data-stu-id="d9945-170">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</span></span> <span data-ttu-id="d9945-171">Wenn Ihr JavaScript-Code beispielsweise die Windows.Foundation.Uri-Klasse verwendet und Sie diese einer C#- oder Visual Basic-Methode übergeben möchten,</span><span class="sxs-lookup"><span data-stu-id="d9945-171">For example, suppose your JavaScript code uses the Windows.Foundation.Uri class, and you want to pass it to a C# or Visual Basic method.</span></span> <span data-ttu-id="d9945-172">entspricht der Typ im verwalteten Code der .NET Framework-Klasse System.Uri und das ist der Typ für den Methodenparameter.</span><span class="sxs-lookup"><span data-stu-id="d9945-172">The equivalent type in managed code is the .NET Framework System.Uri class, and that's the type to use for the method parameter.</span></span> <span data-ttu-id="d9945-173">Sie können feststellen, wann ein Windows-Runtime-Typ als .NET Framework-Typ erscheint, da IntelliSense in Visual Studio den Windows-Runtime-Typ ausblendet, wenn Sie verwalteten Code schreiben und den entsprechenden .NET Framework-Typ anzeigt.</span><span class="sxs-lookup"><span data-stu-id="d9945-173">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</span></span> <span data-ttu-id="d9945-174">(In der Regel haben beiden Typen den gleichen Namen.</span><span class="sxs-lookup"><span data-stu-id="d9945-174">(Usually the two types have the same name.</span></span> <span data-ttu-id="d9945-175">Beachten Sie jedoch, dass die Windows.Foundation.DateTime-Struktur in verwaltetem Code als System.DateTimeOffset und nicht als System.DateTime angezeigt wird.)</span><span class="sxs-lookup"><span data-stu-id="d9945-175">However, note that the Windows.Foundation.DateTime structure appears in managed code as System.DateTimeOffset and not as System.DateTime.)</span></span>

<span data-ttu-id="d9945-176">Für einige häufig verwendete Sammlungstypen erfolgt die Zuordnung zwischen den Schnittstellen, die von einem Windows-Runtime-Typ implementiert werden, und den Schnittstellen, die vom entsprechenden .NET Framework-Typ implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-176">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</span></span> <span data-ttu-id="d9945-177">Wie bei den bereits erwähnten Typen deklarieren Sie Parametertypen, indem Sie den .NET Framework-Typ verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-177">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</span></span> <span data-ttu-id="d9945-178">Dadurch werden bestimmte Unterschiede zwischen den Typen ausgeblendet, und das Schreiben von .NET Framework-Code wirkt natürlicher.</span><span class="sxs-lookup"><span data-stu-id="d9945-178">This hides some differences between the types and makes writing .NET Framework code more natural.</span></span> <span data-ttu-id="d9945-179">In der folgenden Tabelle sind die häufigsten dieser generischen Schnittstellentypen zusammen mit anderen allgemeinen Klassen- und Schnittstellenzuordnungen aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="d9945-179">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</span></span> <span data-ttu-id="d9945-180">Eine vollständige Liste der Windows-Runtime-Typen, die das .NET Framework zuordnet, finden Sie unter „.NET Framework-Zuordnungen von Windows-Runtime-Typen”.</span><span class="sxs-lookup"><span data-stu-id="d9945-180">For a complete list of Windows Runtime types that the .NET Framework maps, see .NET Framework mappings of Windows Runtime types.</span></span>

| <span data-ttu-id="d9945-181">Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="d9945-181">Windows Runtime</span></span>                                  | <span data-ttu-id="d9945-182">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="d9945-182">.NET Framework</span></span>                                    |
|--------------------------------------------------|---------------------------------------------------|
| <span data-ttu-id="d9945-183">IIterable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-183">IIterable&lt;T&gt;</span></span>                               | <span data-ttu-id="d9945-184">IEnumerable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-184">IEnumerable&lt;T&gt;</span></span>                              |
| <span data-ttu-id="d9945-185">IVector&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-185">IVector&lt;T&gt;</span></span>                                 | <span data-ttu-id="d9945-186">IList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-186">IList&lt;T&gt;</span></span>                                    |
| <span data-ttu-id="d9945-187">IVectorView&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-187">IVectorView&lt;T&gt;</span></span>                             | <span data-ttu-id="d9945-188">IReadOnlyList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-188">IReadOnlyList&lt;T&gt;</span></span>                            |
| <span data-ttu-id="d9945-189">IMap&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-189">IMap&lt;K, V&gt;</span></span>                                 | <span data-ttu-id="d9945-190">IDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-190">IDictionary&lt;TKey, TValue&gt;</span></span>                   |
| <span data-ttu-id="d9945-191">IMapView&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-191">IMapView&lt;K, V&gt;</span></span>                             | <span data-ttu-id="d9945-192">IReadOnlyDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-192">IReadOnlyDictionary&lt;TKey, TValue&gt;</span></span>           |
| <span data-ttu-id="d9945-193">IKeyValuePair&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-193">IKeyValuePair&lt;K, V&gt;</span></span>                        | <span data-ttu-id="d9945-194">KeyValuePair&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="d9945-194">KeyValuePair&lt;TKey, TValue&gt;</span></span>                  |
| <span data-ttu-id="d9945-195">IBindableIterable</span><span class="sxs-lookup"><span data-stu-id="d9945-195">IBindableIterable</span></span>                                | <span data-ttu-id="d9945-196">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="d9945-196">IEnumerable</span></span>                                       |
| <span data-ttu-id="d9945-197">IBindableVecinr</span><span class="sxs-lookup"><span data-stu-id="d9945-197">IBindableVector</span></span>                                  | <span data-ttu-id="d9945-198">IList</span><span class="sxs-lookup"><span data-stu-id="d9945-198">IList</span></span>                                             |
| <span data-ttu-id="d9945-199">Windows.UI.Xaml.Data.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="d9945-199">Windows.UI.Xaml.Data.INotifyPropertyChanged</span></span>      | <span data-ttu-id="d9945-200">System.ComponentModel.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="d9945-200">System.ComponentModel.INotifyPropertyChanged</span></span>      |
| <span data-ttu-id="d9945-201">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="d9945-201">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span></span> | <span data-ttu-id="d9945-202">System.ComponentModel.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="d9945-202">System.ComponentModel.PropertyChangedEventHandler</span></span> |
| <span data-ttu-id="d9945-203">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="d9945-203">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span></span>    | <span data-ttu-id="d9945-204">System.ComponentModel.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="d9945-204">System.ComponentModel.PropertyChangedEventArgs</span></span>    |

<span data-ttu-id="d9945-205">Wenn ein Typ mehrere Schnittstellen implementiert, können Sie jede Schnittstelle verwenden, die als Parametertyp oder Rückgabetyp eines Members implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="d9945-205">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</span></span> <span data-ttu-id="d9945-206">Sie können z. B. übergeben oder zurückgeben ein Wörterbuch&lt;Int, String&gt; (Dictionary (Of Integer, String) in Visual Basic) als IDictionary&lt;Int, String&gt;, IReadOnlyDictionary&lt;Int, String&gt;, oder IEnumerable&lt; System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.</span><span class="sxs-lookup"><span data-stu-id="d9945-206">For example, you can pass or return a Dictionary&lt;int, string&gt; (Dictionary(Of Integer, String) in Visual Basic) as IDictionary&lt;int, string&gt;, IReadOnlyDictionary&lt;int, string&gt;, or IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.</span></span>

<span data-ttu-id="d9945-207">**Wichtige**JavaScript verwendet die Schnittstelle, die zuerst in der Liste der Schnittstellen angezeigt wird, die ein verwalteter Typ implementiert.</span><span class="sxs-lookup"><span data-stu-id="d9945-207">**Important**JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</span></span> <span data-ttu-id="d9945-208">Wenn Sie beispielsweise Dictionary&lt;int, string&gt; an JavaScript-Code zurückgeben, wird IDictionary&lt;int, string&gt; angezeigt, unabhängig davon, welche Schnittstelle Sie als Rückgabetyp angeben.</span><span class="sxs-lookup"><span data-stu-id="d9945-208">For example, if you return Dictionary&lt;int, string&gt; to JavaScript code, it appears as IDictionary&lt;int, string&gt; no matter which interface you specify as the return type.</span></span> <span data-ttu-id="d9945-209">Das bedeutet, dass die erste Schnittstelle Member enthalten muss, die in den nächsten Schnittstellen erscheinen, damit diese Member für JavaScript sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="d9945-209">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</span></span>

<span data-ttu-id="d9945-210">In der Windows-Runtime werden IMap&lt;K, V&gt; und IMapView&lt;K, V&gt; mit IKeyValuePair durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="d9945-210">In the Windows Runtime, IMap&lt;K, V&gt; and IMapView&lt;K, V&gt; are iterated by using IKeyValuePair.</span></span> <span data-ttu-id="d9945-211">Wenn Sie diese Schnittstellen an verwalteten Code übergeben, werden sie als IDictionary&lt;TKey, TValue&gt; und IReadOnlyDictionary&lt;TKey, TValue&gt; angezeigt. Daher können Sie sie mit System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt; auflisten.</span><span class="sxs-lookup"><span data-stu-id="d9945-211">When you pass them to managed code, they appear as IDictionary&lt;TKey, TValue&gt; and IReadOnlyDictionary&lt;TKey, TValue&gt;, so naturally you use System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt; to enumerate them.</span></span>

<span data-ttu-id="d9945-212">Die Darstellungsweise von Schnittstellen in verwaltetem Code wirkt sich auf die Darstellungsweise der Typen aus, die diese Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="d9945-212">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</span></span> <span data-ttu-id="d9945-213">Die PropertySet-Klasse implementiert z.B. den Typ IMap&lt;K, V&gt;, der in verwaltetem Code als IDictionary&lt;TKey, TValue&gt; erscheint.</span><span class="sxs-lookup"><span data-stu-id="d9945-213">For example, the PropertySet class implements IMap&lt;K, V&gt;, which appears in managed code as IDictionary&lt;TKey, TValue&gt;.</span></span> <span data-ttu-id="d9945-214">PropertySet wird angezeigt, als ob es IDictionary&lt;TKey, TValue&gt; anstelle von IMap&lt;K, V&gt; implementiert. In verwaltetem Code ist scheinbar eine Add-Methode vorhanden, die sich wie eine Add-Methode in .NET Framework-Wörterbüchern verhält.</span><span class="sxs-lookup"><span data-stu-id="d9945-214">PropertySet appears as if it implemented IDictionary&lt;TKey, TValue&gt; instead of IMap&lt;K, V&gt;, so in managed code it appears to have an Add method, which behaves like the Add method on .NET Framework dictionaries.</span></span> <span data-ttu-id="d9945-215">Eine Insert-Methode ist scheinbar nicht vorhanden.</span><span class="sxs-lookup"><span data-stu-id="d9945-215">It doesn't appear to have an Insert method.</span></span> <span data-ttu-id="d9945-216">Sie finden dieses Beispiel unter dem Thema [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in c# oder Visual Basic und Aufrufen der Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="d9945-216">You can see this example in the topic [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="passing-managed-types-to-the-windows-runtime"></a><span data-ttu-id="d9945-217">Übergeben von verwalteten Typen an die Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="d9945-217">Passing managed types to the Windows Runtime</span></span>
<span data-ttu-id="d9945-218">Wie bereits im vorherigen Abschnitt erwähnt, können einige Windows-Runtime-Typen als .NET Framework-Typen in den Signaturen von Komponentenmembern oder in den Signaturen von Windows-Runtime-Membern erscheinen, wenn Sie sie in der IDE verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-218">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</span></span> <span data-ttu-id="d9945-219">Wenn Sie .NET Framework-Typen an diese Member übergeben oder als Rückgabewerte von Komponentenmembern verwenden, werden sie dem Code auf der anderen Seite als der entsprechende Windows-Runtime-Typ dargestellt.</span><span class="sxs-lookup"><span data-stu-id="d9945-219">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</span></span> <span data-ttu-id="d9945-220">Sie finden einige Beispiele für die Auswirkungen beim Aufruf Ihrer Komponente in JavaScript im Abschnitt „Zurückgeben verwalteter Typen aus der Komponente” unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="d9945-220">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="overloaded-methods"></a><span data-ttu-id="d9945-221">Überladene Methoden</span><span class="sxs-lookup"><span data-stu-id="d9945-221">Overloaded methods</span></span>
<span data-ttu-id="d9945-222">In der Windows-Runtime können Methoden überladen werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-222">In the Windows Runtime, methods can be overloaded.</span></span> <span data-ttu-id="d9945-223">Wenn Sie aber mehrere Überladungen mit der gleichen Anzahl von Parametern deklarieren, müssen Sie das Attribut [Windows.Foundation.Metadata.DefaultOverloadAttribute](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) nur auf eine dieser Überladungen anwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-223">However, if you declare multiple overloads with the same number of parameters, you must apply the [Windows.Foundation.Metadata.DefaultOverloadAttribute](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx) attribute to only one of those overloads.</span></span> <span data-ttu-id="d9945-224">Nur diese Überladung kann aus JavaScript aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d9945-224">That overload is the only one you can call from JavaScript.</span></span> <span data-ttu-id="d9945-225">Im folgenden Code ist beispielsweise die Überladung, die **int** übernimmt (**Integer** in Visual Basic), die Standardüberladung.</span><span class="sxs-lookup"><span data-stu-id="d9945-225">For example, in the following code the overload that takes an **int** (**Integer** in Visual Basic) is the default overload.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public string OverloadExample(string s)
> {
>     return s;
> }
> [Windows.Foundation.Metadata.DefaultOverload()]
> public int OverloadExample(int x)
> {
>     return x;
> }
> ```
> ```vb
> Public Function OverloadExample(ByVal s As String) As String
>     Return s
> End Function
> <Windows.Foundation.Metadata.DefaultOverload> _
> Public Function OverloadExample(ByVal x As Integer) As Integer
>     Return x
> End Function
> ```

 <span data-ttu-id="d9945-226">**Achtung**JavaScript können Sie einen beliebigen Wert zu OverloadExample übergeben und wandelt den Wert in den Typ, der durch den Parameter erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-226">**Caution**JavaScript allows you to pass any value to OverloadExample, and coerces the value to the type that is required by the parameter.</span></span> <span data-ttu-id="d9945-227">Sie können OverloadExample mit „zweiundvierzig”, „42” oder „42,3” aufrufen. Alle diese Werte werden an die Standardüberladung übergeben.</span><span class="sxs-lookup"><span data-stu-id="d9945-227">You can call OverloadExample with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</span></span> <span data-ttu-id="d9945-228">Die Standardüberladung im vorherigen Beispiel gibt 0, 42 bzw. 42 zurück.</span><span class="sxs-lookup"><span data-stu-id="d9945-228">The default overload in the previous example returns 0, 42, and 42 respectively.</span></span>

<span data-ttu-id="d9945-229">Das DefaultOverloadAttribute-Attribut können Sie nicht für Konstruktoren verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-229">You cannot apply the DefaultOverloadAttribute attribute to constructors.</span></span> <span data-ttu-id="d9945-230">Alle Konstruktoren in einer Klasse müssen eine unterschiedliche Anzahl von Parametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d9945-230">All the constructors in a class must have different numbers of parameters.</span></span>

## <a name="implementing-istringable"></a><span data-ttu-id="d9945-231">Implementieren von IStringable</span><span class="sxs-lookup"><span data-stu-id="d9945-231">Implementing IStringable</span></span>
<span data-ttu-id="d9945-232">Ab Windows8.1 enthält die Windows-Runtime eine IStringable-Schnittstelle, deren einzige Methode, IStringable.ToString, eine grundlegende Formatierungsunterstützung bietet, die mit der von Object.ToString vergleichbar ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-232">Starting with Windows 8.1, the Windows Runtime includes an IStringable interface whose single method, IStringable.ToString, provides basic formatting support comparable to that provided by Object.ToString.</span></span> <span data-ttu-id="d9945-233">Wenn Sie IStringable in einem öffentlichen, verwalteten Typ implementieren möchten, der in eine Komponente für Windows-Runtime exportiert wird, gelten folgende Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="d9945-233">If you do choose to implement IStringable in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</span></span>

-   <span data-ttu-id="d9945-234">Sie können die IStringable-Schnittstelle nur in einer „class implements”-Beziehung definieren, also in C#-Code:</span><span class="sxs-lookup"><span data-stu-id="d9945-234">You can define the IStringable interface only in a "class implements" relationship, such as the following code in C#:</span></span>

    ```cs
    public class NewClass : IStringable
    ```

    <span data-ttu-id="d9945-235">Oder in Visual Basic-Code:</span><span class="sxs-lookup"><span data-stu-id="d9945-235">Or the following Visual Basic code:</span></span>

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="d9945-236">Sie können IStringable nicht in einer Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="d9945-236">You cannot implement IStringable on an interface.</span></span>
-   <span data-ttu-id="d9945-237">Sie können einen Parameter nicht als IStringable-Typ deklarieren.</span><span class="sxs-lookup"><span data-stu-id="d9945-237">You cannot declare a parameter to be of type IStringable.</span></span>
-   <span data-ttu-id="d9945-238">IStringable kann nicht der Rückgabetyp einer Methode, einer Eigenschaft oder eines Felds sein.</span><span class="sxs-lookup"><span data-stu-id="d9945-238">IStringable cannot be the return type of a method, property, or field.</span></span>
-   <span data-ttu-id="d9945-239">Sie können die IStringable-Implementierung nicht vor Basisklassen verbergen, indem Sie eine Methodendefinition wie die folgende verwenden:</span><span class="sxs-lookup"><span data-stu-id="d9945-239">You cannot hide your IStringable implementation from base classes by using a method definition such as the following:</span></span>

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    <span data-ttu-id="d9945-240">Stattdessen muss die IStringable.ToString-Implementierung immer die Implementierung der Basisklasse überschreiben.</span><span class="sxs-lookup"><span data-stu-id="d9945-240">Instead, the IStringable.ToString implementation must always override the base class implementation.</span></span> <span data-ttu-id="d9945-241">Sie können eine ToString-Implementierung nur verbergen, indem Sie sie für eine stark typisierte Klasseninstanz aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d9945-241">You can hide a ToString implementation only by invoking it on a strongly typed class instance.</span></span>

<span data-ttu-id="d9945-242">Unter bestimmten Bedingungen können Aufrufe eines verwalteten Typs, der IStringable implementiert oder seine ToString-Implementierung verbirgt, aus systemeigenem Code zu unerwartetem Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="d9945-242">Note that under a variety of conditions, calls from native code to a managed type that implements IStringable or hides its ToString implementation can produce unexpected behavior.</span></span>

## <a name="asynchronous-operations"></a><span data-ttu-id="d9945-243">Asynchrone Vorgänge</span><span class="sxs-lookup"><span data-stu-id="d9945-243">Asynchronous operations</span></span>
<span data-ttu-id="d9945-244">Um eine asynchrone Methode in Ihrer Komponente zu implementieren, fügen Sie am Ende des Methodennamens „Async“ hinzu und geben eine der Windows-Runtime-Schnittstellen zurück, die asynchrone Aktionen oder Vorgänge repräsentieren: IAsyncAction, IAsyncActionWithProgress&lt;TProgress&gt;, IAsyncOperation&lt;TResult&gt; oder IAsyncOperationWithProgress&lt;TResult, TProgress&gt;.</span><span class="sxs-lookup"><span data-stu-id="d9945-244">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: IAsyncAction, IAsyncActionWithProgress&lt;TProgress&gt;, IAsyncOperation&lt;TResult&gt;, or IAsyncOperationWithProgress&lt;TResult, TProgress&gt;.</span></span>

<span data-ttu-id="d9945-245">Sie können mit .NET Framework-Aufgaben (die [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx)-Klasse und die generische [Task&lt;TResult&gt;](https://msdn.microsoft.com/library/dd321424.aspx)-Klasse) eine asynchrone Methode implementieren.</span><span class="sxs-lookup"><span data-stu-id="d9945-245">You can use .NET Framework tasks (the [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) class and generic [Task&lt;TResult&gt;](https://msdn.microsoft.com/library/dd321424.aspx) class) to implement your asynchronous method.</span></span> <span data-ttu-id="d9945-246">Sie müssen eine Aufgabe zurückgeben, die einen laufenden Vorgang darstellt, wie z.B. eine Aufgabe, die von einer asynchronen Methode zurückgegeben wird, die in C# oder Visual Basic geschrieben wurde, oder eine Aufgabe, die von der [Task.Run](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx)-Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="d9945-246">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the [Task.Run](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx) method.</span></span> <span data-ttu-id="d9945-247">Wenn Sie für die Aufgabenerstellung einen Konstruktor verwenden, müssen Sie seine [Task.Start](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx)-Methode vor der Rückgabe aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d9945-247">If you use a constructor to create the task, you must call its [Task.Start](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx) method before returning it.</span></span>

<span data-ttu-id="d9945-248">Eine Methode, die „await” verwendet („Await” in Visual Basic) benötigt das Schlüsselwort **async** (**Async** in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d9945-248">A method that uses await (Await in Visual Basic) requires the **async** keyword (**Async** in Visual Basic).</span></span> <span data-ttu-id="d9945-249">Wenn Sie eine solche Methode aus einer Komponente für Windows-Runtime verfügbar machen, müssen Sie das Schlüsselwort **async** für den Delegaten verwenden, den Sie an die Run-Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="d9945-249">If you expose such a method from a Windows Runtime component, apply the **async** keyword to the delegate that you pass to the Run method.</span></span>

<span data-ttu-id="d9945-250">Für asynchrone Aktionen und Vorgänge, die weder die Abbruch- noch die Fortschrittsberichterstattung unterstützen, können Sie mit der Erweiterungsmethode [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) oder [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) die Aufgabe in die entsprechende Schnittstelle umschließen.</span><span class="sxs-lookup"><span data-stu-id="d9945-250">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) or [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) extension method to wrap the task in the appropriate interface.</span></span> <span data-ttu-id="d9945-251">Der folgende Code implementiert z.B. eine asynchrone Methode, indem mit der Task.Run&lt;TResult&gt;-Methode eine Aufgabe gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="d9945-251">For example, the following code implements an asynchronous method by using the Task.Run&lt;TResult&gt; method to start a task.</span></span> <span data-ttu-id="d9945-252">Die Erweiterungsmethode „AsAsyncOperation&lt;TResult&gt;“ gibt die Aufgabe als asynchronen Windows-Runtime-Vorgang zurück.</span><span class="sxs-lookup"><span data-stu-id="d9945-252">The AsAsyncOperation&lt;TResult&gt; extension method returns the task as a Windows Runtime asynchronous operation.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return Task.Run<IList<string>>(async () =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     }).AsAsyncOperation();
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>      As IAsyncOperation(Of IList(Of String))
>
>     Return Task.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function).AsAsyncOperation()
> End Function
> ```

<span data-ttu-id="d9945-253">Im folgenden JavaScript-Code wird gezeigt, wie die Methode mit einem [WinJS.Promise](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)-Objekt aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d9945-253">The following JavaScript code shows how the method could be called by using a [WinJS.Promise](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) object.</span></span> <span data-ttu-id="d9945-254">Die an die then-Methode übergebene Funktion wird ausgeführt, wenn der asynchrone Aufruf abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-254">The function that is passed to the then method is executed when the asynchronous call completes.</span></span> <span data-ttu-id="d9945-255">Der StringList-Parameter enthält die Liste der Zeichenfolgen, die von der DownloadAsStringAsync-Methode zurückgegeben wird. Die Funktion übernimmt die gewünschte Verarbeitung.</span><span class="sxs-lookup"><span data-stu-id="d9945-255">The stringList parameter contains the list of strings that is returned by the DownloadAsStringAsync method, and the function does whatever processing is required.</span></span>

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

<span data-ttu-id="d9945-256">Verwenden Sie für asynchrone Aktionen und Vorgänge, die die Abbruch- oder die Fortschrittsberichterstattung unterstützen, die [AsyncInfo](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx)-Klasse, um eine gestartete Aufgabe zu generieren und die Abbruch- und Fortschrittsberichterstattungsfunktionen der Aufgabe mit den Abbruch- und Fortschrittsberichterstattungsfunktionen der entsprechenden Windows-Runtime-Schnittstelle zu verknüpfen.</span><span class="sxs-lookup"><span data-stu-id="d9945-256">For asynchronous actions and operations that support cancellation or progress reporting, use the [AsyncInfo](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx) class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</span></span> <span data-ttu-id="d9945-257">Ein Beispiel, das sowohl die Abbruch- als auch die Fortschrittsberichterstattung unterstützt, finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="d9945-257">For an example that supports both cancellation and progress reporting, see [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

<span data-ttu-id="d9945-258">Sie können die Methoden der AsyncInfo-Klasse auch verwenden, wenn Ihre asynchrone Methode die Abbruch- oder Fortschrittsberichterstattung nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d9945-258">Note that you can use the methods of the AsyncInfo class even if your asynchronous method doesn't support cancellation or progress reporting.</span></span> <span data-ttu-id="d9945-259">Geben Sie keine Parameter für das Token und die [IProgress&lt;T&gt;](https://msdn.microsoft.com/library/hh138298.aspx)-Schnittstelle an, wenn Sie eine Visual Basic-Lambda-Funktion oder eine anonyme C#-Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-259">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and [IProgress&lt;T&gt;](https://msdn.microsoft.com/library/hh138298.aspx) interface.</span></span> <span data-ttu-id="d9945-260">Wenn Sie eine C#-Lambda-Funktion verwenden, geben Sie einen Tokenparameter an, aber ignorieren Sie ihn.</span><span class="sxs-lookup"><span data-stu-id="d9945-260">If you use a C# lambda function, supply a token parameter but ignore it.</span></span> <span data-ttu-id="d9945-261">Das vorherige Beispiel, in dem die asasyncoperation&lt;TResult&gt; -Methode, sieht wie folgt aus, bei der Verwendung der [AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779740.aspx))-Methode stattdessen die Überladung:</span><span class="sxs-lookup"><span data-stu-id="d9945-261">The previous example, which used the AsAsyncOperation&lt;TResult&gt; method, looks like this when you use the [AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;](https://msdn.microsoft.com/library/hh779740.aspx)) method overload instead:</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
> {
>     return AsyncInfo.Run<IList<string>>(async (token) =>
>     {
>         var data = await DownloadDataAsync(id);
>         return ExtractStrings(data);
>     });
> }
> ```
> ```vb
> Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
>     As IAsyncOperation(Of IList(Of String))
>
>     Return AsyncInfo.Run(Of IList(Of String))(
>         Async Function()
>             Dim data = Await DownloadDataAsync(id)
>             Return ExtractStrings(data)
>         End Function)
> End Function
> ```

<span data-ttu-id="d9945-262">Wenn Sie eine asynchrone Methode erstellen, die optional die Abbruch- oder Fortschrittsberichterstattung unterstützt, sollten Sie das Hinzufügen von Überladungen in Betracht ziehen, die keine Parameter für ein Abbruchtoken oder die IProgress&lt;T&gt;-Schnittstelle haben.</span><span class="sxs-lookup"><span data-stu-id="d9945-262">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the IProgress&lt;T&gt; interface.</span></span>

## <a name="throwing-exceptions"></a><span data-ttu-id="d9945-263">Auslösen von Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="d9945-263">Throwing exceptions</span></span>
<span data-ttu-id="d9945-264">Sie können jeden Ausnahmetyp auslösen, der in .NET für Windows-Apps enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-264">You can throw any exception type that is included in the .NET for Windows apps.</span></span> <span data-ttu-id="d9945-265">Sie können keine eigenen öffentlichen Ausnahmetypen in einer Komponente für Windows-Runtime deklarieren, aber Sie können nicht öffentliche Typen deklarieren und auslösen.</span><span class="sxs-lookup"><span data-stu-id="d9945-265">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</span></span>

<span data-ttu-id="d9945-266">Wenn die Komponente die Ausnahme nicht behandelt, wird eine entsprechende Ausnahme im Code ausgelöst, der die Komponente aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="d9945-266">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</span></span> <span data-ttu-id="d9945-267">Die Unterstützung der Windows-Runtime durch die aufrufende Sprache bestimmt, wie die Ausnahme dem Aufrufer dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="d9945-267">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</span></span>

-   <span data-ttu-id="d9945-268">In JavaScript erscheint die Ausnahme als Objekt, in dem die Ausnahmemeldung durch eine Stapelüberwachung ersetzt ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-268">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</span></span> <span data-ttu-id="d9945-269">Wenn Sie Ihre App in Visual Studio debuggen, wird der Originaltext der Meldung im Ausnahmedialogfeld des Debuggers unter „WinRT Information" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d9945-269">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</span></span> <span data-ttu-id="d9945-270">Sie können mit JavaScript-Code nicht auf den Originaltext der Meldung zugreifen.</span><span class="sxs-lookup"><span data-stu-id="d9945-270">You can't access the original message text from JavaScript code.</span></span>

    > <span data-ttu-id="d9945-271">**Tipp:** derzeit enthält die stapelüberwachung zwar den verwalteten Ausnahmetyp, jedoch wird nicht empfohlen, diese zu analysieren, um den Ausnahmetyp zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="d9945-271">**Tip**Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</span></span> <span data-ttu-id="d9945-272">Verwenden Sie stattdessen einen HRESULT-Wert, wie weiter unten in diesem Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="d9945-272">Instead, use an HRESULT value as described later in this section.</span></span>

-   <span data-ttu-id="d9945-273">In C++ erscheint die Ausnahme als Plattformausnahme.</span><span class="sxs-lookup"><span data-stu-id="d9945-273">In C++, the exception appears as a platform exception.</span></span> <span data-ttu-id="d9945-274">Wenn die HResult-Eigenschaft der verwalteten Ausnahme dem HRESULT einer bestimmten Plattformausnahme zugeordnet werden kann, wird die jeweilige Ausnahme verwendet. Andernfalls wird eine [Platform::COMException](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)-Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d9945-274">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a [Platform::COMException](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) exception is thrown.</span></span> <span data-ttu-id="d9945-275">Der Meldungstext der verwalteten Ausnahme ist für C++-Code nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="d9945-275">The message text of the managed exception is not available to C++ code.</span></span> <span data-ttu-id="d9945-276">Wenn eine bestimmte Plattformausnahme ausgelöst wurde, erscheint der Meldungstext für diesen Ausnahmetyp. Andernfalls wird kein Meldungstext ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="d9945-276">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</span></span> <span data-ttu-id="d9945-277">Siehe [Ausnahmen (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9945-277">See [Exceptions (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span></span>
-   <span data-ttu-id="d9945-278">In C# oder Visual Basic ist die Ausnahme eine normale verwaltete Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="d9945-278">In C# or Visual Basic, the exception is a normal managed exception.</span></span>

<span data-ttu-id="d9945-279">Wenn Sie in Ihrer Komponente eine Ausnahme auslösen, sollten Sie einen nicht öffentlichen Ausnahmetyp verwenden, dessen HResult-Eigenschaftswert speziell für Ihre Komponente gilt, damit die Ausnahme leichter von einem JavaScript- oder C++-Aufrufer verwaltet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d9945-279">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</span></span> <span data-ttu-id="d9945-280">HRESULT ist für einen JavaScript-Aufrufer über die Eigenschaft „number” des Ausnahmeobjekts verfügbar und für einen C++-Aufrufer über die Eigenschaft [COMException::HResult](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9945-280">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the [COMException::HResult](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) property.</span></span>

> <span data-ttu-id="d9945-281">**Hinweis:** verwenden Sie einen negativen Wert für Ihre HRESULT.</span><span class="sxs-lookup"><span data-stu-id="d9945-281">**Note**Use a negative value for your HRESULT.</span></span> <span data-ttu-id="d9945-282">Ein positiver Wert wird als Erfolg interpretiert und im JavaScript- oder C++-Aufrufer wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d9945-282">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</span></span>

## <a name="declaring-and-raising-events"></a><span data-ttu-id="d9945-283">Deklarieren und Auslösen von Ereignissen</span><span class="sxs-lookup"><span data-stu-id="d9945-283">Declaring and raising events</span></span>
<span data-ttu-id="d9945-284">Wenn Sie einen Typ deklarieren, um die Daten für das Ereignis aufzunehmen, leiten Sie diesen von „Object“ und nicht von „EventArgs“ ab, da „EventArgs“ kein Windows-Runtime-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="d9945-284">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</span></span> <span data-ttu-id="d9945-285">Verwenden Sie [EventHandler&lt;TEventArgs&gt;](https://msdn.microsoft.com/library/db0etb8x.aspx) als Typ des Ereignisses, und verwenden Sie den Ereignisargumenttyp als generisches Typargument.</span><span class="sxs-lookup"><span data-stu-id="d9945-285">Use [EventHandler&lt;TEventArgs&gt;](https://msdn.microsoft.com/library/db0etb8x.aspx) as the type of the event, and use your event argument type as the generic type argument.</span></span> <span data-ttu-id="d9945-286">Lösen Sie das Ereignis genauso wie in einer .NET Framework-Anwendung aus.</span><span class="sxs-lookup"><span data-stu-id="d9945-286">Raise the event just as you would in a .NET Framework application.</span></span>

<span data-ttu-id="d9945-287">Wenn Ihre Komponente für Windows-Runtime von JavaScript oder C++ verwendet wird, folgt das Ereignis dem Windows-Runtime-Ereignismuster, das diese Sprachen erwarten.</span><span class="sxs-lookup"><span data-stu-id="d9945-287">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</span></span> <span data-ttu-id="d9945-288">Wenn Sie die Komponente in C# oder Visual Basic verwenden, erscheint das Ereignis als normales .NET Framework-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="d9945-288">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</span></span> <span data-ttu-id="d9945-289">Ein Beispiel finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript]().</span><span class="sxs-lookup"><span data-stu-id="d9945-289">An example is provided in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript]().</span></span>

<span data-ttu-id="d9945-290">Wenn Sie benutzerdefinierte Ereignisaccessoren implementieren (in Visual Basic ein Ereignis mit dem Schlüsselwort **Custom** deklarieren), müssen Sie in der Implementierung das Windows-Runtime-Ereignismuster verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-290">If you implement custom event accessors (declare an event with the **Custom** keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</span></span> <span data-ttu-id="d9945-291">Siehe [Benutzerdefinierte Ereignisse und Ereignisaccessoren in Komponenten für Windows-Runtime](custom-events-and-event-accessors-in-windows-runtime-components.md).</span><span class="sxs-lookup"><span data-stu-id="d9945-291">See [Custom events and event accessors in Windows Runtime Components](custom-events-and-event-accessors-in-windows-runtime-components.md).</span></span> <span data-ttu-id="d9945-292">Beachten Sie, dass das Ereignis auch dann als einfaches .NET Framework-Ereignis erscheint, wenn Sie C#- oder Visual Basic-Code verwenden.</span><span class="sxs-lookup"><span data-stu-id="d9945-292">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d9945-293">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="d9945-293">Next steps</span></span>
<span data-ttu-id="d9945-294">Nachdem Sie eine Komponente für Windows-Runtime für eigene Zwecke erstellt haben, stellen Sie möglicherweise fest, dass die Funktionen, die diese kapselt, für andere Entwickler nützlich sind.</span><span class="sxs-lookup"><span data-stu-id="d9945-294">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</span></span> <span data-ttu-id="d9945-295">Sie haben zwei Optionen, um eine Komponente für die Verteilung an andere Entwickler zu packen.</span><span class="sxs-lookup"><span data-stu-id="d9945-295">You have two options for packaging a component for distribution to other developers.</span></span> <span data-ttu-id="d9945-296">Siehe [Verteilen einer verwalteten Komponente für Windows-Runtime](https://msdn.microsoft.com/library/jj614475.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9945-296">See [Distributing a managed Windows Runtime component](https://msdn.microsoft.com/library/jj614475.aspx).</span></span>

<span data-ttu-id="d9945-297">Weitere Informationen zu Visual Basic- und C#-Sprachfunktionen und zur .NET Framework-Unterstützung für die Windows-Runtime finden Sie unter [Visual Basic- und C#-Programmiersprachenreferenz](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span><span class="sxs-lookup"><span data-stu-id="d9945-297">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see [Visual Basic and C# language reference](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span></span>

## <a name="related-topics"></a><span data-ttu-id="d9945-298">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="d9945-298">Related topics</span></span>
* [<span data-ttu-id="d9945-299">.NET für UWP-apps (Übersicht)</span><span class="sxs-lookup"><span data-stu-id="d9945-299">.NET for UWP apps Overview</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/br230302.aspx)
* [<span data-ttu-id="d9945-300">.NET für UWP-Apps</span><span class="sxs-lookup"><span data-stu-id="d9945-300">.NET for UWP apps</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)
* [<span data-ttu-id="d9945-301">Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente für Windows-Runtime und Aufrufen der Komponente über JavaScript</span><span class="sxs-lookup"><span data-stu-id="d9945-301">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</span></span>](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
