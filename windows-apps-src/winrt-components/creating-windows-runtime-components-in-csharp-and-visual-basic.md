---
title: Erstellen von Komponenten für Windows-Runtime in C# und Visual Basic
description: Ab .NET Framework4.5 können Sie mit verwaltetem Code eigene Windows-Runtime-Typen erstellen, die in einer Komponente für Windows-Runtime gepackt sind.
ms.assetid: A5672966-74DF-40AB-B01E-01E3FCD0AD7A
ms.date: 12/04/2018
ms.topic: article
dev_langs:
- csharp
- vb
keywords: Windows10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: b4f5a2de5c3fa5564b4e4389cfc0806fd5d2844f
ms.sourcegitcommit: 49d58bc66c1c9f2a4f81473bcb25af79e2b1088d
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 12/11/2018
ms.locfileid: "8928109"
---
# <a name="creating-windows-runtime-components-in-c-and-visual-basic"></a><span data-ttu-id="5f04f-104">Erstellen von Komponenten für Windows-Runtime in C# und Visual Basic</span><span class="sxs-lookup"><span data-stu-id="5f04f-104">Creating Windows Runtime Components in C# and Visual Basic</span></span>
<span data-ttu-id="5f04f-105">Ab .NET Framework 4.5, können Sie verwalteten Code verwenden, um Ihre eigenen Windows-Runtime-Typen zu erstellen und diese in einer Komponente für Windows-Runtime-verpacken.</span><span class="sxs-lookup"><span data-stu-id="5f04f-105">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types and package them in a Windows Runtime component.</span></span> <span data-ttu-id="5f04f-106">Sie können Ihre Komponente in universelle Windows-Plattform (UWP)-apps verwenden, die in C++, JavaScript, Visual Basic oder c# geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-106">You can use your component in Universal Windows Platform (UWP) apps that are written in C++, JavaScript, Visual Basic, or C#.</span></span> <span data-ttu-id="5f04f-107">In diesem Thema wird beschrieben, die Regeln zum Erstellen einer Komponente, und beschreibt einige Aspekte der .NET Framework-Unterstützung für die Windows-Runtime.</span><span class="sxs-lookup"><span data-stu-id="5f04f-107">This topic outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</span></span> <span data-ttu-id="5f04f-108">Im Allgemeinen ist diese Unterstützung allen .NET Framework-Programmierern klar.</span><span class="sxs-lookup"><span data-stu-id="5f04f-108">In general, that support is designed to be transparent to the .NET Framework programmer.</span></span> <span data-ttu-id="5f04f-109">Wenn Sie aber eine Komponente erstellen, die mit JavaScript oder C++ verwendet werden soll, müssen Sie auf die Unterschiede bei der Unterstützung der Windows-Runtime durch diese Sprachen achten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-109">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</span></span>

<span data-ttu-id="5f04f-110">Wenn Sie erstellen eine Komponente nur in UWP-apps, die in Visual Basic oder c# geschrieben werden, und die Komponente enthält keine UWP-Steuerelemente, klicken Sie dann mit der **Klassenbibliotheksvorlage** und anstelle von der **Komponente für Windows-Runtime** -Projektvorlage onsider in Microsoft Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="5f04f-110">If you are creating a component for use only in UWP apps that are written in Visual Basic or C#, and the component does not contain UWP controls, then onsider using the **Class Library** template instead of the **Windows Runtime Component** project template in Microsoft Visual Studio.</span></span> <span data-ttu-id="5f04f-111">Eine einfache Klassenbibliothek weist weniger Einschränkungen auf.</span><span class="sxs-lookup"><span data-stu-id="5f04f-111">There are fewer restrictions on a simple class library.</span></span>

## <a name="declaring-types-in-windows-runtime-components"></a><span data-ttu-id="5f04f-112">Deklarieren von Typen in Komponenten für Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="5f04f-112">Declaring types in Windows Runtime Components</span></span>

<span data-ttu-id="5f04f-113">Intern können die Windows-Runtime-Typen in Ihrer Komponente alle .NET Framework-Funktionen verwenden, die in einer UWP-app zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-113">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a UWP app.</span></span> <span data-ttu-id="5f04f-114">Weitere Informationen finden Sie unter [.NET für UWP-apps](https://msdn.microsoft.com/library/windows/apps/mt185501).</span><span class="sxs-lookup"><span data-stu-id="5f04f-114">For more info, see [.NET for UWP apps](https://msdn.microsoft.com/library/windows/apps/mt185501).</span></span>

<span data-ttu-id="5f04f-115">Extern können die Member Ihrer Typen nur Windows-Runtime-Typen für ihre Parameter und Rückgabewerte verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-115">Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</span></span> <span data-ttu-id="5f04f-116">In der folgende Liste sind die Einschränkungen für .NET Framework-Typen, die aus einer Komponente für Windows-Runtime verfügbar gemacht werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-116">The following list describes the limitations on .NET Framework types that are exposed from a Windows Runtime Component.</span></span>

- <span data-ttu-id="5f04f-117">Die Felder, Parameter und Rückgabewerte aller öffentlichen Typen und Member in der Komponente müssen Windows-Runtime-Typen sein.</span><span class="sxs-lookup"><span data-stu-id="5f04f-117">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</span></span> <span data-ttu-id="5f04f-118">Diese Einschränkung betrifft die Windows-Runtime-Typen, die sowie Typen zu erstellen, die von der Windows-Runtime bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-118">This restriction includes the Windows Runtime types that you author as well as types that are provided by the Windows Runtime itself.</span></span> <span data-ttu-id="5f04f-119">Außerdem trifft sie auf einige .NET Framework-Typen zu.</span><span class="sxs-lookup"><span data-stu-id="5f04f-119">It also includes a number of .NET Framework types.</span></span> <span data-ttu-id="5f04f-120">Die Aufnahme dieser Typen ist Teil der Unterstützung von .NET Framework bietet, um die natürliche Verwendung der Windows-Runtime in verwaltetem Code zu ermöglichen&mdash;Code bekannte .NET Framework-Typen anstelle der zugrunde liegenden Windows-Runtime-Typen verwenden angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="5f04f-120">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code&mdash;your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</span></span> <span data-ttu-id="5f04f-121">Beispielsweise können Sie primitive .NET Framework-Typen wie **Int32** und **Double**, bestimmte grundlegenden Typen wie **DateTimeOffset** und **Uri**, und einige häufig verwendete generische Schnittstellentypen wie IEnumerable- \*\*&lt;T &gt; \*\* (IEnumerable (Of T) in Visual Basic) und **IDictionary&lt;TKey, TValue&gt;**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-121">For example, you can use .NET Framework primitive types such as **Int32** and **Double**, certain fundamental types such as **DateTimeOffset** and **Uri**, and some commonly used generic interface types such as **IEnumerable&lt;T&gt;** (IEnumerable(Of T) in Visual Basic) and **IDictionary&lt;TKey,TValue&gt;**.</span></span> <span data-ttu-id="5f04f-122">Beachten Sie, dass die Typargumente dieser generischen Typen Windows-Runtime-Typen sein müssen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-122">Note that the type arguments of these generic types must be Windows Runtime types.</span></span> <span data-ttu-id="5f04f-123">Dies wird in den Abschnitten [übergeben von Windows-Runtime-Typen an verwalteten Code](#passing-windows-runtime-types-to-managed-code) und [übergeben von verwalteten Typen an die Windows-Runtime](#passing-managed-types-to-the-windows-runtime), später in diesem Thema erläutert.</span><span class="sxs-lookup"><span data-stu-id="5f04f-123">This is discussed in the sections [Passing Windows Runtime types to managed code](#passing-windows-runtime-types-to-managed-code) and [Passing managed types to the Windows Runtime](#passing-managed-types-to-the-windows-runtime), later in this topic.</span></span>

- <span data-ttu-id="5f04f-124">Öffentliche Klassen und Schnittstellen können Methoden, Eigenschaften und Ereignisse enthalten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-124">Public classes and interfaces can contain methods, properties, and events.</span></span> <span data-ttu-id="5f04f-125">Sie können Delegaten für Ereignisse deklarieren oder verwenden Sie die \*\*EventHandler&lt;T&gt; \*\* delegieren.</span><span class="sxs-lookup"><span data-stu-id="5f04f-125">You can declare delegates for your events, or use the **EventHandler&lt;T&gt;** delegate.</span></span> <span data-ttu-id="5f04f-126">Eine öffentliche Klasse oder Schnittstelle kann nicht:</span><span class="sxs-lookup"><span data-stu-id="5f04f-126">A public class or interface can't:</span></span>
    - <span data-ttu-id="5f04f-127">generisch sein.</span><span class="sxs-lookup"><span data-stu-id="5f04f-127">Be generic.</span></span>
    - <span data-ttu-id="5f04f-128">Eine Schnittstelle implementieren, die keine Windows-Runtime-Schnittstelle ist (Sie können eigene Windows-Runtime-Schnittstellen erstellen und implementieren sie).</span><span class="sxs-lookup"><span data-stu-id="5f04f-128">Implement an interface that is not a Windows Runtime interface (however, you can create your own Windows Runtime interfaces and implement them).</span></span>
    - <span data-ttu-id="5f04f-129">Von Typen, die nicht in der Windows-Runtime, wie **System.Exception** und **System.EventArgs**abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="5f04f-129">Derive from types that are not in the Windows Runtime, such as **System.Exception** and **System.EventArgs**.</span></span>

- <span data-ttu-id="5f04f-130">Alle öffentliche Typen müssen über einen Stammnamespace verfügen, der mit dem Assemblynamen übereinstimmt, und der Assemblyname darf nicht mit „Windows” beginnen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-130">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</span></span>

    > <span data-ttu-id="5f04f-131">**Tipp**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-131">**Tip**.</span></span> <span data-ttu-id="5f04f-132">Standardmäßig entsprechen die Namespacenamen in Visual Studio-Projekten den Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-132">By default, Visual Studio projects have namespace names that match the assembly name.</span></span> <span data-ttu-id="5f04f-133">In Visual Basic wird die Namespace-Anweisung für diesen Standardnamespace nicht im Code angezeigt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-133">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</span></span>

- <span data-ttu-id="5f04f-134">Öffentliche Strukturen können nur öffentliche Felder als Member enthalten, und diese Felder müssen Werttypen oder Zeichenfolgen sein.</span><span class="sxs-lookup"><span data-stu-id="5f04f-134">Public structures can't have any members other than public fields, and those fields must be value types or strings.</span></span>
- <span data-ttu-id="5f04f-135">Öffentliche Klassen müssen **versiegelt** (**NotInheritable** in Visual Basic) sein.</span><span class="sxs-lookup"><span data-stu-id="5f04f-135">Public classes must be **sealed** (**NotInheritable** in Visual Basic).</span></span> <span data-ttu-id="5f04f-136">Wenn das Programmiermodell Polymorphie erfordert, können Sie eine öffentliche Schnittstelle erstellen und implementieren Sie diese Schnittstelle für die Klassen, die polymorph sein müssen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-136">If your programming model requires polymorphism, then you can create a public interface, and implement that interface on the classes that must be polymorphic.</span></span>

## <a name="debugging-your-component"></a><span data-ttu-id="5f04f-137">Debuggen der Komponente</span><span class="sxs-lookup"><span data-stu-id="5f04f-137">Debugging your component</span></span>

<span data-ttu-id="5f04f-138">Wenn Ihre UWP-app und Ihre Komponente mit verwaltetem Code erstellt wurden, können Sie beide gleichzeitig Debuggen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-138">If both your UWP app and your component are built with managed code, then you can debug them both at the same time.</span></span>

<span data-ttu-id="5f04f-139">Wenn Sie Ihre Komponente als Teil einer UWP-app mit C++ testen, können Sie verwalteten und systemeigenen Code gleichzeitig Debuggen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-139">When you're testing your component as part of a UWP app using C++, you can debug managed and native code at the same time.</span></span> <span data-ttu-id="5f04f-140">Die Vorgabe ist nur systemeigener Code.</span><span class="sxs-lookup"><span data-stu-id="5f04f-140">The default is native code only.</span></span>

## <a name="to-debug-both-native-c-code-and-managed-code"></a><span data-ttu-id="5f04f-141">So debuggen Sie systemeigenen C++-Code und verwalteten Code</span><span class="sxs-lookup"><span data-stu-id="5f04f-141">To debug both native C++ code and managed code</span></span>
1.  <span data-ttu-id="5f04f-142">Öffnen Sie das Kontextmenü für das Visual C++-Projekt, und wählen Sie **Eigenschaften** aus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-142">Open the shortcut menu for your Visual C++ project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="5f04f-143">Wählen Sie auf den Eigenschaftenseiten unter **Konfigurationseigenschaften** die Option **Debuggen** aus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-143">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="5f04f-144">Wählen Sie **Debuggertyp** aus, und ändern Sie dann in der Dropdownliste **Nur systemeigen** in **Gemischt (verwaltet und systemeigen)**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-144">Choose **Debugger Type**, and in the drop-down list box change **Native Only** to **Mixed (Managed and Native)**.</span></span> <span data-ttu-id="5f04f-145">Klicken Sie auf **OK**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-145">Choose **OK**.</span></span>
4.  <span data-ttu-id="5f04f-146">Legen Sie Haltepunkte im systemeigenen und verwalteten Code fest.</span><span class="sxs-lookup"><span data-stu-id="5f04f-146">Set breakpoints in native and managed code.</span></span>

<span data-ttu-id="5f04f-147">Wenn Sie Ihre Komponente als Teil einer UWP-app mit JavaScript testen, ist die Projektmappe standardmäßig im JavaScript-Debugmodus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-147">When you're testing your component as part of a UWP app using JavaScript, by default the solution is in JavaScript debugging mode.</span></span> <span data-ttu-id="5f04f-148">In Visual Studio ist das gleichzeitige Debuggen von JavaScript und verwaltetem Code nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="5f04f-148">In Visual Studio, you can't debug JavaScript and managed code at the same time.</span></span>

## <a name="to-debug-managed-code-instead-of-javascript"></a><span data-ttu-id="5f04f-149">So debuggen Sie verwalteten Code anstelle von JavaScript</span><span class="sxs-lookup"><span data-stu-id="5f04f-149">To debug managed code instead of JavaScript</span></span>
1.  <span data-ttu-id="5f04f-150">Öffnen Sie das Kontextmenü für das JavaScript-Projekt, und wählen Sie **Eigenschaften** aus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-150">Open the shortcut menu for your JavaScript project, and choose **Properties**.</span></span>
2.  <span data-ttu-id="5f04f-151">Wählen Sie auf den Eigenschaftenseiten unter **Konfigurationseigenschaften** die Option **Debuggen** aus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-151">In the property pages, under **Configuration Properties**, choose **Debugging**.</span></span>
3.  <span data-ttu-id="5f04f-152">Wählen Sie **Debuggertyp** aus, und ändern Sie in der Dropdownliste **Nur Skript** in **Nur verwaltet**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-152">Choose **Debugger Type**, and in the drop-down list box change **Script Only** to **Managed Only**.</span></span> <span data-ttu-id="5f04f-153">Klicken Sie auf **OK**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-153">Choose **OK**.</span></span>
4.  <span data-ttu-id="5f04f-154">Legen Sie Haltepunkte im verwaltetem Code fest, und debuggen Sie wie gewohnt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-154">Set breakpoints in managed code and debug as usual.</span></span>

## <a name="passing-windows-runtime-types-to-managed-code"></a><span data-ttu-id="5f04f-155">Übergeben von Windows-Runtime Typen an verwalteten Code</span><span class="sxs-lookup"><span data-stu-id="5f04f-155">Passing Windows Runtime types to managed code</span></span>
<span data-ttu-id="5f04f-156">Wie bereits im Abschnitt [Deklarieren von Typen in Komponenten für Windows-Runtime-](#declaring-types-in-windows-runtime-components)erwähnt, können bestimmte .NET Framework-Typen in den Signaturen von Membern öffentlicher Klassen erscheinen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-156">As mentioned previously in the section [Declaring types in Windows Runtime Components](#declaring-types-in-windows-runtime-components), certain .NET Framework types can appear in the signatures of members of public classes.</span></span> <span data-ttu-id="5f04f-157">Dies ist Teil der Unterstützung, die .NET Framework bietet, um die natürliche Verwendung der Windows-Runtime in verwaltetem Code zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-157">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</span></span> <span data-ttu-id="5f04f-158">Darin sind primitive Typen und einige Klassen und Schnittstellen enthalten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-158">It includes primitive types and some classes and interfaces.</span></span> <span data-ttu-id="5f04f-159">Wenn die Komponente über JavaScript oder C++-Code verwendet wird, ist es wichtig zu wissen, wie die .NET Framework-Typen an den Aufrufer angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-159">When your component is used from JavaScript, or from C++ code, it's important to know how your .NET Framework types appear to the caller.</span></span> <span data-ttu-id="5f04f-160">Beispiele mit JavaScript finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-160">See [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md) for examples with JavaScript.</span></span> <span data-ttu-id="5f04f-161">In diesem Abschnitt werden häufig verwendete Typen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-161">This section discusses commonly used types.</span></span>

<span data-ttu-id="5f04f-162">In .NET Framework haben primitive Typen wie **Int32** -Struktur viele nützliche Eigenschaften und Methoden, z. B. die **TryParse** -Methode.</span><span class="sxs-lookup"><span data-stu-id="5f04f-162">In the .NET Framework, primitive types such as the **Int32** structure have many useful properties and methods, such as the **TryParse** method.</span></span> <span data-ttu-id="5f04f-163">Im Gegensatz dazu haben primitive Typen und Strukturen in der Windows-Runtime nur Felder.</span><span class="sxs-lookup"><span data-stu-id="5f04f-163">By contrast, primitive types and structures in the Windows Runtime only have fields.</span></span> <span data-ttu-id="5f04f-164">Wenn Sie diese Typen an verwalteten Code übergeben, verhalten sie sich wie .NET Framework-Typen, und Sie können die Eigenschaften und Methoden der .NET Framework-Typen wie gewohnt verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-164">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</span></span> <span data-ttu-id="5f04f-165">Die folgende Liste fasst die Ersetzungen zusammen, die automatisch in der IDE vorgenommen werden:</span><span class="sxs-lookup"><span data-stu-id="5f04f-165">The following list summarizes the substitutions that are made automatically in the IDE:</span></span>

-   <span data-ttu-id="5f04f-166">Für die primitiven Windows-Runtime **Int32** **Int64**, **Single**, **Double**, **Boolean**, **String** (eine unveränderliche Sammlung von Unicode-Zeichen), **Enum**, **UInt32**, **UInt64**und \*\*Guid \*\*, verwenden Sie den Typ mit dem gleichen Namen im System-Namespace.</span><span class="sxs-lookup"><span data-stu-id="5f04f-166">For the Windows Runtime primitives **Int32**, **Int64**, **Single**, **Double**, **Boolean**, **String** (an immutable collection of Unicode characters), **Enum**, **UInt32**, **UInt64**, and **Guid**, use the type of the same name in the System namespace.</span></span>
-   <span data-ttu-id="5f04f-167">Verwenden Sie für **UInt8** **den Typ System.Byte**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-167">For **UInt8**, use **System.Byte**.</span></span>
-   <span data-ttu-id="5f04f-168">Verwenden Sie für **Char16** **den Typ System.Char**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-168">For **Char16**, use **System.Char**.</span></span>
-   <span data-ttu-id="5f04f-169">Verwenden Sie für die **IInspectable** -Schnittstelle **System.Object**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-169">For the **IInspectable** interface, use **System.Object**.</span></span>

<span data-ttu-id="5f04f-170">Wenn c# oder Visual Basic ein Schlüsselwort für einen dieser Typen bereitstellt, können Sie stattdessen das Schlüsselwort verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-170">If C# or Visual Basic provides a language keyword for any of these types, then you can use the language keyword instead.</span></span>

<span data-ttu-id="5f04f-171">Zusätzlich zu primitiven Typen erscheinen einige grundlegende, häufig verwendete Windows-Runtime-Typen in verwaltetem Code als ihre .NET Framework-Entsprechung.</span><span class="sxs-lookup"><span data-stu-id="5f04f-171">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</span></span> <span data-ttu-id="5f04f-172">Nehmen wir beispielsweise an Ihren JavaScript-Code verwendet die **Windows.Foundation.Uri** -Klasse, und es auf ein C#- oder Visual Basic-Methode übergeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-172">For example, suppose your JavaScript code uses the **Windows.Foundation.Uri** class, and you want to pass it to a C# or Visual Basic method.</span></span> <span data-ttu-id="5f04f-173">Entspricht der Typ im verwalteten Code ist die .NET Framework- **System.Uri** -Klasse, und das ist der Typ, der für den Methodenparameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="5f04f-173">The equivalent type in managed code is the .NET Framework **System.Uri** class, and that's the type to use for the method parameter.</span></span> <span data-ttu-id="5f04f-174">Sie können feststellen, wann ein Windows-Runtime-Typ als .NET Framework-Typ erscheint, da IntelliSense in Visual Studio den Windows-Runtime-Typ ausblendet, wenn Sie verwalteten Code schreiben und den entsprechenden .NET Framework-Typ anzeigt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-174">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</span></span> <span data-ttu-id="5f04f-175">(In der Regel haben beiden Typen den gleichen Namen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-175">(Usually the two types have the same name.</span></span> <span data-ttu-id="5f04f-176">Beachten Sie jedoch, dass die **Windows.Foundation.DateTime** -Struktur in verwaltetem Code als **System.DateTimeOffset** und nicht als **System.DateTime**angezeigt wird.)</span><span class="sxs-lookup"><span data-stu-id="5f04f-176">However, note that the **Windows.Foundation.DateTime** structure appears in managed code as **System.DateTimeOffset** and not as **System.DateTime**.)</span></span>

<span data-ttu-id="5f04f-177">Für einige häufig verwendete Sammlungstypen erfolgt die Zuordnung zwischen den Schnittstellen, die von einem Windows-Runtime-Typ implementiert werden, und den Schnittstellen, die vom entsprechenden .NET Framework-Typ implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-177">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</span></span> <span data-ttu-id="5f04f-178">Wie bei den bereits erwähnten Typen deklarieren Sie Parametertypen, indem Sie den .NET Framework-Typ verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-178">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</span></span> <span data-ttu-id="5f04f-179">Dadurch werden bestimmte Unterschiede zwischen den Typen ausgeblendet, und das Schreiben von .NET Framework-Code wirkt natürlicher.</span><span class="sxs-lookup"><span data-stu-id="5f04f-179">This hides some differences between the types and makes writing .NET Framework code more natural.</span></span>

<span data-ttu-id="5f04f-180">In der folgenden Tabelle sind die häufigsten dieser generischen Schnittstellentypen zusammen mit anderen allgemeinen Klassen- und Schnittstellenzuordnungen aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-180">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</span></span> <span data-ttu-id="5f04f-181">Eine vollständige Liste der Windows-Runtime-Typen, die das .NET Framework zuordnet, finden Sie unter [.NET Framework-Zuordnungen von Windows-Runtime-Typen](net-framework-mappings-of-windows-runtime-types.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-181">For a complete list of Windows Runtime types that the .NET Framework maps, see [.NET Framework mappings of Windows Runtime types](net-framework-mappings-of-windows-runtime-types.md).</span></span>

| <span data-ttu-id="5f04f-182">Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="5f04f-182">Windows Runtime</span></span>                                  | <span data-ttu-id="5f04f-183">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="5f04f-183">.NET Framework</span></span>                                    |
|-|-|
| <span data-ttu-id="5f04f-184">IIterable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-184">IIterable&lt;T&gt;</span></span>                               | <span data-ttu-id="5f04f-185">IEnumerable&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-185">IEnumerable&lt;T&gt;</span></span>                              |
| <span data-ttu-id="5f04f-186">IVector&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-186">IVector&lt;T&gt;</span></span>                                 | <span data-ttu-id="5f04f-187">IList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-187">IList&lt;T&gt;</span></span>                                    |
| <span data-ttu-id="5f04f-188">IVectorView&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-188">IVectorView&lt;T&gt;</span></span>                             | <span data-ttu-id="5f04f-189">IReadOnlyList&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-189">IReadOnlyList&lt;T&gt;</span></span>                            |
| <span data-ttu-id="5f04f-190">IMap&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-190">IMap&lt;K, V&gt;</span></span>                                 | <span data-ttu-id="5f04f-191">IDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-191">IDictionary&lt;TKey, TValue&gt;</span></span>                   |
| <span data-ttu-id="5f04f-192">IMapView&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-192">IMapView&lt;K, V&gt;</span></span>                             | <span data-ttu-id="5f04f-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-193">IReadOnlyDictionary&lt;TKey, TValue&gt;</span></span>           |
| <span data-ttu-id="5f04f-194">IKeyValuePair&lt;K, V&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-194">IKeyValuePair&lt;K, V&gt;</span></span>                        | <span data-ttu-id="5f04f-195">KeyValuePair&lt;TKey, TValue&gt;</span><span class="sxs-lookup"><span data-stu-id="5f04f-195">KeyValuePair&lt;TKey, TValue&gt;</span></span>                  |
| <span data-ttu-id="5f04f-196">IBindableIterable</span><span class="sxs-lookup"><span data-stu-id="5f04f-196">IBindableIterable</span></span>                                | <span data-ttu-id="5f04f-197">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="5f04f-197">IEnumerable</span></span>                                       |
| <span data-ttu-id="5f04f-198">IBindableVecinr</span><span class="sxs-lookup"><span data-stu-id="5f04f-198">IBindableVector</span></span>                                  | <span data-ttu-id="5f04f-199">IList</span><span class="sxs-lookup"><span data-stu-id="5f04f-199">IList</span></span>                                             |
| <span data-ttu-id="5f04f-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="5f04f-200">Windows.UI.Xaml.Data.INotifyPropertyChanged</span></span>      | <span data-ttu-id="5f04f-201">System.ComponentModel.INotifyPropertyChanged</span><span class="sxs-lookup"><span data-stu-id="5f04f-201">System.ComponentModel.INotifyPropertyChanged</span></span>      |
| <span data-ttu-id="5f04f-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="5f04f-202">Windows.UI.Xaml.Data.PropertyChangedEventHandler</span></span> | <span data-ttu-id="5f04f-203">System.ComponentModel.PropertyChangedEventHandler</span><span class="sxs-lookup"><span data-stu-id="5f04f-203">System.ComponentModel.PropertyChangedEventHandler</span></span> |
| <span data-ttu-id="5f04f-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="5f04f-204">Windows.UI.Xaml.Data.PropertyChangedEventArgs</span></span>    | <span data-ttu-id="5f04f-205">System.ComponentModel.PropertyChangedEventArgs</span><span class="sxs-lookup"><span data-stu-id="5f04f-205">System.ComponentModel.PropertyChangedEventArgs</span></span>    |

<span data-ttu-id="5f04f-206">Wenn ein Typ mehrere Schnittstellen implementiert, können Sie jede Schnittstelle verwenden, die als Parametertyp oder Rückgabetyp eines Members implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="5f04f-206">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</span></span> <span data-ttu-id="5f04f-207">Angenommen, Sie übergeben oder zurückgeben können eine **Wörterbuch&lt;Int, String&gt; \*\* (**Dictionary (Of Integer, String)\*\* in Visual Basic) als **IDictionary&lt;Int, String&gt;**, \*\*IReadOnlyDictionary&lt;Int, String &gt; \*\*, oder **IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-207">For example, you can pass or return a **Dictionary&lt;int, string&gt;** (**Dictionary(Of Integer, String)** in Visual Basic) as **IDictionary&lt;int, string&gt;**, **IReadOnlyDictionary&lt;int, string&gt;**, or **IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5f04f-208">JavaScript verwendet die Schnittstelle, die zuerst in der Liste der Schnittstellen angezeigt wird, die ein verwalteter Typ implementiert.</span><span class="sxs-lookup"><span data-stu-id="5f04f-208">JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</span></span> <span data-ttu-id="5f04f-209">Wenn Sie zurückkehren, z. B. \*\*Wörterbuch&lt;Int, String&gt; \*\* an JavaScript-Code, sie wird als \*\*IDictionary&lt;Int, String&gt; \*\* unabhängig davon, welche Schnittstelle Sie als Rückgabetyp angeben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-209">For example, if you return **Dictionary&lt;int, string&gt;** to JavaScript code, it appears as **IDictionary&lt;int, string&gt;** no matter which interface you specify as the return type.</span></span> <span data-ttu-id="5f04f-210">Das bedeutet, dass die erste Schnittstelle Member enthalten muss, die in den nächsten Schnittstellen erscheinen, damit diese Member für JavaScript sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="5f04f-210">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</span></span>

<span data-ttu-id="5f04f-211">In der Windows-Runtime \*\*IMap&lt;K, V&gt; \*\* und \*\*IMapView&lt;K, V&gt; \*\* werden mit IKeyValuePair durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-211">In the Windows Runtime, **IMap&lt;K, V&gt;** and **IMapView&lt;K, V&gt;** are iterated by using IKeyValuePair.</span></span> <span data-ttu-id="5f04f-212">Wenn Sie diese an verwalteten Code übergeben, werden sie als \*\*IDictionary&lt;TKey, TValue&gt; \*\* und **IReadOnlyDictionary&lt;TKey, TValue&gt;**, natürlich verwenden Sie \*\*System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt; \*\* auflisten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-212">When you pass them to managed code, they appear as **IDictionary&lt;TKey, TValue&gt;** and **IReadOnlyDictionary&lt;TKey, TValue&gt;**, so naturally you use **System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;** to enumerate them.</span></span>

<span data-ttu-id="5f04f-213">Die Darstellungsweise von Schnittstellen in verwaltetem Code wirkt sich auf die Darstellungsweise der Typen aus, die diese Schnittstellen implementieren.</span><span class="sxs-lookup"><span data-stu-id="5f04f-213">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</span></span> <span data-ttu-id="5f04f-214">Die **PropertySet** -Klasse implementiert z. B. **IMap&lt;K, V&gt;**, die angezeigt wird, in verwaltetem Code als **IDictionary&lt;TKey, TValue&gt;**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-214">For example, the **PropertySet** class implements **IMap&lt;K, V&gt;**, which appears in managed code as **IDictionary&lt;TKey, TValue&gt;**.</span></span> <span data-ttu-id="5f04f-215">**PropertySet** wird angezeigt, als ob sie implementiert \*\*IDictionary&lt;TKey, TValue&gt; \*\* anstelle von **IMap&lt;K, V&gt;** in verwaltetem Code scheinbar eine **Add** -Methode vorhanden, die verhält, wie die **Add** -Methode in .NET Framework-Wörterbüchern.</span><span class="sxs-lookup"><span data-stu-id="5f04f-215">**PropertySet** appears as if it implemented **IDictionary&lt;TKey, TValue&gt;** instead of **IMap&lt;K, V&gt;**, so in managed code it appears to have an **Add** method, which behaves like the **Add** method on .NET Framework dictionaries.</span></span> <span data-ttu-id="5f04f-216">Es wird nicht angezeigt, haben Sie eine **Insert** -Methode.</span><span class="sxs-lookup"><span data-stu-id="5f04f-216">It doesn't appear to have an **Insert** method.</span></span> <span data-ttu-id="5f04f-217">Sie finden dieses Beispiel im Thema [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in c# oder Visual Basic und Aufrufen der Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-217">You can see this example in the topic [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="passing-managed-types-to-the-windows-runtime"></a><span data-ttu-id="5f04f-218">Übergeben von verwalteten Typen an die Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="5f04f-218">Passing managed types to the Windows Runtime</span></span>

<span data-ttu-id="5f04f-219">Wie bereits im vorherigen Abschnitt erwähnt, können einige Windows-Runtime-Typen als .NET Framework-Typen in den Signaturen von Komponentenmembern oder in den Signaturen von Windows-Runtime-Membern erscheinen, wenn Sie sie in der IDE verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-219">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</span></span> <span data-ttu-id="5f04f-220">Wenn Sie .NET Framework-Typen an diese Member übergeben oder als Rückgabewerte von Komponentenmembern verwenden, werden sie dem Code auf der anderen Seite als der entsprechende Windows-Runtime-Typ dargestellt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-220">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</span></span> <span data-ttu-id="5f04f-221">Sie finden einige Beispiele für die Auswirkungen beim Aufruf Ihrer Komponente in JavaScript im Abschnitt „Zurückgeben verwalteter Typen aus der Komponente” unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-221">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

## <a name="overloaded-methods"></a><span data-ttu-id="5f04f-222">Überladene Methoden</span><span class="sxs-lookup"><span data-stu-id="5f04f-222">Overloaded methods</span></span>

<span data-ttu-id="5f04f-223">In der Windows-Runtime können Methoden überladen werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-223">In the Windows Runtime, methods can be overloaded.</span></span> <span data-ttu-id="5f04f-224">Wenn Sie mehrere Überladungen mit der gleichen Anzahl von Parametern deklarieren, müssen Sie das Attribut [**Windows.Foundation.Metadata.defaultoverloadattribute versehen wird**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute) nur auf eine dieser Überladungen anwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-224">However, if you declare multiple overloads with the same number of parameters, you must apply the [**Windows.Foundation.Metadata.DefaultOverloadAttribute**](/uwp/api/windows.foundation.metadata.defaultoverloadattribute) attribute to only one of those overloads.</span></span> <span data-ttu-id="5f04f-225">Nur diese Überladung kann aus JavaScript aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-225">That overload is the only one you can call from JavaScript.</span></span> <span data-ttu-id="5f04f-226">Im folgenden Code ist beispielsweise die Überladung, die **int** übernimmt (**Integer** in Visual Basic), die Standardüberladung.</span><span class="sxs-lookup"><span data-stu-id="5f04f-226">For example, in the following code the overload that takes an **int** (**Integer** in Visual Basic) is the default overload.</span></span>

```csharp
public string OverloadExample(string s)
{
    return s;
}

[Windows.Foundation.Metadata.DefaultOverload()]
public int OverloadExample(int x)
{
    return x;
}
```

```vb
Public Function OverloadExample(ByVal s As String) As String
    Return s
End Function

<Windows.Foundation.Metadata.DefaultOverload> _
Public Function OverloadExample(ByVal x As Integer) As Integer
    Return x
End Function
```

> <span data-ttu-id="5f04f-227">[WICHTIGE] JavaScript können Sie einen beliebigen Wert zu **OverloadExample**übergeben und wandelt den Wert in den Typ, der durch den Parameter erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-227">[IMPORTANT] JavaScript allows you to pass any value to **OverloadExample**, and coerces the value to the type that is required by the parameter.</span></span> <span data-ttu-id="5f04f-228">Sie können **OverloadExample** mit "Zweiundvierzig", "42" oder "42,3" aufrufen, aber alle diese Werte werden an die standardüberladung übergeben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-228">You can call **OverloadExample** with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</span></span> <span data-ttu-id="5f04f-229">Die standardüberladung im vorherigen Beispiel gibt 0, 42 bzw. 42 zurück.</span><span class="sxs-lookup"><span data-stu-id="5f04f-229">The default overload in the previous example returns 0, 42, and 42, respectively.</span></span>

<span data-ttu-id="5f04f-230">Sie können keine Konstruktoren das **DefaultOverloadAttribut**-e-Mail-Attribut zuweisen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-230">You can't apply the **DefaultOverloadAttribut**e attribute to constructors.</span></span> <span data-ttu-id="5f04f-231">Alle Konstruktoren in einer Klasse müssen eine unterschiedliche Anzahl von Parametern aufweisen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-231">All the constructors in a class must have different numbers of parameters.</span></span>

## <a name="implementing-istringable"></a><span data-ttu-id="5f04f-232">Implementieren von IStringable</span><span class="sxs-lookup"><span data-stu-id="5f04f-232">Implementing IStringable</span></span>

<span data-ttu-id="5f04f-233">Ab Windows 8.1 enthält die Windows-Runtime eine **IStringable** -Schnittstelle, deren einzige Methode, **IStringable.ToString**, grundlegende formatierungsunterstützung mit **Object.ToString**enthält.</span><span class="sxs-lookup"><span data-stu-id="5f04f-233">Starting with Windows 8.1, the Windows Runtime includes an **IStringable** interface whose single method, **IStringable.ToString**, provides basic formatting support comparable to that provided by **Object.ToString**.</span></span> <span data-ttu-id="5f04f-234">Wenn Sie **IStringable** in einem öffentlichen, verwalteten Typ implementieren möchten, die in einer Komponente für Windows-Runtime exportiert wird, gelten folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="5f04f-234">If you do choose to implement **IStringable** in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</span></span>

-   <span data-ttu-id="5f04f-235">Sie können die **IStringable** -Schnittstelle nur in einer "Klasse implementiert", z. B. den folgenden Code in c# definieren:</span><span class="sxs-lookup"><span data-stu-id="5f04f-235">You can define the **IStringable** interface only in a "class implements" relationship, such as the following code in C#:</span></span>

    ```cs
    public class NewClass : IStringable
    ```

    <span data-ttu-id="5f04f-236">Oder in Visual Basic-Code:</span><span class="sxs-lookup"><span data-stu-id="5f04f-236">Or the following Visual Basic code:</span></span>

    ```vb
    Public Class NewClass : Implements IStringable
    ```

-   <span data-ttu-id="5f04f-237">Sie können keine **IStringable** in einer Schnittstelle implementieren.</span><span class="sxs-lookup"><span data-stu-id="5f04f-237">You can't implement **IStringable** on an interface.</span></span>
-   <span data-ttu-id="5f04f-238">Sie können einen Parameter vom Typ **IStringable**nicht deklarieren.</span><span class="sxs-lookup"><span data-stu-id="5f04f-238">You can't declare a parameter to be of type **IStringable**.</span></span>
-   <span data-ttu-id="5f04f-239">**IStringable** kann nicht der Rückgabetyp einer Methode, eine Eigenschaft oder ein Feld sein.</span><span class="sxs-lookup"><span data-stu-id="5f04f-239">**IStringable** can't be the return type of a method, property, or field.</span></span>
-   <span data-ttu-id="5f04f-240">Sie können die **IStringable** -Implementierung von Basisklassen verbergen, indem Sie eine Methodendefinition wie folgt:</span><span class="sxs-lookup"><span data-stu-id="5f04f-240">You can't hide your **IStringable** implementation from base classes by using a method definition such as the following:</span></span>

    ```cs
    public class NewClass : IStringable
    {
       public new string ToString()
       {
          return "New ToString in NewClass";
       }
    }
    ```

    <span data-ttu-id="5f04f-241">Stattdessen muss die **IStringable.ToString** -Implementierung immer die Implementierung der Basisklasse überschreiben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-241">Instead, the **IStringable.ToString** implementation must always override the base class implementation.</span></span> <span data-ttu-id="5f04f-242">Sie können eine **ToString** -Implementierung ausblenden, nur, indem sie für eine stark typisierte Klasseninstanz aufrufen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-242">You can hide a **ToString** implementation only by invoking it on a strongly typed class instance.</span></span>

> [!NOTE]
> <span data-ttu-id="5f04f-243">Unter verschiedenen Bedingungen können Aufrufe von systemeigenem Code auf einen verwalteten Typ, der **IStringable** implementiert oder seine **ToString** -Implementierung verbirgt unerwartetem Verhalten führen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-243">Under a variety of conditions, calls from native code to a managed type that implements **IStringable** or hides its **ToString** implementation can produce unexpected behavior.</span></span>

## <a name="asynchronous-operations"></a><span data-ttu-id="5f04f-244">Asynchrone Vorgänge</span><span class="sxs-lookup"><span data-stu-id="5f04f-244">Asynchronous operations</span></span>

<span data-ttu-id="5f04f-245">Um eine asynchrone Methode in Ihrer Komponente zu implementieren, fügen Sie am Ende des Methodennamens "Async", und Zurückgeben eines Windows-Runtime-Schnittstellen, die asynchrone Aktionen oder Vorgänge repräsentieren: **IAsyncAction**, IAsyncActionWithProgress- **&lt; TProgress&gt;**, **IAsyncOperation&lt;TResult&gt;**, oder **IAsyncOperationWithProgress&lt;TResult, TProgress&gt;**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-245">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: **IAsyncAction**, **IAsyncActionWithProgress&lt;TProgress&gt;**, **IAsyncOperation&lt;TResult&gt;**, or **IAsyncOperationWithProgress&lt;TResult, TProgress&gt;**.</span></span>

<span data-ttu-id="5f04f-246">Sie können die .NET Framework-Aufgaben (der [**Task**](/dotnet/api/system.threading.tasks.task) -Klasse und die generische [\*\*Aufgabe&lt;TResult&gt; \*\*](/dotnet/api/system.threading.tasks.task-1) Klasse) eine asynchrone Methode implementieren.</span><span class="sxs-lookup"><span data-stu-id="5f04f-246">You can use .NET Framework tasks (the [**Task**](/dotnet/api/system.threading.tasks.task) class and generic [**Task&lt;TResult&gt;**](/dotnet/api/system.threading.tasks.task-1) class) to implement your asynchronous method.</span></span> <span data-ttu-id="5f04f-247">Sie müssen eine Aufgabe zurückgeben, die einen laufenden Vorgang darstellt, z. B. eine Aufgabe, die von einer asynchronen Methode in c# oder Visual Basic geschrieben zurückgegeben wird, oder eine Aufgabe, die von der [**Task.Run**](/dotnet/api/system.threading.tasks.task.run) -Methode zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="5f04f-247">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the [**Task.Run**](/dotnet/api/system.threading.tasks.task.run) method.</span></span> <span data-ttu-id="5f04f-248">Wenn Sie für die Aufgabenerstellung einen Konstruktor verwenden, müssen Sie seine [Task.Start](/dotnet/api/system.threading.tasks.task.start)-Methode vor der Rückgabe aufrufen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-248">If you use a constructor to create the task, you must call its [Task.Start](/dotnet/api/system.threading.tasks.task.start) method before returning it.</span></span>

<span data-ttu-id="5f04f-249">Eine Methode, die verwendet `await` (`Await` in Visual Basic) erfordert die `async` Schlüsselwort (`Async` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="5f04f-249">A method that uses `await` (`Await` in Visual Basic) requires the `async` keyword (`Async` in Visual Basic).</span></span> <span data-ttu-id="5f04f-250">Wenn Sie eine solche Methode aus einer Komponente für Windows-Runtime verfügbar machen, die `async` Schlüsselwort für den Delegaten, die an die **Run** -Methode übergeben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-250">If you expose such a method from a Windows Runtime component, apply the `async` keyword to the delegate that you pass to the **Run** method.</span></span>

<span data-ttu-id="5f04f-251">Für asynchrone Aktionen und Vorgänge, die weder die Abbruch- noch die Fortschrittsberichterstattung unterstützen, können Sie mit der Erweiterungsmethode [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) oder [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) die Aufgabe in die entsprechende Schnittstelle umschließen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-251">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the [WindowsRuntimeSystemExtensions.AsAsyncAction](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx) or [AsAsyncOperation&lt;TResult&gt;](https://msdn.microsoft.com/library/hh779745.aspx) extension method to wrap the task in the appropriate interface.</span></span> <span data-ttu-id="5f04f-252">Der folgende Code implementiert z. B. eine asynchrone Methode, mit der \*\*Task.Run&lt;TResult&gt; \*\* Methode, um eine Aufgabe zu starten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-252">For example, the following code implements an asynchronous method by using the **Task.Run&lt;TResult&gt;** method to start a task.</span></span> <span data-ttu-id="5f04f-253">Die \*\*AsAsyncOperation&lt;TResult&gt; \*\* Erweiterungsmethode gibt die Aufgabe als asynchronen Windows-Runtime-Vorgang zurück.</span><span class="sxs-lookup"><span data-stu-id="5f04f-253">The **AsAsyncOperation&lt;TResult&gt;** extension method returns the task as a Windows Runtime asynchronous operation.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return Task.Run<IList<string>>(async () =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    }).AsAsyncOperation();
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
     As IAsyncOperation(Of IList(Of String))

    Return Task.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function).AsAsyncOperation()
End Function
```

<span data-ttu-id="5f04f-254">Der folgende JavaScript-Code zeigt, wie die Methode aufgerufen werden kann, mit einem [**WinJS.Promise**](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) -Objekt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-254">The following JavaScript code shows how the method could be called by using a [**WinJS.Promise**](https://msdn.microsoft.com/library/windows/apps/br211867.aspx) object.</span></span> <span data-ttu-id="5f04f-255">Die an die then-Methode übergebene Funktion wird ausgeführt, wenn der asynchrone Aufruf abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-255">The function that is passed to the then method is executed when the asynchronous call completes.</span></span> <span data-ttu-id="5f04f-256">Der StringList-Parameter enthält die Liste der Zeichenfolgen, die von der **DownloadAsStringAsync** -Methode zurückgegeben wird, und die Funktion übernimmt Verarbeitung erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-256">The stringList parameter contains the list of strings that is returned by the **DownloadAsStringAsync** method, and the function does whatever processing is required.</span></span>

```javascript
function asyncExample(id) {

    var result = SampleComponent.Example.downloadAsStringAsync(id).then(
        function (stringList) {
            // Place code that uses the returned list of strings here.
        });
}
```

<span data-ttu-id="5f04f-257">Verwenden Sie für asynchrone Aktionen und Vorgänge, die Abbruch- oder Fortschrittsberichterstattung unterstützen, [**AsyncInfo**](/dotnet/api/system.runtime.interopservices.windowsruntime) -Klasse, um eine gestartete Aufgabe zu generieren und die Abbruch-und fortschrittsberichterstattungsfunktionen der Aufgabe mit den Abbruch- und Status zu verknüpfen Funktionen zur Erstellung der entsprechenden Windows-Runtime-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5f04f-257">For asynchronous actions and operations that support cancellation or progress reporting, use the [**AsyncInfo**](/dotnet/api/system.runtime.interopservices.windowsruntime) class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</span></span> <span data-ttu-id="5f04f-258">Ein Beispiel, das sowohl die Abbruch- als auch die Fortschrittsberichterstattung unterstützt, finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-258">For an example that supports both cancellation and progress reporting, see [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md).</span></span>

<span data-ttu-id="5f04f-259">Beachten Sie, dass Sie die Methoden der **AsyncInfo** -Klasse verwenden können, auch wenn die asynchrone Methode nicht Abbruch oder Fortschrittsberichterstattung unterstützt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-259">Note that you can use the methods of the **AsyncInfo** class even if your asynchronous method doesn't support cancellation or progress reporting.</span></span> <span data-ttu-id="5f04f-260">Wenn Sie eine Visual Basic-Lambda-Funktion oder eine anonyme C#-Methode verwenden, geben Sie keine Parameter für das Token und [\*\*IProgress&lt;T&gt; \*\*](https://msdn.microsoft.com/library/hh138298.aspx) Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5f04f-260">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and [**IProgress&lt;T&gt;**](https://msdn.microsoft.com/library/hh138298.aspx) interface.</span></span> <span data-ttu-id="5f04f-261">Wenn Sie eine C#-Lambda-Funktion verwenden, geben Sie einen Tokenparameter an, aber ignorieren Sie ihn.</span><span class="sxs-lookup"><span data-stu-id="5f04f-261">If you use a C# lambda function, supply a token parameter but ignore it.</span></span> <span data-ttu-id="5f04f-262">Die vorherigen Beispiel, in dem die asasyncoperation&lt;TResult&gt; Methode sieht wie folgt aus, bei der Verwendung der [**AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;**](https://msdn.microsoft.com/library/hh779740.aspx))-Methode stattdessen die Überladung.</span><span class="sxs-lookup"><span data-stu-id="5f04f-262">The previous example, which used the AsAsyncOperation&lt;TResult&gt; method, looks like this when you use the [**AsyncInfo.Run&lt;TResult&gt;(Func&lt;CancellationToken, Task&lt;TResult&gt;&gt;**](https://msdn.microsoft.com/library/hh779740.aspx)) method overload instead.</span></span>

```csharp
public static IAsyncOperation<IList<string>> DownloadAsStringsAsync(string id)
{
    return AsyncInfo.Run<IList<string>>(async (token) =>
    {
        var data = await DownloadDataAsync(id);
        return ExtractStrings(data);
    });
}
```

```vb
Public Shared Function DownloadAsStringsAsync(ByVal id As String) _
    As IAsyncOperation(Of IList(Of String))

    Return AsyncInfo.Run(Of IList(Of String))(
        Async Function()
            Dim data = Await DownloadDataAsync(id)
            Return ExtractStrings(data)
        End Function)
End Function
```

<span data-ttu-id="5f04f-263">Wenn Sie eine asynchrone Methode, die optional die Abbruch- oder Fortschrittsberichterstattung unterstützt erstellen, sollten Sie die Überladung, die Parameter für ein Abbruchtoken hinzufügen oder die \*\*IProgress&lt;T&gt; \*\* Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="5f04f-263">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the **IProgress&lt;T&gt;** interface.</span></span>

## <a name="throwing-exceptions"></a><span data-ttu-id="5f04f-264">Auslösen von Ausnahmen</span><span class="sxs-lookup"><span data-stu-id="5f04f-264">Throwing exceptions</span></span>

<span data-ttu-id="5f04f-265">Sie können jeden Ausnahmetyp auslösen, der in .NET für Windows-Apps enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-265">You can throw any exception type that is included in the .NET for Windows apps.</span></span> <span data-ttu-id="5f04f-266">Sie können keine eigenen öffentlichen Ausnahmetypen in einer Komponente für Windows-Runtime deklarieren, aber Sie können nicht öffentliche Typen deklarieren und auslösen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-266">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</span></span>

<span data-ttu-id="5f04f-267">Wenn die Komponente die Ausnahme nicht behandelt, wird eine entsprechende Ausnahme im Code ausgelöst, der die Komponente aufgerufen hat.</span><span class="sxs-lookup"><span data-stu-id="5f04f-267">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</span></span> <span data-ttu-id="5f04f-268">Die Unterstützung der Windows-Runtime durch die aufrufende Sprache bestimmt, wie die Ausnahme dem Aufrufer dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="5f04f-268">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</span></span>

-   <span data-ttu-id="5f04f-269">In JavaScript erscheint die Ausnahme als Objekt, in dem die Ausnahmemeldung durch eine Stapelüberwachung ersetzt ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-269">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</span></span> <span data-ttu-id="5f04f-270">Wenn Sie Ihre App in Visual Studio debuggen, wird der Originaltext der Meldung im Ausnahmedialogfeld des Debuggers unter „WinRT Information" angezeigt.</span><span class="sxs-lookup"><span data-stu-id="5f04f-270">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</span></span> <span data-ttu-id="5f04f-271">Sie können mit JavaScript-Code nicht auf den Originaltext der Meldung zugreifen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-271">You can't access the original message text from JavaScript code.</span></span>

    > <span data-ttu-id="5f04f-272">**Tipp**.</span><span class="sxs-lookup"><span data-stu-id="5f04f-272">**Tip**.</span></span><span data-ttu-id="5f04f-273">Momentan enthält die Stapelüberwachung zwar den verwalteten Ausnahmetyp, aber es ist nicht empfehlenswert, diese zu untersuchen, um den Ausnahmetyp zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="5f04f-273">Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</span></span> <span data-ttu-id="5f04f-274">Verwenden Sie stattdessen einen HRESULT-Wert, wie weiter unten in diesem Abschnitt beschrieben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-274">Instead, use an HRESULT value as described later in this section.</span></span>

-   <span data-ttu-id="5f04f-275">In C++ erscheint die Ausnahme als Plattformausnahme.</span><span class="sxs-lookup"><span data-stu-id="5f04f-275">In C++, the exception appears as a platform exception.</span></span> <span data-ttu-id="5f04f-276">Wenn der verwalteten Ausnahme HResult-Eigenschaft auf das Ergebnis der einer bestimmten plattformausnahme zugeordnet werden kann, wird die jeweiligen Ausnahme verwendet. Andernfalls wird eine [**Platform:: COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) -Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5f04f-276">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a [**Platform::COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx) exception is thrown.</span></span> <span data-ttu-id="5f04f-277">Der Meldungstext der verwalteten Ausnahme ist für C++-Code nicht verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5f04f-277">The message text of the managed exception is not available to C++ code.</span></span> <span data-ttu-id="5f04f-278">Wenn eine bestimmte Plattformausnahme ausgelöst wurde, erscheint der Meldungstext für diesen Ausnahmetyp. Andernfalls wird kein Meldungstext ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="5f04f-278">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</span></span> <span data-ttu-id="5f04f-279">Siehe [Ausnahmen (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span><span class="sxs-lookup"><span data-stu-id="5f04f-279">See [Exceptions (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx).</span></span>
-   <span data-ttu-id="5f04f-280">In C# oder Visual Basic ist die Ausnahme eine normale verwaltete Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="5f04f-280">In C# or Visual Basic, the exception is a normal managed exception.</span></span>

<span data-ttu-id="5f04f-281">Wenn Sie in Ihrer Komponente eine Ausnahme auslösen, sollten Sie einen nicht öffentlichen Ausnahmetyp verwenden, dessen HResult-Eigenschaftswert speziell für Ihre Komponente gilt, damit die Ausnahme leichter von einem JavaScript- oder C++-Aufrufer verwaltet werden kann.</span><span class="sxs-lookup"><span data-stu-id="5f04f-281">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</span></span> <span data-ttu-id="5f04f-282">Das Ergebnis ist für einen JavaScript-Aufrufer über die Eigenschaft des Ausnahmeobjekts Anzahl, und ein C++-Aufrufer über die Eigenschaft [**COMException**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5f04f-282">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the [**COMException::HResult**](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx) property.</span></span>

> [!NOTE]
> <span data-ttu-id="5f04f-283">Verwenden Sie einen negativen Wert für HRESULT.</span><span class="sxs-lookup"><span data-stu-id="5f04f-283">Use a negative value for your HRESULT.</span></span> <span data-ttu-id="5f04f-284">Ein positiver Wert wird als Erfolg interpretiert und im JavaScript- oder C++-Aufrufer wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="5f04f-284">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</span></span>

## <a name="declaring-and-raising-events"></a><span data-ttu-id="5f04f-285">Deklarieren und Auslösen von Ereignissen</span><span class="sxs-lookup"><span data-stu-id="5f04f-285">Declaring and raising events</span></span>

<span data-ttu-id="5f04f-286">Wenn Sie einen Typ deklarieren, um die Daten für das Ereignis aufzunehmen, leiten Sie diesen von „Object“ und nicht von „EventArgs“ ab, da „EventArgs“ kein Windows-Runtime-Typ ist.</span><span class="sxs-lookup"><span data-stu-id="5f04f-286">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</span></span> <span data-ttu-id="5f04f-287">Verwenden Sie [\*\*EventHandler&lt;TEventArgs&gt; \*\*](https://msdn.microsoft.com/library/db0etb8x.aspx) als Typ des Ereignisses, und verwenden Sie den Ereignisargumenttyp als generisches Typargument.</span><span class="sxs-lookup"><span data-stu-id="5f04f-287">Use [**EventHandler&lt;TEventArgs&gt;**](https://msdn.microsoft.com/library/db0etb8x.aspx) as the type of the event, and use your event argument type as the generic type argument.</span></span> <span data-ttu-id="5f04f-288">Lösen Sie das Ereignis genauso wie in einer .NET Framework-Anwendung aus.</span><span class="sxs-lookup"><span data-stu-id="5f04f-288">Raise the event just as you would in a .NET Framework application.</span></span>

<span data-ttu-id="5f04f-289">Wenn Ihre Komponente für Windows-Runtime von JavaScript oder C++ verwendet wird, folgt das Ereignis dem Windows-Runtime-Ereignismuster, das diese Sprachen erwarten.</span><span class="sxs-lookup"><span data-stu-id="5f04f-289">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</span></span> <span data-ttu-id="5f04f-290">Wenn Sie die Komponente in C# oder Visual Basic verwenden, erscheint das Ereignis als normales .NET Framework-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="5f04f-290">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</span></span> <span data-ttu-id="5f04f-291">Ein Beispiel finden Sie unter [Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente in C# oder Visual Basic und Aufrufen dieser Komponente über JavaScript]().</span><span class="sxs-lookup"><span data-stu-id="5f04f-291">An example is provided in [Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript]().</span></span>

<span data-ttu-id="5f04f-292">Wenn Sie benutzerdefinierte Ereignisaccessoren implementieren (in Visual Basic ein Ereignis mit dem Schlüsselwort **Custom** deklarieren), müssen Sie in der Implementierung das Windows-Runtime-Ereignismuster verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-292">If you implement custom event accessors (declare an event with the **Custom** keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</span></span> <span data-ttu-id="5f04f-293">Siehe [Benutzerdefinierte Ereignisse und Ereignisaccessoren in Komponenten für Windows-Runtime](custom-events-and-event-accessors-in-windows-runtime-components.md).</span><span class="sxs-lookup"><span data-stu-id="5f04f-293">See [Custom events and event accessors in Windows Runtime Components](custom-events-and-event-accessors-in-windows-runtime-components.md).</span></span> <span data-ttu-id="5f04f-294">Beachten Sie, dass das Ereignis auch dann als einfaches .NET Framework-Ereignis erscheint, wenn Sie C#- oder Visual Basic-Code verwenden.</span><span class="sxs-lookup"><span data-stu-id="5f04f-294">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</span></span>

## <a name="next-steps"></a><span data-ttu-id="5f04f-295">Nächste Schritte</span><span class="sxs-lookup"><span data-stu-id="5f04f-295">Next steps</span></span>

<span data-ttu-id="5f04f-296">Nachdem Sie eine Komponente für Windows-Runtime für eigene Zwecke erstellt haben, stellen Sie möglicherweise fest, dass die Funktionen, die diese kapselt, für andere Entwickler nützlich sind.</span><span class="sxs-lookup"><span data-stu-id="5f04f-296">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</span></span> <span data-ttu-id="5f04f-297">Sie haben zwei Optionen, um eine Komponente für die Verteilung an andere Entwickler zu packen.</span><span class="sxs-lookup"><span data-stu-id="5f04f-297">You have two options for packaging a component for distribution to other developers.</span></span> <span data-ttu-id="5f04f-298">Siehe [Verteilen einer verwalteten Komponente für Windows-Runtime](https://msdn.microsoft.com/library/jj614475.aspx).</span><span class="sxs-lookup"><span data-stu-id="5f04f-298">See [Distributing a managed Windows Runtime component](https://msdn.microsoft.com/library/jj614475.aspx).</span></span>

<span data-ttu-id="5f04f-299">Weitere Informationen zu Visual Basic- und C#-Sprachfunktionen und zur .NET Framework-Unterstützung für die Windows-Runtime finden Sie unter [Visual Basic- und C#-Programmiersprachenreferenz](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span><span class="sxs-lookup"><span data-stu-id="5f04f-299">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see [Visual Basic and C# language reference](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx).</span></span>

## <a name="related-topics"></a><span data-ttu-id="5f04f-300">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="5f04f-300">Related topics</span></span>
* [<span data-ttu-id="5f04f-301">.NET für UWP-Apps</span><span class="sxs-lookup"><span data-stu-id="5f04f-301">.NET for UWP apps</span></span>](https://msdn.microsoft.com/library/windows/apps/mt185501)
* [<span data-ttu-id="5f04f-302">Exemplarische Vorgehensweise: Erstellen einer einfachen Komponente für Windows-Runtime und Aufrufen der Komponente über JavaScript</span><span class="sxs-lookup"><span data-stu-id="5f04f-302">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</span></span>](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)
