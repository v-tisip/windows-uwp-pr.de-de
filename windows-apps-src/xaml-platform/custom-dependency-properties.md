---
author: jwmsft
description: Hier wird erläutert, wie Sie benutzerdefinierte Abhängigkeitseigenschaften für eine Windows-Runtime-App mit C++, C# oder Visual Basic definieren und implementieren können.
title: Benutzerdefinierte Abhängigkeitseigenschaften
ms.assetid: 5ADF7935-F2CF-4BB6-B1A5-F535C2ED8EF8
ms.author: jimwalk
ms.date: 07/12/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows10, UWP
ms.localizationpriority: medium
dev_langs:
- csharp
- vb
- cppwinrt
- cpp
ms.openlocfilehash: ddeccfe4c5e198afd77eaa4a81fc017543291ba1
ms.sourcegitcommit: 5dda01da4702cbc49c799c750efe0e430b699502
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 09/21/2018
ms.locfileid: "4113172"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="92cd4-104">Benutzerdefinierte Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="92cd4-104">Custom dependency properties</span></span>

<span data-ttu-id="92cd4-105">Hier wird erläutert, wie Sie eigene Abhängigkeitseigenschaften für eine Windows-Runtime-App mit C++, C# oder Visual Basic verwenden können.</span><span class="sxs-lookup"><span data-stu-id="92cd4-105">Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</span></span> <span data-ttu-id="92cd4-106">Wir zählen mögliche Gründen für die Erstellung benutzerdefinierter Abhängigkeitseigenschaften durch App-Entwickler und Komponentenautoren auf.</span><span class="sxs-lookup"><span data-stu-id="92cd4-106">We list reasons why app developers and component authors might want to create custom dependency properties.</span></span> <span data-ttu-id="92cd4-107">Des Weiteren beschreiben wir die Implementierungsschritte für eine benutzerdefinierte Abhängigkeitseigenschaft sowie einige bewährte Methoden, die die Leistung, Benutzerfreundlichkeit und Vielseitigkeit der Abhängigkeitseigenschaft verbessern.</span><span class="sxs-lookup"><span data-stu-id="92cd4-107">We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="92cd4-108">Voraussetzungen</span><span class="sxs-lookup"><span data-stu-id="92cd4-108">Prerequisites</span></span>

<span data-ttu-id="92cd4-109">Wir gehen davon aus, dass Sie die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) bereits gelesen haben und dass Sie Abhängigkeitseigenschaften aus der Perspektive eines Konsumenten von bestehenden Abhängigkeitseigenschaften verstehen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-109">We assume that you have read the [Dependency properties overview](dependency-properties-overview.md) and that you understand dependency properties from the perspective of a consumer of existing dependency properties.</span></span> <span data-ttu-id="92cd4-110">Für ein besseres Verständnis der in diesem Thema aufgeführten Beispiele sollten Sie XAML verstehen und wissen, wie eine einfache Windows-Runtime-App mit C++, C# oder Visual Basic geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-110">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</span></span>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="92cd4-111">Was ist eine Abhängigkeitseigenschaft?</span><span class="sxs-lookup"><span data-stu-id="92cd4-111">What is a dependency property?</span></span>

<span data-ttu-id="92cd4-112">Um Formate, Datenbindung, Animationen und Standardwerte für eine Eigenschaft zu unterstützen, sollte sie als Abhängigkeitseigenschaft implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-112">To support styling, data binding, animations, and default values for a property, then it should be implemented as a dependency property.</span></span> <span data-ttu-id="92cd4-113">Werte der Abhängigkeitseigenschaft werden nicht als Felder in der Klasse gespeichert, sondern sie werden vom XAML-Framework gespeichert und mit einem Schlüssel verwiesen, der abgerufen wird, wenn die Eigenschaft durch Aufruf der [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Methode im Windows-Runtime-Eigenschaftensystem registriert wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-113">Dependency property values are not stored as fields on the class, they are stored by the xaml framework, and are referenced using a key, which is retrieved when the property is registered with the Windows Runtime property system by calling the [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method.</span></span>   <span data-ttu-id="92cd4-114">Abhängigkeitseigenschaften können nur von Typen verwendet werden, die von [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) abgeleitet sind.</span><span class="sxs-lookup"><span data-stu-id="92cd4-114">Dependency properties can be used only by types deriving from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356).</span></span> <span data-ttu-id="92cd4-115">Das **DependencyObject** befindet sich jedoch ziemlich weit oben in der Klassenhierarchie, sodass die Mehrzahl der Klassen, die für die UI- und Darstellungsunterstützung bestimmt sind, Abhängigkeitseigenschaften unterstützen können.</span><span class="sxs-lookup"><span data-stu-id="92cd4-115">But **DependencyObject** is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.</span></span> <span data-ttu-id="92cd4-116">Weitere Informationen zu Abhängigkeitseigenschaften und für die in dieser Dokumentation verwendeten Begriffe und Konventionen finden Sie unter [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="92cd4-116">For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see [Dependency properties overview](dependency-properties-overview.md).</span></span>

<span data-ttu-id="92cd4-117">Beispiele für Abhängigkeitseigenschaften in der Windows-Runtime sind: [**Control.Background**](https://msdn.microsoft.com/library/windows/apps/br209395), [**FrameworkElement.Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width), [**TextBox.Text**](https://msdn.microsoft.com/library/windows/apps/br209702) und viele weitere.</span><span class="sxs-lookup"><span data-stu-id="92cd4-117">Examples of dependency properties in the Windows Runtime are: [**Control.Background**](https://msdn.microsoft.com/library/windows/apps/br209395), [**FrameworkElement.Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width), and [**TextBox.Text**](https://msdn.microsoft.com/library/windows/apps/br209702), among many others.</span></span>

<span data-ttu-id="92cd4-118">Gemäß der Konvention besitzt jede durch eine Klasse verfügbar gemachte Abhängigkeitseigenschaft eine entsprechende **public static readonly**-Eigenschaft des Typs [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362), die für die gleiche Klasse verfügbar gemacht wird, die den Bezeichner für die Abhängigkeitseigenschaft bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-118">Convention is that each dependency property exposed by a class has a corresponding **public static readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) that is exposed on that same class the provides the identifier for the dependency property.</span></span> <span data-ttu-id="92cd4-119">Für die Benennung des Bezeichners wird folgende Konvention verwendet: der Name der Abhängigkeitseigenschaft mit der am Namensende angehängten Zeichenfolge „Property“.</span><span class="sxs-lookup"><span data-stu-id="92cd4-119">The identifier's name follows this convention: the name of the dependency property, with the string "Property" added to the end of the name.</span></span> <span data-ttu-id="92cd4-120">Beispielsweise ist der **DependencyProperty**-Bezeichner für die Eigenschaft **Control.Background** [**Control.BackgroundProperty**](https://msdn.microsoft.com/library/windows/apps/br209396).</span><span class="sxs-lookup"><span data-stu-id="92cd4-120">For example, the corresponding **DependencyProperty** identifier for the **Control.Background** property is [**Control.BackgroundProperty**](https://msdn.microsoft.com/library/windows/apps/br209396).</span></span> <span data-ttu-id="92cd4-121">Der Bezeichner speichert die Informationen zur Abhängigkeitseigenschaft, die bei der Registrierung gelten, und kann anschließend für andere Vorgänge verwendet werden, welche die Abhängigkeitseigenschaft betreffen, wie z. B. der Aufruf von [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361).</span><span class="sxs-lookup"><span data-stu-id="92cd4-121">The identifier stores the information about the dependency property as it was registered, and can then be used for other operations involving the dependency property, such as calling [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361).</span></span>

## <a name="property-wrappers"></a><span data-ttu-id="92cd4-122">Eigenschaftenwrapper</span><span class="sxs-lookup"><span data-stu-id="92cd4-122">Property wrappers</span></span>

<span data-ttu-id="92cd4-123">Abhängigkeitseigenschaften haben für gewöhnlich eine Wrapper-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="92cd4-123">Dependency properties typically have a wrapper implementation.</span></span> <span data-ttu-id="92cd4-124">Ohne den Wrapper können die Eigenschaften nur durch die Verwendung der Methoden der Abhängigkeitseigenschafts-Hilfsprogramme [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) und [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) sowie durch die Nutzung des Bezeichners als Parameter abgerufen oder festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-124">Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and to pass the identifier to them as a parameter.</span></span> <span data-ttu-id="92cd4-125">Dies handelt es sich um eine ziemlich ungewöhnliche Verwendung für eine offensichtliche Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="92cd4-125">This is a rather unnatural usage for something that is ostensibly a property.</span></span> <span data-ttu-id="92cd4-126">Mit dem Wrapper können Ihr Code und jegliche anderen Codes, die auf die Abhängigkeitseigenschaft verweisen, eine unkomplizierte, für die von Ihnen verwendete Sprache natürliche Syntax für Objekteigenschaften verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-126">But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.</span></span>

<span data-ttu-id="92cd4-127">Wenn Sie eine benutzerdefinierte Abhängigkeitseigenschaft selbst implementieren und diese veröffentlichen und leicht auffindbar machen möchten, definieren Sie auch die Eigenschaftenwrapper.</span><span class="sxs-lookup"><span data-stu-id="92cd4-127">If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.</span></span> <span data-ttu-id="92cd4-128">Eigenschaftenwrapper sind des Weiteren nützlich für die Berichterstattung über grundlegende Informationen der Abhängigkeitseigenschaft für Betrachtungen und statische Analysen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-128">The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.</span></span> <span data-ttu-id="92cd4-129">Der Wrapper befindet sich insbesondere dort, wo Sie Attribute platzieren, beispielsweise [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011).</span><span class="sxs-lookup"><span data-stu-id="92cd4-129">Specifically, the wrapper is where you place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011).</span></span>

## <a name="when-to-implement-a-property-as-a-dependency-property"></a><span data-ttu-id="92cd4-130">Wann sollten Sie eine Eigenschaft als Abhängigkeitseigenschaft implementieren?</span><span class="sxs-lookup"><span data-stu-id="92cd4-130">When to implement a property as a dependency property</span></span>

<span data-ttu-id="92cd4-131">Wenn Sie eine öffentliche Lese-/Schreibeigenschaft in eine Klasse implementieren und die Klasse von [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) abgeleitet ist, können Sie Ihre Eigenschaft als Abhängigkeitseigenschaft nutzen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-131">Whenever you implement a public read/write property on a class, as long as your class derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), you have the option to make your property work as a dependency property.</span></span> <span data-ttu-id="92cd4-132">In einigen Fällen ist die typische Methode, Ihre Eigenschaft mit einem privaten Feld abzusichern, angemessen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-132">Sometimes the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="92cd4-133">Das Definieren Ihrer benutzerdefinierten Eigenschaft als Abhängigkeitseigenschaft ist nicht immer notwendig oder angemessen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-133">Defining your custom property as a dependency property is not always necessary or appropriate.</span></span> <span data-ttu-id="92cd4-134">Die Entscheidung hängt von den Szenarien ab, die Ihre Eigenschaft unterstützen soll.</span><span class="sxs-lookup"><span data-stu-id="92cd4-134">The choice will depend on the scenarios that you intend your property to support.</span></span>

<span data-ttu-id="92cd4-135">Sie können Ihre Eigenschaft als Abhängigkeitseigenschaft implementieren, wenn diese mindestens eine der folgenden Eigenschaften der Windows-Runtime oder von Windows-Runtime-Apps unterstützen soll:</span><span class="sxs-lookup"><span data-stu-id="92cd4-135">You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:</span></span>

- <span data-ttu-id="92cd4-136">Festlegen der Eigenschaft über einen [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849)</span><span class="sxs-lookup"><span data-stu-id="92cd4-136">Setting the property through a [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849)</span></span>
- <span data-ttu-id="92cd4-137">Funktion als gültige Zieleigenschaft für Datenbindung mit [**{Binding}**](binding-markup-extension.md)</span><span class="sxs-lookup"><span data-stu-id="92cd4-137">Acting as valid target property for data binding with [**{Binding}**](binding-markup-extension.md)</span></span>
- <span data-ttu-id="92cd4-138">Unterstützung animierter Werte durch ein [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490)</span><span class="sxs-lookup"><span data-stu-id="92cd4-138">Supporting animated values through a [**Storyboard**](https://msdn.microsoft.com/library/windows/apps/br210490)</span></span>
- <span data-ttu-id="92cd4-139">Melden von Änderungen des Eigenschaftswerts durch:</span><span class="sxs-lookup"><span data-stu-id="92cd4-139">Reporting when the value of the property has been changed by:</span></span>
  - <span data-ttu-id="92cd4-140">Vom Eigenschaftensystem selbst durchgeführte Aktionen</span><span class="sxs-lookup"><span data-stu-id="92cd4-140">Actions taken by the property system itself</span></span>
  - <span data-ttu-id="92cd4-141">Die Umgebung</span><span class="sxs-lookup"><span data-stu-id="92cd4-141">The environment</span></span>
  - <span data-ttu-id="92cd4-142">Benutzeraktionen</span><span class="sxs-lookup"><span data-stu-id="92cd4-142">User actions</span></span>
  - <span data-ttu-id="92cd4-143">Lese- und Schreibstile</span><span class="sxs-lookup"><span data-stu-id="92cd4-143">Reading and writing styles</span></span>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="92cd4-144">Prüfliste für die Definition einer Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="92cd4-144">Checklist for defining a dependency property</span></span>

<span data-ttu-id="92cd4-145">Das Definieren einer Abhängigkeitseigenschaft umfasst mehrere Konzepte.</span><span class="sxs-lookup"><span data-stu-id="92cd4-145">Defining a dependency property can be thought of as a set of concepts.</span></span> <span data-ttu-id="92cd4-146">Bei diesen Begriffen handelt es sich nicht unbedingt um einzelne Schritte, da einige Schritte bei der Implementierung im Code in einzelnen Codezeilen zusammengefasst werden:</span><span class="sxs-lookup"><span data-stu-id="92cd4-146">These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.</span></span> <span data-ttu-id="92cd4-147">Diese Liste verschafft Ihnen einen schnellen Überblick..</span><span class="sxs-lookup"><span data-stu-id="92cd4-147">This list gives just a quick overview.</span></span> <span data-ttu-id="92cd4-148">Wir werden später noch genauer auf jeden Begriff eingehen und Ihnen Beispielcode in verschiedenen Sprachen zeigen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-148">We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.</span></span>

- <span data-ttu-id="92cd4-149">Registrieren Sie den Eigenschaftennamen im Eigenschaftensystem (durch Aufruf von [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)), indem Sie einen Besitzertyp und den Typ des Eigenschaftswerts angeben.</span><span class="sxs-lookup"><span data-stu-id="92cd4-149">Register the property name with the property system (call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)), specifying an owner type and the type of the property value.</span></span>
  - <span data-ttu-id="92cd4-150">Es gibt auch einen erforderlichen Parameter für [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829), der Eigenschaftenmetadaten benötigt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-150">There's a required parameter for [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) that expects property metadata.</span></span> <span data-ttu-id="92cd4-151">Geben Sie **null** dafür an, oder wenn Sie PropertyChanged-Verhalten oder einen metadatenbasierten Standardwert haben möchten, der durch den Aufruf von [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) wiederhergestellt werden kann, geben Sie eine Instanz von [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.propertymetadata) an.</span><span class="sxs-lookup"><span data-stu-id="92cd4-151">Specify **null** for this, or if you want property-changed behavior, or a metadata-based default value that can be restored by calling [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357), specify an instance of [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.propertymetadata).</span></span>
- <span data-ttu-id="92cd4-152">Definieren Sie einen [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362)-Bezeichner als ein **public static readonly**-Eigenschaftenmember des Besitzertyps.</span><span class="sxs-lookup"><span data-stu-id="92cd4-152">Define a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier as a **public static readonly** property member on the owner type.</span></span>
- <span data-ttu-id="92cd4-153">Definieren Sie eine Wrappereigenschaft nach dem Accessor-Modell für Eigenschaften, das in der von Ihnen implementierten Sprache verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-153">Define a wrapper property, following the property accessor model that's used in the language you are implementing.</span></span> <span data-ttu-id="92cd4-154">Der Name der Wrappereigenschaft muss mit der Zeichenfolge *string* übereinstimmen, die Sie in [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) verwendet haben.</span><span class="sxs-lookup"><span data-stu-id="92cd4-154">The wrapper property name should match the *name* string that you used in [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829).</span></span> <span data-ttu-id="92cd4-155">Implementieren Sie die **get**- und **set**-Accessoren, um den Wrapper durch den Aufruf von [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) und [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) und die Übergabe des Bezeichners Ihrer Eigenschaft als Parameter mit der von diesem umschlossenen Abhängigkeitseigenschaft zu verbinden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-155">Implement the **get** and **set** accessors to connect the wrapper with the dependency property that it wraps, by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and passing your own property's identifier as a parameter.</span></span>
- <span data-ttu-id="92cd4-156">(Optional) Platzieren Sie Attribute wie [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011) auf dem Wrapper.</span><span class="sxs-lookup"><span data-stu-id="92cd4-156">(Optional) Place attributes such as [**ContentPropertyAttribute**](https://msdn.microsoft.com/library/windows/apps/br228011) on the wrapper.</span></span>

> [!NOTE]
> <span data-ttu-id="92cd4-157">Wenn Sie eine benutzerdefinierte angefügte Eigenschaft definieren, wird der Wrapper für gewöhnlich weggelassen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-157">If you are defining a custom attached property, you generally omit the wrapper.</span></span> <span data-ttu-id="92cd4-158">Stattdessen verwenden Sie einen anderen Accessor-Stil, den ein XAML-Prozessor verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="92cd4-158">Instead, you write a different style of accessor that a XAML processor can use.</span></span> <span data-ttu-id="92cd4-159">Siehe [Benutzerdefinierte angefügte Eigenschaften](custom-attached-properties.md).</span><span class="sxs-lookup"><span data-stu-id="92cd4-159">See [Custom attached properties](custom-attached-properties.md).</span></span> 

## <a name="registering-the-property"></a><span data-ttu-id="92cd4-160">Registrieren der Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="92cd4-160">Registering the property</span></span>

<span data-ttu-id="92cd4-161">Damit Ihre Eigenschaft zu einer Abhängigkeitseigenschaft wird, müssen Sie die Eigenschaft in einem Eigenschaftenspeicher registrieren, der vom Windows-Runtime-Eigenschaftensystem verwaltet wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-161">For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.</span></span>  <span data-ttu-id="92cd4-162">Rufen Sie für die Registrierung der Eigenschaft die [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="92cd4-162">To register the property, you call the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method.</span></span>

<span data-ttu-id="92cd4-163">Im Fall von Microsoft .NET-Sprachen (C# und Microsoft Visual Basic) rufen Sie [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) im Text Ihrer Klasse auf (innerhalb der Klasse, jedoch außerhalb der Memberdefinitionen).</span><span class="sxs-lookup"><span data-stu-id="92cd4-163">For Microsoft .NET languages (C# and Microsoft Visual Basic) you call [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) within the body of your class (inside the class, but outside any member definitions).</span></span> <span data-ttu-id="92cd4-164">Der Bezeichner wird vom [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Methodenaufruf als Rückgabewert bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-164">The identifier is provided by the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) method call, as the return value.</span></span> <span data-ttu-id="92cd4-165">Der [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Aufruf erfolgt in der Regel als statischer Konstruktor oder als Teil der Initialisierung einer **public static readonly**-Eigenschaft des Typs [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) als Teil der Klasse.</span><span class="sxs-lookup"><span data-stu-id="92cd4-165">The [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is typically made as a static constructor or as part of the initialization of a **public static readonly** property of type [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) as part of your class.</span></span> <span data-ttu-id="92cd4-166">Diese Eigenschaft macht den Bezeichner für Ihre Abhängigkeitseigenschaft verfügbar.</span><span class="sxs-lookup"><span data-stu-id="92cd4-166">This property exposes the identifier for your dependency property.</span></span> <span data-ttu-id="92cd4-167">Im Anschluss finden Sie Beispiele für den [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Aufruf.</span><span class="sxs-lookup"><span data-stu-id="92cd4-167">Here are examples of the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call.</span></span>

> [!NOTE]
> <span data-ttu-id="92cd4-168">Registrieren der Abhängigkeitseigenschaft als Teil des Bezeichners Eigenschaftsdefinition normalen Implementierung ist, aber Sie können eine Abhängigkeitseigenschaft auch im statischen Konstruktor Klasse registrieren.</span><span class="sxs-lookup"><span data-stu-id="92cd4-168">Registering the dependency property as part of the identifier property definition is the typical implementation, but you can also register a dependency property in the class static constructor.</span></span> <span data-ttu-id="92cd4-169">Dieser Ansatz eignet sich ggf., wenn Sie mehr als eine Codezeile benötigen, um die Abhängigkeitseigenschaft zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="92cd4-169">This approach may make sense if you need more than one line of code to initialize the dependency property.</span></span>

<span data-ttu-id="92cd4-170">Für C++ / CX, verfügen Sie über Optionen für wie die Implementierung zwischen der Header- und Codedatei aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-170">For C++/CX, you have options for how you split the implementation between the header and the code file.</span></span> <span data-ttu-id="92cd4-171">In der Regel wird der Bezeichner selbst als **public static**-Eigenschaft in der Kopfzeile mit einer **get**-Implementierung, jedoch ohne **set**-Implementierung deklariert.</span><span class="sxs-lookup"><span data-stu-id="92cd4-171">The typical split is to declare the identifier itself as **public static** property in the header, with a **get** implementation but no **set**.</span></span> <span data-ttu-id="92cd4-172">Die **get**-Implementierung bezieht sich auf ein privates Feld, das eine nicht initialisierte [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362)-Instanz ist.</span><span class="sxs-lookup"><span data-stu-id="92cd4-172">The **get** implementation refers to a private field, which is an uninitialized [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) instance.</span></span> <span data-ttu-id="92cd4-173">Sie können darüber hinaus die Wrapper und die **get**- und **set**-Implementierungen des Wrappers deklarieren.</span><span class="sxs-lookup"><span data-stu-id="92cd4-173">You can also declare the wrappers and the **get** and **set** implementations of the wrapper.</span></span> <span data-ttu-id="92cd4-174">In diesem Fall enthält der Wrapper eine minimale Implementierung.</span><span class="sxs-lookup"><span data-stu-id="92cd4-174">In this case the header includes some minimal implementation.</span></span> <span data-ttu-id="92cd4-175">Wenn der Wrapper eine Zuordnung zur Windows-Runtime benötigt, führen Sie die Zuordnung auch in der Kopfzeile durch.</span><span class="sxs-lookup"><span data-stu-id="92cd4-175">If the wrapper needs Windows Runtime attribution, attribute in the header too.</span></span> <span data-ttu-id="92cd4-176">Platzieren Sie den [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Aufruf in die Codedatei innerhalb einer Hilfsfunktion, die nur bei der ersten Initialisierung der App ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-176">Put the [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call in the code file, within a helper function that only gets run when the app initializes the first time.</span></span> <span data-ttu-id="92cd4-177">Verwenden Sie den Rückgabewert von **Register**, um die statischen, jedoch nicht initialisierten Bezeichner zu füllen, die Sie in der Kopfzeile deklariert haben und zunächst im Stammbereich der Implementierungsdatei auf **nullptr** festgelegt haben.</span><span class="sxs-lookup"><span data-stu-id="92cd4-177">Use the return value of **Register** to fill the static but uninitialized identifiers that you declared in the header, which you initially set to **nullptr** at the root scope of the implementation file.</span></span>

```csharp
public static readonly DependencyProperty LabelProperty = DependencyProperty.Register(
  "Label",
  typeof(String),
  typeof(ImageWithLabelControl),
  new PropertyMetadata(null)
);
```

```vb
Public Shared ReadOnly LabelProperty As DependencyProperty = 
    DependencyProperty.Register("Label", 
      GetType(String), 
      GetType(ImageWithLabelControl), 
      New PropertyMetadata(Nothing))
```

```cppwinrt
// ImageWithLabelControl.idl
namespace ImageWithLabelControlApp
{
    runtimeclass ImageWithLabelControl : Windows.UI.Xaml.Controls.Control
    {
        ImageWithLabelControl();
        static Windows.UI.Xaml.DependencyProperty LabelProperty{ get; };
        String Label;
    }
}

// ImageWithLabelControl.h
...
private:
    static Windows::UI::Xaml::DependencyProperty m_labelProperty;
...

// ImageWithLabelControl.cpp
...
Windows::UI::Xaml::DependencyProperty ImageWithLabelControl::m_labelProperty =
    Windows::UI::Xaml::DependencyProperty::Register(
        L"Label",
        winrt::xaml_typename<winrt::hstring>(),
        winrt::xaml_typename<ImageWithLabelControlApp::ImageWithLabelControl>(),
        Windows::UI::Xaml::PropertyMetadata{ nullptr }
);
...
```

```cpp
//.h file
//using namespace Windows::UI::Xaml::Controls;
//using namespace Windows::UI::Xaml::Interop;
//using namespace Windows::UI::Xaml;
//using namespace Platform;

public ref class ImageWithLabelControl sealed : public Control
{
private:
    static DependencyProperty^ _LabelProperty;
...
public:
    static void RegisterDependencyProperties();
    static property DependencyProperty^ LabelProperty
    {
        DependencyProperty^ get() {return _LabelProperty;}
    }
...
};

//.cpp file
using namespace Windows::UI::Xaml;
using namespace Windows::UI::Xaml.Interop;

DependencyProperty^ ImageWithLabelControl::_LabelProperty = nullptr;

// This function is called from the App constructor in App.xaml.cpp
// to register the properties
void ImageWithLabelControl::RegisterDependencyProperties()
{ 
    if (_LabelProperty == nullptr)
    { 
        _LabelProperty = DependencyProperty::Register(
          "Label", Platform::String::typeid, ImageWithLabelControl::typeid, nullptr);
    } 
}
```

> [!NOTE]
> <span data-ttu-id="92cd4-178">Für die C++ / CX-code, den Grund, warum Sie ein privates Feld und eine öffentliche Eigenschaft schreibgeschützt, die [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) Flächen ist, damit andere Aufrufer an, die Ihre Abhängigkeitseigenschaft auch Eigenschaftensystem Hilfsprogramm-APIs verwenden können, die erfordern, die Bezeichner öffentlich sein.</span><span class="sxs-lookup"><span data-stu-id="92cd4-178">For the C++/CX code, the reason why you have a private field and a public read-only property that surfaces the [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.</span></span> <span data-ttu-id="92cd4-179">Wenn Sie den Bezeichner nicht offenlegen, können Benutzer diese Hilfsprogramm-APIs nicht verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-179">If you keep the identifier private, people can't use these utility APIs.</span></span> <span data-ttu-id="92cd4-180">Beispiele für eine API und Szenarien dieser Art sind [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359), [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361), [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357), [**GetAnimationBaseValue**](https://msdn.microsoft.com/library/windows/apps/br242358), [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257) und [**Setter.Property**](https://msdn.microsoft.com/library/windows/apps/br208836).</span><span class="sxs-lookup"><span data-stu-id="92cd4-180">Examples of such API and scenarios include [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) by choice, [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357), [**GetAnimationBaseValue**](https://msdn.microsoft.com/library/windows/apps/br242358), [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257), and [**Setter.Property**](https://msdn.microsoft.com/library/windows/apps/br208836).</span></span> <span data-ttu-id="92cd4-181">Ein öffentliches Feld kann dazu nicht verwendet werden, da Windows-Runtime-Metadatenregeln keine öffentlichen Felder zulassen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-181">You can't use a public field for this, because Windows Runtime metadata rules don't allow for public fields.</span></span>

## <a name="dependency-property-name-conventions"></a><span data-ttu-id="92cd4-182">Namenskonventionen für Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="92cd4-182">Dependency property name conventions</span></span>

<span data-ttu-id="92cd4-183">Für Abhängigkeitseigenschaften gelten Namenskonventionen, die Sie bis auf bestimmte Ausnahmefälle befolgen müssen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-183">There are naming conventions for dependency properties; follow them in all but exceptional circumstances.</span></span> <span data-ttu-id="92cd4-184">Die Abhängigkeitseigenschaft selbst hat einen Basisnamen („Label“ im vorherigen Beispiel), der als erster Parameter von [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-184">The dependency property itself has a basic name ("Label" in the preceding example) that is given as the first parameter of [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829).</span></span> <span data-ttu-id="92cd4-185">Dieser Name muss innerhalb jedes Registrierungstyps eindeutig sein. Diese Eindeutigkeit muss auch von vererbten Membern eingehalten werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-185">The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.</span></span> <span data-ttu-id="92cd4-186">Abhängigkeitseigenschaften, die über Basistypen geerbt werden, werden als Teil des Registrierungstyps betrachtet. Die Namen geerbter Eigenschaften können nicht erneut registriert werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-186">Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.</span></span>

> [!WARNING]
> <span data-ttu-id="92cd4-187">Obwohl der Name, die Sie angeben, dass hier kann jeder Zeichenfolgebezeichner sein, die bei der Programmierung einer Sprache Ihrer Wahl in gültig ist, möchten Sie in der Regel Ihre Abhängigkeitseigenschaft auch in XAML festlegen können.</span><span class="sxs-lookup"><span data-stu-id="92cd4-187">Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.</span></span> <span data-ttu-id="92cd4-188">Für die Verwendung in XAML muss der von Ihnen gewählte Eigenschaftenname ein gültiger XAML-Name sein.</span><span class="sxs-lookup"><span data-stu-id="92cd4-188">To be set in XAML, the property name you choose must be a valid XAML name.</span></span> <span data-ttu-id="92cd4-189">Weitere Informationen finden Sie in der [XAML-Übersicht](xaml-overview.md).</span><span class="sxs-lookup"><span data-stu-id="92cd4-189">For more info, see [XAML overview](xaml-overview.md).</span></span>

<span data-ttu-id="92cd4-190">Kombinieren Sie beim Erstellen der Bezeichnereigenschaft den von Ihnen registrierten Eigenschaftennamen mit dem Suffix „Property“ (beispielsweise „LabelProperty“).</span><span class="sxs-lookup"><span data-stu-id="92cd4-190">When you create the identifier property, combine the name of the property as you registered it with the suffix "Property" ("LabelProperty", for example).</span></span> <span data-ttu-id="92cd4-191">Diese Eigenschaft ist Ihr Bezeichner für die Abhängigkeitseigenschaft und wird als Eingabe für die [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361)- und [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359)-Aufrufe verwendet, die Sie in Ihren eigenen Eigenschaftenwrappern ausführen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-191">This property is your identifier for the dependency property, and it is used as an input for the [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) and [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) calls you make in your own property wrappers.</span></span> <span data-ttu-id="92cd4-192">Sie wird auch vom Eigenschaftensystem und anderen XAML-Prozessoren, wie z. B. [**{x:Bind}**](x-bind-markup-extension.md), verwendet.</span><span class="sxs-lookup"><span data-stu-id="92cd4-192">It is also used by the property system and other XAML processors such as [**{x:Bind}**](x-bind-markup-extension.md)</span></span>

## <a name="implementing-the-wrapper"></a><span data-ttu-id="92cd4-193">Implementieren des Wrappers</span><span class="sxs-lookup"><span data-stu-id="92cd4-193">Implementing the wrapper</span></span>

<span data-ttu-id="92cd4-194">Ihr Eigenschaftenwrapper sollte [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) in der **get**-Implementierung und [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) in der **set**-Implementierung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-194">Your property wrapper should call [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) in the **get** implementation, and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) in the **set** implementation.</span></span>

> [!WARNING]
> <span data-ttu-id="92cd4-195">Von Ausnahmefällen abgesehen sollten Ihre Wrapperimplementierungen nur die [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) und [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) Vorgänge ausführen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-195">In all but exceptional circumstances, your wrapper implementations should perform only the [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) and [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) operations.</span></span> <span data-ttu-id="92cd4-196">Andernfalls erhalten Sie ein anderes Verhalten, wenn Ihre Eigenschaft über XAML anstelle über Code festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-196">Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.</span></span> <span data-ttu-id="92cd4-197">Aus Effizienzgründen umgeht der XAML-Parser Wrapper beim Festlegen von Abhängigkeitseigenschaften und kommuniziert mit dem Sicherungsspeicher über **SetValue**.</span><span class="sxs-lookup"><span data-stu-id="92cd4-197">For efficiency, the XAML parser bypasses wrappers when setting dependency properties; and talks to the backing store via **SetValue**.</span></span>

```csharp
public String Label
{
    get { return (String)GetValue(LabelProperty); }
    set { SetValue(LabelProperty, value); }
}
```

```vb
Public Property Label() As String
    Get
        Return DirectCast(GetValue(LabelProperty), String) 
    End Get 
    Set(ByVal value As String)
        SetValue(LabelProperty, value)
    End Set
End Property
```

```cppwinrt
// ImageWithLabelControl.h
...
winrt::hstring Label()
{
    return winrt::unbox_value<winrt::hstring>(GetValue(m_labelProperty));
}

void Label(winrt::hstring const& value)
{
    SetValue(m_labelProperty, winrt::box_value(value));
}
...
```

```cpp
//using namespace Platform;
public:
...
  property String^ Label
  {
    String^ get() {
      return (String^)GetValue(LabelProperty);
    }
    void set(String^ value) {
      SetValue(LabelProperty, value);
    }
  }
```

## <a name="property-metadata-for-a-custom-dependency-property"></a><span data-ttu-id="92cd4-198">Eigenschaftenmetadaten für eine benutzerdefinierte Abhängigkeitseigenschaft</span><span class="sxs-lookup"><span data-stu-id="92cd4-198">Property metadata for a custom dependency property</span></span>

<span data-ttu-id="92cd4-199">Wenn Eigenschaftenmetadaten einer Abhängigkeitseigenschaft zugewiesen werden, gelten die gleichen Metadaten für diese Eigenschaft für jede Instanz des Eigenschaftenbesitzertyps oder dessen Unterklassen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-199">When property metadata is assigned to a dependency property, the same metadata is applied to that property for every instance of the property-owner type or its subclasses.</span></span> <span data-ttu-id="92cd4-200">Sie können zwei Verhalten in Eigenschaftenmetadaten festlegen:</span><span class="sxs-lookup"><span data-stu-id="92cd4-200">In property metadata, you can specify two behaviors:</span></span>

- <span data-ttu-id="92cd4-201">Einen Standardwert, den das Eigenschaftensystem allen Anfragen der Eigenschaft zuweist.</span><span class="sxs-lookup"><span data-stu-id="92cd4-201">A default value that the property system assigns to all cases of the property.</span></span>
- <span data-ttu-id="92cd4-202">Eine statische Rückrufmethode, die automatisch innerhalb des Eigenschaftensystems aufgerufen wird, sobald eine Eigenschaftswertänderung erkannt wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-202">A static callback method that is automatically invoked within the property system whenever a property value change is detected.</span></span>

### <a name="calling-register-with-property-metadata"></a><span data-ttu-id="92cd4-203">Aufrufen von Register mit Eigenschaftenmetadaten</span><span class="sxs-lookup"><span data-stu-id="92cd4-203">Calling Register with property metadata</span></span>

<span data-ttu-id="92cd4-204">In den bisherigen Beispielen für den Aufruf von [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) wurde für den Parameter *propertyMetadata* ein Nullwert übergeben.</span><span class="sxs-lookup"><span data-stu-id="92cd4-204">In the previous examples of calling [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829), we passed a null value for the *propertyMetadata* parameter.</span></span> <span data-ttu-id="92cd4-205">Damit eine Abhängigkeitseigenschaft einen Standardwert bereitstellt oder einen Rückruf mit geänderter Eigenschaft verwendet, müssen Sie eine [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771)-Instanz definieren, die mindestens eine dieser beiden Funktionen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-205">To enable a dependency property to provide a default value or use a property-changed callback, you must define a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance that provides one or both of these capabilities.</span></span>

<span data-ttu-id="92cd4-206">In der Regel geben Sie einen [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) als inline erstellte Instanz innerhalb der Parameter für [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) an.</span><span class="sxs-lookup"><span data-stu-id="92cd4-206">Typically you provide a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) as an inline-created instance, within the parameters for [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829).</span></span>

> [!NOTE]
> <span data-ttu-id="92cd4-207">Wenn Sie eine Implementierung [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) definieren, müssen Sie Aufruf eines Konstruktors [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) , anstatt die Hilfsmethode [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702099) verwenden, um die **PropertyMetadata** -Instanz zu definieren.</span><span class="sxs-lookup"><span data-stu-id="92cd4-207">If you are defining a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation, you must use the utility method [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702099) rather than calling a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructor to define the **PropertyMetadata** instance.</span></span>

<span data-ttu-id="92cd4-208">Im nächsten Beispiel werden die zuvor gezeigten Beispiele für [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) modifiziert, indem auf eine [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771)-Instanz mit einem [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770)-Wert verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-208">This next example modifies the previously shown [**DependencyProperty.Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples by referencing a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) instance with a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) value.</span></span> <span data-ttu-id="92cd4-209">Die Implementierung des OnLabelChanged-Rückrufs wird später in diesem Abschnitt gezeigt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-209">The implementation of the "OnLabelChanged" callback will be shown later in this section.</span></span>

```csharp
public static readonly DependencyProperty LabelProperty = DependencyProperty.Register(
  "Label",
  typeof(String),
  typeof(ImageWithLabelControl),
  new PropertyMetadata(null,new PropertyChangedCallback(OnLabelChanged))
);
```

```vb
Public Shared ReadOnly LabelProperty As DependencyProperty =
    DependencyProperty.Register("Label",
      GetType(String),
      GetType(ImageWithLabelControl),
      New PropertyMetadata(
        Nothing, new PropertyChangedCallback(AddressOf OnLabelChanged)))
```

```cppwinrt
// ImageWithLabelControl.cpp
...
Windows::UI::Xaml::DependencyProperty ImageWithLabelControl::m_labelProperty =
    Windows::UI::Xaml::DependencyProperty::Register(
        L"Label",
        winrt::xaml_typename<winrt::hstring>(),
        winrt::xaml_typename<ImageWithLabelControlApp::ImageWithLabelControl>(),
        Windows::UI::Xaml::PropertyMetadata{ nullptr, Windows::UI::Xaml::PropertyChangedCallback{ &ImageWithLabelControl::OnLabelChanged } }
);
...
```

```cpp
DependencyProperty^ ImageWithLabelControl::_LabelProperty =
    DependencyProperty::Register("Label",
    Platform::String::typeid,
    ImageWithLabelControl::typeid,
    ref new PropertyMetadata(nullptr,
      ref new PropertyChangedCallback(&ImageWithLabelControl::OnLabelChanged))
    );
```

### <a name="default-value"></a><span data-ttu-id="92cd4-210">Standardwert</span><span class="sxs-lookup"><span data-stu-id="92cd4-210">Default value</span></span>

<span data-ttu-id="92cd4-211">Sie können einen Standardwert für eine Abhängigkeitseigenschaft festlegen, damit diese immer einen bestimmten Standardwert zurückgibt, wenn ihre Festlegung aufgehoben wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-211">You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.</span></span> <span data-ttu-id="92cd4-212">Dieser Wert kann vom vererbten Standardwert für den Typ dieser Eigenschaft abweichen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-212">This value can be different than the inherent default value for the type of that property.</span></span>

<span data-ttu-id="92cd4-213">Wenn kein Standardwert festgelegt ist, ist der Standardwert einer Abhängigkeitseigenschaft für einen Verweistyp null oder entspricht der Standardeinstellung des Werttyps oder des Sprachengrundtyps (zum Beispiel 0 für einen Integer oder eine leere Zeichenfolge für eine Zeichenfolge).</span><span class="sxs-lookup"><span data-stu-id="92cd4-213">If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).</span></span> <span data-ttu-id="92cd4-214">Ein Standardwert wird vor allem erstellt, damit dessen Wert wiederhergestellt wird, wenn [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) in der Eigenschaft aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-214">The main reason for establishing a default value is that this value is restored when you call [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) on the property.</span></span> <span data-ttu-id="92cd4-215">Das Erstellen eines Standardwerts pro Eigenschaft kann vorteilhafter als das Erstellen von Standardwerten in Konstruktoren sein, insbesondere für Werttypen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-215">Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.</span></span> <span data-ttu-id="92cd4-216">Achten Sie jedoch bei Verweistypen darauf, dass beim Erstellen eines Standardwerts kein unbeabsichtigtes Singleton-Muster entsteht.</span><span class="sxs-lookup"><span data-stu-id="92cd4-216">However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.</span></span> <span data-ttu-id="92cd4-217">Weitere Informationen finden Sie weiter unten in diesem Thema unter [Bewährte Methoden](#best-practices).</span><span class="sxs-lookup"><span data-stu-id="92cd4-217">For more info, see [Best practices](#best-practices) later in this topic</span></span>

```cppwinrt
// ImageWithLabelControl.cpp
...
Windows::UI::Xaml::DependencyProperty ImageWithLabelControl::m_labelProperty =
    Windows::UI::Xaml::DependencyProperty::Register(
        L"Label",
        winrt::xaml_typename<winrt::hstring>(),
        winrt::xaml_typename<ImageWithLabelControlApp::ImageWithLabelControl>(),
        Windows::UI::Xaml::PropertyMetadata{ winrt::box_value(L"default label"), Windows::UI::Xaml::PropertyChangedCallback{ &ImageWithLabelControl::OnLabelChanged } }
);
...
```

> [!NOTE]
> <span data-ttu-id="92cd4-218">Führen Sie keine Registrierung mit einem Standardwert von [**UnsetValue**](https://msdn.microsoft.com/library/windows/apps/br242371).</span><span class="sxs-lookup"><span data-stu-id="92cd4-218">Do not register with a default value of [**UnsetValue**](https://msdn.microsoft.com/library/windows/apps/br242371).</span></span> <span data-ttu-id="92cd4-219">Diese Handlung verwirrt Eigenschaftennutzer und führt zu unbeabsichtigten Folgen innerhalb des Eigenschaftensystems.</span><span class="sxs-lookup"><span data-stu-id="92cd4-219">If you do, it will confuse property consumers and will have unintended consequences within the property system.</span></span>

### <a name="createdefaultvaluecallback"></a><span data-ttu-id="92cd4-220">CreateDefaultValueCallback</span><span class="sxs-lookup"><span data-stu-id="92cd4-220">CreateDefaultValueCallback</span></span>

<span data-ttu-id="92cd4-221">In einigen Szenarien werden Abhängigkeitseigenschaften für Objekte definiert, die in mehreren UI-Threads verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-221">In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.</span></span> <span data-ttu-id="92cd4-222">Dies ist beispielsweise der Fall, wenn ein Datenobjekt oder ein Steuerelement für mehrere Apps definiert wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-222">This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.</span></span> <span data-ttu-id="92cd4-223">Sie können den Austausch des Objekts zwischen verschiedenen Benutzeroberflächenthreads ermöglichen, indem Sie anstelle einer Standardwertinstanz eine [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812)-Implementierung bereitstellen, die an den Thread gebunden ist, der die Eigenschaft registriert hat.</span><span class="sxs-lookup"><span data-stu-id="92cd4-223">You can enable the exchange of the object between different UI threads by providing a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) implementation rather than a default value instance, which is tied to the thread that registered the property.</span></span> <span data-ttu-id="92cd4-224">Grundsätzlich definiert ein [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) eine Zuordnungsinstanz für Standardwerte.</span><span class="sxs-lookup"><span data-stu-id="92cd4-224">Basically a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) defines a factory for default values.</span></span> <span data-ttu-id="92cd4-225">Der Wert, der von **CreateDefaultValueCallback** zurückgegeben wird, ist stets mit dem aktuellen Benutzeroberflächenthread von **CreateDefaultValueCallback** verbunden, von dem das Objekt verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-225">The value returned by **CreateDefaultValueCallback** is always associated with the current UI **CreateDefaultValueCallback** thread that is using the object.</span></span>

<span data-ttu-id="92cd4-226">Um Metadaten zu definieren, die einen [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) angeben, müssen Sie [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702115) aufrufen, um eine Metadateninstanz zurückzugeben. Die [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771)-Konstruktoren besitzen keine Signatur, die einen **CreateDefaultValueCallback**-Parameter enthält.</span><span class="sxs-lookup"><span data-stu-id="92cd4-226">To define metadata that specifies a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812), you must call [**PropertyMetadata.Create**](https://msdn.microsoft.com/library/windows/apps/hh702115) to return a metadata instance; the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) constructors do not have a signature that includes a **CreateDefaultValueCallback** parameter.</span></span>

<span data-ttu-id="92cd4-227">Das typische Implementierungsmuster für einen [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) besteht im Erstellen einer neuen [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)-Klasse, dem Festlegen der spezifischen Eigenschaftswerte der einzelnen Eigenschaften von **DependencyObject** auf die beabsichtigen Standardwerte und der anschließenden Rückgabe der neuen Klasse als **Object**-Verweis über den Rückgabewert der Methode **CreateDefaultValueCallback**.</span><span class="sxs-lookup"><span data-stu-id="92cd4-227">The typical implementation pattern for a [**CreateDefaultValueCallback**](https://msdn.microsoft.com/library/windows/apps/hh701812) is to create a new [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) class, set the specific property value of each property of the **DependencyObject** to the intended default, and then return the new class as an **Object** reference via the return value of the **CreateDefaultValueCallback** method.</span></span>

### <a name="property-changed-callback-method"></a><span data-ttu-id="92cd4-228">Rückrufmethode mit geänderter Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="92cd4-228">Property-changed callback method</span></span>

<span data-ttu-id="92cd4-229">Sie können eine PropertyChanged-Rückrufmethode verwenden, um die Interaktionen Ihrer Eigenschaft mit anderen Abhängigkeitseigenschaften zu definieren oder eine interne Eigenschaft bzw. einen Status Ihres Objekts zu aktualisieren, sobald die Eigenschaft geändert wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-229">You can define a property-changed callback method to define your property's interactions with other dependency properties, or to update an internal property or state of your object whenever the property changes.</span></span> <span data-ttu-id="92cd4-230">Wenn Ihr Rückruf aufgerufen wurde, hat das Eigenschaftensystem festgestellt, dass es eine effektive Änderung des Eigenschaftswerts gibt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-230">If your callback is invoked, the property system has determined that there is an effective property value change.</span></span> <span data-ttu-id="92cd4-231">Da die Rückrufmethode statisch ist, ist der *d*-Parameter des Rückrufs wichtig, da dieser anzeigt, welche Instanz der Klasse eine Änderung gemeldet hat.</span><span class="sxs-lookup"><span data-stu-id="92cd4-231">Because the callback method is static, the *d* parameter of the callback is important because it tells you which instance of the class has reported a change.</span></span> <span data-ttu-id="92cd4-232">In einer typischen Implementierung wird die [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364)-Eigenschaft des Ereignisdatums verwendet und dieser Wert auf bestimmte Weise verarbeitet, in der Regel durch Ausführung einer anderen Änderung für das Objekt, das als *d* übergeben wurde.</span><span class="sxs-lookup"><span data-stu-id="92cd4-232">A typical implementation uses the [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) property of the event data and processes that value in some manner, usually by performing some other change on the object passed as *d*.</span></span> <span data-ttu-id="92cd4-233">Weitere Reaktionen auf eine Eigenschaftenänderung sind die Zurückweisung des von **NewValue** gemeldeten Werts, die Wiederherstellung von [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365) oder die Festlegung des Werts auf eine programmgesteuerte Einschränkung für den **NewValue**.</span><span class="sxs-lookup"><span data-stu-id="92cd4-233">Additional responses to a property change are to reject the value reported by **NewValue**, to restore [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365), or to set the value to a programmatic constraint applied to the **NewValue**.</span></span>

<span data-ttu-id="92cd4-234">Das nächste Beispiel zeigt eine [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770)-Implementierung.</span><span class="sxs-lookup"><span data-stu-id="92cd4-234">This next example shows a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) implementation.</span></span> <span data-ttu-id="92cd4-235">Hier wird die Methode implementiert, auf die in den vorigen [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Beispielen als Teil des Konstruktionsarguments für die [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) Bezug genommen wurde.</span><span class="sxs-lookup"><span data-stu-id="92cd4-235">It implements the method you saw referenced in the previous [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) examples, as part of the construction arguments for the [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771).</span></span> <span data-ttu-id="92cd4-236">In diesem Rückrufszenario besitzt die Klasse auch eine berechnete schreibgeschützte Eigenschaft „HasLabelValue“ (Implementierung nicht gezeigt).</span><span class="sxs-lookup"><span data-stu-id="92cd4-236">The scenario addressed by this callback is that the class also has a calculated read-only property named "HasLabelValue" (implementation not shown).</span></span> <span data-ttu-id="92cd4-237">Diese Rückrufmethode wird jedes Mal aufgerufen, wenn die Label-Eigenschaft neu ausgewertet wird. Der Rückruf ermöglicht die kontinuierliche Synchronisierung des abhängigen berechneten Werts mit den Änderungen der Abhängigkeitseigenschaft.</span><span class="sxs-lookup"><span data-stu-id="92cd4-237">Whenever the "Label" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.</span></span>

```csharp
private static void OnLabelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
    ImageWithLabelControl iwlc = d as ImageWithLabelControl; //null checks omitted
    String s = e.NewValue as String; //null checks omitted
    if (s == String.Empty)
    {
        iwlc.HasLabelValue = false;
    } else {
        iwlc.HasLabelValue = true;
    }
}
```

```vb
    Private Shared Sub OnLabelChanged(d As DependencyObject, e As DependencyPropertyChangedEventArgs)
        Dim iwlc As ImageWithLabelControl = CType(d, ImageWithLabelControl) ' null checks omitted
        Dim s As String = CType(e.NewValue,String) ' null checks omitted
        If s Is String.Empty Then
            iwlc.HasLabelValue = False
        Else
            iwlc.HasLabelValue = True
        End If
    End Sub
```

```cppwinrt
void ImageWithLabelControl::OnLabelChanged(Windows::UI::Xaml::DependencyObject const& d, Windows::UI::Xaml::DependencyPropertyChangedEventArgs const& e)
{
    auto iwlc{ d.as<ImageWithLabelControlApp::ImageWithLabelControl>() };
    auto s{ winrt::unbox_value<winrt::hstring>(e.NewValue()) };
    iwlc.HasLabelValue(s.size() != 0);
}
```

```cpp
static void OnLabelChanged(DependencyObject^ d, DependencyPropertyChangedEventArgs^ e)
{
    ImageWithLabelControl^ iwlc = (ImageWithLabelControl^)d;
    Platform::String^ s = (Platform::String^)(e->NewValue);
    if (s->IsEmpty()) {
        iwlc->HasLabelValue=false;
    }
}
```

### <a name="property-changed-behavior-for-structures-and-enumerations"></a><span data-ttu-id="92cd4-238">Verhalten bei geänderter Eigenschaft für Strukturen und Enumerationen</span><span class="sxs-lookup"><span data-stu-id="92cd4-238">Property changed behavior for structures and enumerations</span></span>

<span data-ttu-id="92cd4-239">Wenn der Typ einer [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) eine Enumeration oder Struktur ist, kann der Rückruf auch aufgerufen werden, wenn die internen Werte der Struktur oder der Enumerationswert nicht geändert wurden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-239">If the type of a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.</span></span> <span data-ttu-id="92cd4-240">Dieses Verhalten weicht gegenüber einem Systemgrundtyp wie einer Zeichenfolge ab. Hier erfolgt der Aufruf nur bei einem geänderten Wert.</span><span class="sxs-lookup"><span data-stu-id="92cd4-240">This is different from a system primitive such as a string where it only is invoked if the value changed.</span></span> <span data-ttu-id="92cd4-241">Dies ist der Nebeneffekt eines internen Boxing- und Unboxing-Vorgangs für diese Werte.</span><span class="sxs-lookup"><span data-stu-id="92cd4-241">This is a side effect of box and unbox operations on these values that is done internally.</span></span> <span data-ttu-id="92cd4-242">Wenn Sie über eine [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770)-Methode für eine Eigenschaft verfügen, deren Wert eine Enumeration oder Struktur ist, müssen Sie [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365) und [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) vergleichen. Dazu wandeln Sie die Werte selbst um und verwenden die überladenen Vergleichsoperatoren, die für die nun umgewandelten Werte verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="92cd4-242">If you have a [**PropertyChangedCallback**](https://msdn.microsoft.com/library/windows/apps/br208770) method for a property where your value is an enumeration or structure, you need to compare the [**OldValue**](https://msdn.microsoft.com/library/windows/apps/br242365) and [**NewValue**](https://msdn.microsoft.com/library/windows/apps/br242364) by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.</span></span> <span data-ttu-id="92cd4-243">Wenn kein entsprechender Operator verfügbar ist (beispielsweise weil es sich um eine benutzerdefinierte Struktur handelt), müssen Sie möglicherweise die einzelnen Werte vergleichen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-243">Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.</span></span> <span data-ttu-id="92cd4-244">Wenn Sie zu dem Ergebnis kommen, dass sich die Werte nicht geändert haben, ist normalerweise keine Aktion erforderlich.</span><span class="sxs-lookup"><span data-stu-id="92cd4-244">You would typically choose to do nothing if the result is that the values have not changed.</span></span>

```csharp
private static void OnVisibilityValueChanged(DependencyObject d, DependencyPropertyChangedEventArgs e) {
    if ((Visibility)e.NewValue != (Visibility)e.OldValue)
    {
        //value really changed, invoke your changed logic here
    } // else this was invoked because of boxing, do nothing
}
```

```vb
Private Shared Sub OnVisibilityValueChanged(d As DependencyObject, e As DependencyPropertyChangedEventArgs)
    If CType(e.NewValue,Visibility) != CType(e.OldValue,Visibility) Then
        '  value really changed, invoke your changed logic here
    End If
    '  else this was invoked because of boxing, do nothing
End Sub
```

```cppwinrt
static void OnVisibilityValueChanged(Windows::UI::Xaml::DependencyObject const& d, Windows::UI::Xaml::DependencyPropertyChangedEventArgs const& e)
{
    auto oldVisibility{ winrt::unbox_value<Windows::UI::Xaml::Visibility>(e.OldValue()) };
    auto newVisibility{ winrt::unbox_value<Windows::UI::Xaml::Visibility>(e.NewValue()) };

    if (newVisibility != oldVisibility)
    {
        // The value really changed; invoke your property-changed logic here.
    }
    // Otherwise, OnVisibilityValueChanged was invoked because of boxing; do nothing.
}
```

```cpp
static void OnVisibilityValueChanged(DependencyObject^ d, DependencyPropertyChangedEventArgs^ e)
{
    if ((Visibility)e->NewValue != (Visibility)e->OldValue)
    {
        //value really changed, invoke your changed logic here
    } 
    // else this was invoked because of boxing, do nothing
    }
}
```

## <a name="best-practices"></a><span data-ttu-id="92cd4-245">Bewährte Methoden</span><span class="sxs-lookup"><span data-stu-id="92cd4-245">Best practices</span></span>

<span data-ttu-id="92cd4-246">Berücksichtigen Sie die folgenden Überlegungen als bewährte Methoden, wenn Sie Ihre benutzerdefinierte Abhängigkeitseigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-246">Keep the following considerations in mind as best practices when as you define your custom dependency property.</span></span>

### <a name="dependencyobject-and-threading"></a><span data-ttu-id="92cd4-247">DependencyObject und Threading</span><span class="sxs-lookup"><span data-stu-id="92cd4-247">DependencyObject and threading</span></span>

<span data-ttu-id="92cd4-248">Alle [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)-Instanzen müssen in dem Benutzeroberflächenthread erstellt werden, der mit dem aktuellen [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) verknüpft ist, das von einer Windows-Runtime-App angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-248">All [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) instances must be created on the UI thread which is associated with the current [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) that is shown by a Windows Runtime app.</span></span> <span data-ttu-id="92cd4-249">Obwohl jedes **DependencyObject** im zentralen Benutzeroberflächenthread erstellt werden muss, kann durch Aufrufen von [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br230616) mithilfe eines Verteilerverweises von anderen Threads aus auf die Objekte zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-249">Although each **DependencyObject** must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br230616).</span></span>

<span data-ttu-id="92cd4-250">Die Threadingmerkmale von [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) sind relevant, da dies in der Regel bedeutet, dass nur im Benutzeroberflächenthread ausgeführter Code den Wert einer Abhängigkeitseigenschaft ändern oder auch nur lesen kann.</span><span class="sxs-lookup"><span data-stu-id="92cd4-250">The threading aspects of [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</span></span> <span data-ttu-id="92cd4-251">Threadingprobleme können in typischem Benutzeroberflächencode in der Regel vermieden werden, wenn **async**-Muster und Hintergrundworkerthreads richtig verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-251">Threading issues can usually be avoided in typical UI code that makes correct use of **async** patterns and background worker threads.</span></span> <span data-ttu-id="92cd4-252">Threadingprobleme im Zusammenhang mit **DependencyObject** entstehen in der Regel nur, wenn Sie eigene **DependencyObject**-Typen definieren und versuchen, diese als Datenquellen oder für andere Szenarien zu verwenden, für die ein **DependencyObject** nicht notwendigerweise geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="92cd4-252">You typically only run into **DependencyObject**-related threading issues if you are defining your own **DependencyObject** types and you attempt to use them for data sources or other scenarios where a **DependencyObject** isn't necessarily appropriate.</span></span>

### <a name="avoiding-unintentional-singletons"></a><span data-ttu-id="92cd4-253">Vermeiden unbeabsichtigter Singletons</span><span class="sxs-lookup"><span data-stu-id="92cd4-253">Avoiding unintentional singletons</span></span>

<span data-ttu-id="92cd4-254">Ein unbeabsichtigter Singleton kann auftreten, wenn eine Abhängigkeitseigenschaft deklariert wird, die einen Verweistyp annimmt, und Sie einen Konstruktor für diesen Verweistyp als Teil des Codes aufrufen, der [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) erstellt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-254">An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771).</span></span> <span data-ttu-id="92cd4-255">In diesem Fall teilen sich alle Anwendungen der Abhängigkeitseigenschaft eine einzige Instanz von **PropertyMetadata** und versuchen daher, den einzelnen von Ihnen erstellten Verweistyp gemeinsam zu nutzen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-255">What happens is that all usages of the dependency property share just one instance of **PropertyMetadata** and thus try to share the single reference type you constructed.</span></span> <span data-ttu-id="92cd4-256">Alle untergeordneten Eigenschaften dieses Werttyps, die Sie durch Ihre Abhängigkeitseigenschaft festlegen, werden anschließend auf andere Objekte übertragen, und zwar auf eine Weise, die Sie möglicherweise nicht beabsichtigt haben.</span><span class="sxs-lookup"><span data-stu-id="92cd4-256">Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you may not have intended.</span></span>

<span data-ttu-id="92cd4-257">Sie können Klassenkonstruktoren verwenden, um erste Werte für eine Abhängigkeitseigenschaft vom Typ "Verweis" festzulegen, wenn Sie einen Nicht-null-Wert haben möchten. Beachten Sie jedoch, dass dies als lokaler Wert für die [Übersicht über Abhängigkeitseigenschaften](dependency-properties-overview.md) betrachtet werden würde.</span><span class="sxs-lookup"><span data-stu-id="92cd4-257">You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of [Dependency properties overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="92cd4-258">Es ist unter Umständen angemessener, eine Vorlage– falls diese von Ihrer Klasse unterstützt wird– für diesen Zweck zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-258">It might be more appropriate to use a template for this purpose, if your class supports templates.</span></span> <span data-ttu-id="92cd4-259">Eine andere Möglichkeit, um Singleton-Muster zu vermeiden, aber dennoch einen nützlichen Standardwert bereitzustellen, besteht darin, eine statische Eigenschaft für den Verweistyp, der einen passenden Standardwert für die Werte dieser Klasse liefert, verfügbar zu machen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-259">Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.</span></span>

### <a name="collection-type-dependency-properties"></a><span data-ttu-id="92cd4-260">Abhängigkeitseigenschaften des Sammlungstyps</span><span class="sxs-lookup"><span data-stu-id="92cd4-260">Collection-type dependency properties</span></span>

<span data-ttu-id="92cd4-261">Bei Abhängigkeitseigenschaften vom Typ "Sammlung" sind einige zusätzliche Implementierungsaspekte zu beachten.</span><span class="sxs-lookup"><span data-stu-id="92cd4-261">Collection-type dependency properties have some additional implementation issues to consider.</span></span>

<span data-ttu-id="92cd4-262">Abhängigkeitseigenschaften des Sammlungstyps sind in der Windows-Runtime-API vergleichsweise selten.</span><span class="sxs-lookup"><span data-stu-id="92cd4-262">Collection-type dependency properties are relatively rare in the Windows Runtime API.</span></span> <span data-ttu-id="92cd4-263">In den meisten Fällen können Sie Sammlungen verwenden, deren Elemente eine [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)-Unterklasse sind. Die Sammlungseigenschaft selbst wird jedoch als herkömmliche CLR- oder eine C++-Eigenschaft implementiert.</span><span class="sxs-lookup"><span data-stu-id="92cd4-263">In most cases, you can use collections where the items are a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) subclass, but the collection property itself is implemented as a conventional CLR or C++ property.</span></span> <span data-ttu-id="92cd4-264">Das ist darauf zurückzuführen, dass sich Sammlungen nicht unbedingt für herkömmliche Szenarien eignen, bei denen Abhängigkeitseigenschaften involviert sind.</span><span class="sxs-lookup"><span data-stu-id="92cd4-264">This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.</span></span> <span data-ttu-id="92cd4-265">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="92cd4-265">For example:</span></span>

- <span data-ttu-id="92cd4-266">Sie animieren für gewöhnlich keine Sammlung.</span><span class="sxs-lookup"><span data-stu-id="92cd4-266">You do not typically animate a collection.</span></span>
- <span data-ttu-id="92cd4-267">Sie füllen die Elemente einer Sammlung für gewöhnlich nicht vorher mit Stilen oder einer Vorlage aus.</span><span class="sxs-lookup"><span data-stu-id="92cd4-267">You do not typically prepopulate the items in a collection with styles or a template.</span></span>
- <span data-ttu-id="92cd4-268">Obwohl das Binden an Sammlungen ein wichtiges Szenario ist, muss die Sammlung keine Abhängigkeitseigenschaft sein, um eine Bindungsquelle darzustellen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-268">Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.</span></span> <span data-ttu-id="92cd4-269">Im Fall von Bindungszielen werden in der Regel Unterklassen von [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/br242803) oder [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/br242348) verwendet, um Sammlungselemente zu unterstützen oder Modellanzeigemuster zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-269">For binding targets, it is more typical to use subclasses of [**ItemsControl**](https://msdn.microsoft.com/library/windows/apps/br242803) or [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/br242348) to support collection items, or to use view-model patterns.</span></span> <span data-ttu-id="92cd4-270">Weitere Informationen zur Bindung zu und von Sammlungen finden Sie unter [Datenbindung im Detail](https://msdn.microsoft.com/library/windows/apps/mt210946).</span><span class="sxs-lookup"><span data-stu-id="92cd4-270">For more info about binding to and from collections, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).</span></span>
- <span data-ttu-id="92cd4-271">Benachrichtigungen zu Sammlungsänderungen sollten besser durch Schnittstellen wie **INotifyPropertyChanged** oder **INotifyCollectionChanged** oder durch Ableiten des Sammlungstyps von [**ObservableCollection&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/ms668604.aspx) behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-271">Notifications for collection changes are better addressed through interfaces such as **INotifyPropertyChanged** or **INotifyCollectionChanged**, or by deriving the collection type from [**ObservableCollection&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/ms668604.aspx).</span></span>

<span data-ttu-id="92cd4-272">Dennoch gibt es Szenarien für Abhängigkeitseigenschaften des Sammlungstyps.</span><span class="sxs-lookup"><span data-stu-id="92cd4-272">Nevertheless, scenarios for collection-type dependency properties do exist.</span></span> <span data-ttu-id="92cd4-273">In den nächsten drei Abschnitten finden Sie Informationen zur Implementierung einer Abhängigkeitseigenschaft vom Typ "Sammlung".</span><span class="sxs-lookup"><span data-stu-id="92cd4-273">The next three sections provide some guidance on how to implement a collection-type dependency property.</span></span>

### <a name="initializing-the-collection"></a><span data-ttu-id="92cd4-274">Initialisieren der Sammlung</span><span class="sxs-lookup"><span data-stu-id="92cd4-274">Initializing the collection</span></span>

<span data-ttu-id="92cd4-275">Wenn Sie eine Abhängigkeitseigenschaft erstellen, geben Sie den Standardwert über die Metadaten für die Abhängigkeitseigenschaft an.</span><span class="sxs-lookup"><span data-stu-id="92cd4-275">When you create a dependency property, you can establish a default value by means of dependency property metadata.</span></span> <span data-ttu-id="92cd4-276">Achten Sie darauf, keine einzelne statische Sammlung als Standardwert zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-276">But be careful to not use a singleton static collection as the default value.</span></span> <span data-ttu-id="92cd4-277">Stattdessen müssen Sie sicherstellen, dass Sie den Sammlungswert bewusst auf eine eindeutige (Instanz-)Sammlung im Rahmen der Klassenkonstruktorlogik für die Besitzerklasse der Sammlungseigenschaft festlegen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-277">Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.</span></span>

### <a name="change-notifications"></a><span data-ttu-id="92cd4-278">Änderungsbenachrichtigungen</span><span class="sxs-lookup"><span data-stu-id="92cd4-278">Change notifications</span></span>

<span data-ttu-id="92cd4-279">Durch die Definition der Sammlung als Abhängigkeitseigenschaft werden nicht automatisch Änderungsbenachrichtigungen für die Elemente in der Sammlung bereitgestellt, indem das Eigenschaftensytem die Rückrufmethode „PropertyChanged“ aufruft.</span><span class="sxs-lookup"><span data-stu-id="92cd4-279">Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the "PropertyChanged" callback method.</span></span> <span data-ttu-id="92cd4-280">Wenn Sie Benachrichtigungen für Sammlungen oder Sammlungselemente einrichten möchten, beispielsweise für ein Datenbindungsszenario, implementieren Sie die **INotifyPropertyChanged**- oder **INotifyCollectionChanged**-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="92cd4-280">If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the **INotifyPropertyChanged** or **INotifyCollectionChanged** interface.</span></span> <span data-ttu-id="92cd4-281">Weitere Informationen finden Sie unter [Datenbindung im Detail](https://msdn.microsoft.com/library/windows/apps/mt210946).</span><span class="sxs-lookup"><span data-stu-id="92cd4-281">For more info, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).</span></span>

### <a name="dependency-property-security-considerations"></a><span data-ttu-id="92cd4-282">Sicherheitsüberlegungen in Bezug auf Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="92cd4-282">Dependency property security considerations</span></span>

<span data-ttu-id="92cd4-283">Deklarieren Sie Abhängigkeitseigenschaften als öffentliche Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="92cd4-283">Declare dependency properties as public properties.</span></span> <span data-ttu-id="92cd4-284">Bezeichner von Abhängigkeitseigenschaften sollten als **public static readonly**-Member deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-284">Declare dependency property identifiers as **public static readonly** members.</span></span> <span data-ttu-id="92cd4-285">Auch wenn Sie versuchen, andere durch eine Sprache zugelassene Zugriffsebenen (beispielsweise **protected**) zu deklarieren, können Sie stets auf eine Abhängigkeitseigenschaft zugreifen, indem Sie den Bezeichner in Verbindung mit den APIs des Eigenschaftensystems verwenden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-285">Even if you attempt to declare other access levels permitted by a language (such as **protected**), a dependency property can always be accessed through the identifier in combination with the property-system APIs.</span></span> <span data-ttu-id="92cd4-286">Das Deklarieren des Bezeichners der Abhängigkeitseigenschaft als intern oder privat wird nicht funktionieren, da das Eigenschaftensystem in diesem Fall nicht ordnungsgemäß arbeitet.</span><span class="sxs-lookup"><span data-stu-id="92cd4-286">Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.</span></span>

<span data-ttu-id="92cd4-287">Wrappereigenschaften sind nur als Vereinfachung gedacht. Die Sicherheitsmechanismen, die für die Wrapper angewendet werden, können durch das Aufrufen von [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) oder [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) umgangen werden.</span><span class="sxs-lookup"><span data-stu-id="92cd4-287">Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling [**GetValue**](https://msdn.microsoft.com/library/windows/apps/br242359) or [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) instead.</span></span> <span data-ttu-id="92cd4-288">Wrappereigenschaften sollten daher öffentlich bleiben. Andernfalls machen Sie die Nutzung Ihrer Eigenschaft für legitime Aufrufer schwieriger, ohne einen tatsächlichen Vorteil in Bezug auf die Sicherheit zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="92cd4-288">So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.</span></span>

<span data-ttu-id="92cd4-289">Die Windows-Runtime bietet keine Möglichkeit, eine benutzerdefinierte Abhängigkeitseigenschaft als schreibgeschützt zu registrieren.</span><span class="sxs-lookup"><span data-stu-id="92cd4-289">The Windows Runtime does not provide a way to register a custom dependency property as read-only.</span></span>

### <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="92cd4-290">Abhängigkeitseigenschaften und Klassenkonstruktoren</span><span class="sxs-lookup"><span data-stu-id="92cd4-290">Dependency properties and class constructors</span></span>

<span data-ttu-id="92cd4-291">Hier gilt der allgemeine Grundsatz, dass Klassenkonstruktoren keine virtuellen Methoden aufrufen sollten.</span><span class="sxs-lookup"><span data-stu-id="92cd4-291">There is a general principle that class constructors should not call virtual methods.</span></span> <span data-ttu-id="92cd4-292">Der Grund hierfür ist, dass Konstruktoren als Basisinitialisierung eines abgeleiteten Klassenkonstruktors aufgerufen werden können, und das Eingeben der virtuellen Methode über den Konstruktor könnte zu einem Zeitpunkt erfolgen, zu dem das erstellte Objekt einen unvollständigen Initialisierungszustand aufweist.</span><span class="sxs-lookup"><span data-stu-id="92cd4-292">This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.</span></span> <span data-ttu-id="92cd4-293">Wenn Sie eine Ableitung von einer Klasse durchführen, die bereits von [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) abgeleitet ist, sollten Sie daran denken, dass das Eigenschaftensystem selbst als Teil seiner Dienste virtuelle Methoden intern aufruft und offenlegt.</span><span class="sxs-lookup"><span data-stu-id="92cd4-293">When you derive from any class that already derives from [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), remember that the property system itself calls and exposes virtual methods internally as part of its services.</span></span> <span data-ttu-id="92cd4-294">Um mögliche Probleme mit der Laufzeitinitialisierung zu vermeiden, sollten Sie in Konstruktoren von Klassen keine Werte von Abhängigkeitseigenschaften festlegen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-294">To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.</span></span>

### <a name="registering-the-dependency-properties-for-ccx-apps"></a><span data-ttu-id="92cd4-295">Registrieren der Abhängigkeitseigenschaften für C++/CX-Apps</span><span class="sxs-lookup"><span data-stu-id="92cd4-295">Registering the dependency properties for C++/CX apps</span></span>

<span data-ttu-id="92cd4-296">Die Implementierung für das Registrieren einer Eigenschaft in C++/CX ist schwieriger als für C#, zum einen aufgrund der Aufteilung in Kopfzeile und Implementierungsdatei und zum anderen, weil die Initialisierung im Stammbereich der Implementierungsdatei nicht empfohlen wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-296">The implementation for registering a property in C++/CX is trickier than C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.</span></span> <span data-ttu-id="92cd4-297">(Visual C++-Komponentenerweiterungen (C++/CX) platzieren statischen Initialisierungscode aus dem Stammbereich direkt in **DllMain**, während C#-Compiler die statischen Initialisierer Klassen zuweisen und so **DllMain**-Ladeprobleme vermeiden).</span><span class="sxs-lookup"><span data-stu-id="92cd4-297">(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into **DllMain**, whereas C# compilers assign the static initializers to classes and thus avoid **DllMain** load lock issues.).</span></span> <span data-ttu-id="92cd4-298">Die bewährte Methode besteht hier im Deklarieren einer Hilfsfunktion, die die gesamte Registrierung von Abhängigkeitseigenschaften für eine Klasse durchführt, d.h. eine Funktion pro Klasse.</span><span class="sxs-lookup"><span data-stu-id="92cd4-298">The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.</span></span> <span data-ttu-id="92cd4-299">Für jede benutzerdefinierte Klasse, die Ihre App nutzt, müssen Sie dann auf die Hilfsregistrierungsfunktion verweisen, die von den einzelnen benutzerdefinierten Klassen jeweils verfügbar gemacht wird, die Sie verwenden möchten.</span><span class="sxs-lookup"><span data-stu-id="92cd4-299">Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.</span></span> <span data-ttu-id="92cd4-300">Rufen Sie jede Hilfsregistrierungsfunktion einmalig als Teil des [**Application constructor**](https://msdn.microsoft.com/library/windows/apps/br242325) (`App::App()`) vor `InitializeComponent` auf.</span><span class="sxs-lookup"><span data-stu-id="92cd4-300">Call each helper registration function once as part of the [**Application constructor**](https://msdn.microsoft.com/library/windows/apps/br242325) (`App::App()`), prior to `InitializeComponent`.</span></span> <span data-ttu-id="92cd4-301">Dieser Konstruktor wird nur ausgeführt, wenn wirklich zum ersten Mal auf die App verwiesen wir. Er wird nicht erneut ausgeführt, wenn beispielsweise eine angehaltene App fortgesetzt wird.</span><span class="sxs-lookup"><span data-stu-id="92cd4-301">That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.</span></span> <span data-ttu-id="92cd4-302">Wie im vorherigen C++-Registrierungsbeispiel gezeigt, ist auch die **nullptr**-Überprüfung jedes [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829)-Aufrufs wichtig, da hierdurch sichergestellt wird, dass kein Aufrufer der Funktion die Eigenschaft zweimal registrieren kann.</span><span class="sxs-lookup"><span data-stu-id="92cd4-302">Also, as seen in the previous C++ registration example, the **nullptr** check around each [**Register**](https://msdn.microsoft.com/library/windows/apps/hh701829) call is important: it's insurance that no caller of the function can register the property twice.</span></span> <span data-ttu-id="92cd4-303">Bei einem zweiten Registrierungsaufruf würde Ihre App ohne eine solche Überprüfung wahrscheinlich abstürzen, da der Eigenschaftsname doppelt vorhanden wäre.</span><span class="sxs-lookup"><span data-stu-id="92cd4-303">A second registration call would probably crash your app without such a check because the property name would be a duplicate.</span></span> <span data-ttu-id="92cd4-304">Dieses Implementierungsmuster können Sie im [XAML-Beispiel für Benutzer und benutzerdefinierte Steuerelemente](http://go.microsoft.com/fwlink/p/?linkid=238581) im Code für die C++/CX-Version des Beispiels sehen.</span><span class="sxs-lookup"><span data-stu-id="92cd4-304">You can see this implementation pattern in the [XAML user and custom controls sample](http://go.microsoft.com/fwlink/p/?linkid=238581) if you look at the code for the C++/CX version of the sample.</span></span>

## <a name="related-topics"></a><span data-ttu-id="92cd4-305">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="92cd4-305">Related topics</span></span>

- [**<span data-ttu-id="92cd4-306">DependencyObject</span><span class="sxs-lookup"><span data-stu-id="92cd4-306">DependencyObject</span></span>**](https://msdn.microsoft.com/library/windows/apps/br242356)
- [**<span data-ttu-id="92cd4-307">DependencyProperty.Register</span><span class="sxs-lookup"><span data-stu-id="92cd4-307">DependencyProperty.Register</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh701829)
- [<span data-ttu-id="92cd4-308">Übersicht über Abhängigkeitseigenschaften</span><span class="sxs-lookup"><span data-stu-id="92cd4-308">Dependency properties overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="92cd4-309">XAML-Beispiel für Benutzer und benutzerdefinierte Steuerelemente</span><span class="sxs-lookup"><span data-stu-id="92cd4-309">XAML user and custom controls sample</span></span>](http://go.microsoft.com/fwlink/p/?linkid=238581)
 