---
author: jwmsft
description: Ein XAML-NameScope speichert Beziehungen zwischen den definierten XAML-Namen von Objekten und ihren entsprechenden Instanzen. Dies ist vergleichbar mit der weiteren Bedeutung des Begriffs NameScope in anderen Programmiersprachen und Technologien.
title: XAML-NameScopes
ms.assetid: EB060CBD-A589-475E-B83D-B24068B54C21
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: windows10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 8fcbc1566d2b2b5ffc6889a57dd7656a3466d2a9
ms.sourcegitcommit: 6cc275f2151f78db40c11ace381ee2d35f0155f9
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/25/2018
ms.locfileid: "5548084"
---
# <a name="xaml-namescopes"></a><span data-ttu-id="03892-105">XAML-NameScopes</span><span class="sxs-lookup"><span data-stu-id="03892-105">XAML namescopes</span></span>


<span data-ttu-id="03892-106">Ein *XAML-NameScope* speichert Beziehungen zwischen den definierten XAML-Namen von Objekten und ihren entsprechenden Instanzen.</span><span class="sxs-lookup"><span data-stu-id="03892-106">A *XAML namescope* stores relationships between the XAML-defined names of objects and their instance equivalents.</span></span> <span data-ttu-id="03892-107">Dies ist vergleichbar mit der weiteren Bedeutung des Begriffs *NameScope* in anderen Programmiersprachen und Technologien.</span><span class="sxs-lookup"><span data-stu-id="03892-107">This concept is similar to the wider meaning of the term *namescope* in other programming languages and technologies.</span></span>

## <a name="how-xaml-namescopes-are-defined"></a><span data-ttu-id="03892-108">Definieren von XAML-NameScopes</span><span class="sxs-lookup"><span data-stu-id="03892-108">How XAML namescopes are defined</span></span>

<span data-ttu-id="03892-109">Die Namen in XAML-NameScopes aktivieren Benutzercode, der auf die Objekte verweist, die ursprünglich in XAML definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="03892-109">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</span></span> <span data-ttu-id="03892-110">Das interne Ergebnis der XAML-Analyse ist das Erstellen eines Satzes von Objekten, in dem einige oder alle Beziehungen dieser Objekte in den XAML-Deklarationen beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="03892-110">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</span></span> <span data-ttu-id="03892-111">Diese Beziehungen werden als spezifische Objekteigenschaften der erstellten Objekte beibehalten oder für Hilfsmethoden in den Programmiermodell-APIs verfügbar gemacht.</span><span class="sxs-lookup"><span data-stu-id="03892-111">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</span></span>

<span data-ttu-id="03892-112">Die typischste Verwendung eines Namens in einem XAML-NameScope ist der direkte Verweis auf eine Objektinstanz, die vom Markupkompilierungsschritt aktiviert wird, in Kombination mit einer generierten **InitializeComponent**-Methode in den partiellen Klassenvorlagen.</span><span class="sxs-lookup"><span data-stu-id="03892-112">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated **InitializeComponent** method in the partial class templates.</span></span>

<span data-ttu-id="03892-113">Sie können auch die [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715)-Hilfsmethode zur Laufzeit verwenden, um einen Verweis auf Objekte zurückzugeben, die mit einem Namen im XAML-Markup definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="03892-113">You can also use the utility method [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</span></span>

### <a name="more-about-build-actions-and-xaml"></a><span data-ttu-id="03892-114">Mehr zu Buildaktionen und XAML</span><span class="sxs-lookup"><span data-stu-id="03892-114">More about build actions and XAML</span></span>

<span data-ttu-id="03892-115">Technisch gesehen wird für das XAML selbst ein Markupcompilerdurchlauf durchgeführt, während gleichzeitig das XAML und die darin für CodeBehind definierte partielle Klasse gemeinsam kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="03892-115">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</span></span> <span data-ttu-id="03892-116">Jedes Objektelement, für das im Markup ein **Name**- oder [x:Name-Attribut](x-name-attribute.md) definiert wurde, generiert ein internes Feld mit einem Namen, der mit dem XAML-Namen übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="03892-116">Each object element with a **Name** or [x:Name attribute](x-name-attribute.md) defined in the markup generates an internal field with a name that matches the XAML name.</span></span> <span data-ttu-id="03892-117">Dieses Feld ist anfänglich leer.</span><span class="sxs-lookup"><span data-stu-id="03892-117">This field is initially empty.</span></span> <span data-ttu-id="03892-118">Die Klasse generiert dann eine **InitializeComponent**-Methode, die erst aufgerufen wird, wenn das gesamte XAML geladen wurde.</span><span class="sxs-lookup"><span data-stu-id="03892-118">Then the class generates an **InitializeComponent** method that is called only after all the XAML is loaded.</span></span> <span data-ttu-id="03892-119">Anschließend werden durch die **InitializeComponent**-Logik alle internen Felder mit dem [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715)-Rückgabewert für die entsprechende Namenszeichenfolge aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="03892-119">Within the **InitializeComponent** logic, each internal field is then populated with the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) return value for the equivalent name string.</span></span> <span data-ttu-id="03892-120">Sie können diese Infrastruktur selbst erkennen, indem Sie sich die Dateien mit der Erweiterung ".g" (generiert) ansehen, die für die einzelnen XAML-Seiten nach der Kompilierung im /obj-Unterordner eines Projekts für eine Windows-Runtime-App erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="03892-120">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</span></span> <span data-ttu-id="03892-121">Sie können die Felder und die **InitializeComponent**-Methode auch als Member der erstellten Assemblys anzeigen, wenn Sie eine Reflexion über diese ausführen oder in anderer Weise ihre MSIL-Inhalte untersuchen.</span><span class="sxs-lookup"><span data-stu-id="03892-121">You can also see the fields and **InitializeComponent** method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</span></span>

<span data-ttu-id="03892-122">**Hinweis:** speziell für für VisualC++-komponentenerweiterungen (C++ / CX)-apps kein Sicherungsfeld für einen **X: Name** -Verweis nicht für das Stammelement einer XAML-Datei erstellt.</span><span class="sxs-lookup"><span data-stu-id="03892-122">**Note**Specifically for VisualC++ component extensions (C++/CX) apps, a backing field for an **x:Name** reference is not created for the root element of a XAML file.</span></span> <span data-ttu-id="03892-123">Wenn Sie aus CodeBehind für C++/CX auf das Stammobjekt verweisen müssen, verwenden Sie andere APIs oder eine Strukturausnahme.</span><span class="sxs-lookup"><span data-stu-id="03892-123">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</span></span> <span data-ttu-id="03892-124">Sie können beispielsweise erst [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) für ein bekanntes benanntes Unterelement und anschließend [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739) aufrufen.</span><span class="sxs-lookup"><span data-stu-id="03892-124">For example you can call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) for a known named child element and then call [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739).</span></span>

## <a name="creating-objects-at-run-time-with-xamlreaderload"></a><span data-ttu-id="03892-125">Erstellen von Objekten zur Laufzeit mit XamlReader.Load</span><span class="sxs-lookup"><span data-stu-id="03892-125">Creating objects at run time with XamlReader.Load</span></span>

<span data-ttu-id="03892-126">XAML kann auch als Zeichenfolgeneingabe für die [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048)-Methode verwendet werden, die analog zum ursprünglichen XAML-Quellanalysevorgang funktioniert.</span><span class="sxs-lookup"><span data-stu-id="03892-126">XAML can be also be used as the string input for the [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) method, which acts analogously to the initial XAML source parse operation.</span></span> <span data-ttu-id="03892-127">**XamlReader.Load** erstellt zur Laufzeit eine neue getrennte Struktur von Objekten.</span><span class="sxs-lookup"><span data-stu-id="03892-127">**XamlReader.Load** creates a new disconnected tree of objects at run time.</span></span> <span data-ttu-id="03892-128">Die getrennte Struktur kann dann an die Hauptobjektstruktur angefügt werden.</span><span class="sxs-lookup"><span data-stu-id="03892-128">The disconnected tree can then be attached to some point on the main object tree.</span></span> <span data-ttu-id="03892-129">Sie müssen die erstellte Objektstruktur explizit verbinden, entweder durch Hinzufügen zu einer Inhaltseigenschaftenauflistung wie **Children** oder durch Festlegen einer anderen Eigenschaft, die einen Objektwert akzeptiert (z. B. Laden eines neuen [**ImageBrush**](https://msdn.microsoft.com/library/windows/apps/br210101) für einen [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill)-Eigenschaftswert).</span><span class="sxs-lookup"><span data-stu-id="03892-129">You must explicitly connect your created object tree, either by adding it to a content property collection such as **Children**, or by setting some other property that takes an object value (for example, loading a new [**ImageBrush**](https://msdn.microsoft.com/library/windows/apps/br210101) for a [**Fill**](/uwp/api/Windows.UI.Xaml.Shapes.Shape.Fill) property value).</span></span>

### <a name="xaml-namescope-implications-of-xamlreaderload"></a><span data-ttu-id="03892-130">XAML-NameScope-Auswirkungen von XamlReader.Load</span><span class="sxs-lookup"><span data-stu-id="03892-130">XAML namescope implications of XamlReader.Load</span></span>

<span data-ttu-id="03892-131">Der vorläufige XAML-NameScope, der durch die neue mit [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) erstellte Objektstruktur definiert wird, wertet alle definierten Namen im bereitgestellten XAML auf Eindeutigkeit hin aus.</span><span class="sxs-lookup"><span data-stu-id="03892-131">The preliminary XAML namescope defined by the new object tree created by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) evaluates any defined names in the provided XAML for uniqueness.</span></span> <span data-ttu-id="03892-132">Wenn das bereitgestellte XAML zu diesem Zeitpunkt intern nicht eindeutige Namen enthält, wird durch **XamlReader.Load** eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="03892-132">If names in the provided XAML are not internally unique at this point, **XamlReader.Load** throws an exception.</span></span> <span data-ttu-id="03892-133">Beim Verbinden der getrennten Objektstruktur mit der Hauptobjektstruktur der Anwendung wird nicht versucht, den zugehörigen XAML-NameScope mit dem XAML-Haupt-NameScope der Anwendung zusammenzuführen.</span><span class="sxs-lookup"><span data-stu-id="03892-133">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</span></span> <span data-ttu-id="03892-134">Nach dem Verbinden der Strukturen weist die App eine einheitliche Objektstruktur auf, die jedoch einzelne XAML-NameScopes enthält.</span><span class="sxs-lookup"><span data-stu-id="03892-134">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</span></span> <span data-ttu-id="03892-135">Die Trennungen treten an den Verbindungspunkten zwischen Objekten auf, an denen Sie Eigenschaften auf den Wert festlegen, der von einem **XamlReader.Load**-Aufruf zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="03892-135">The divisions occur at the connection points between objects, where you set some property to be the value returned from a **XamlReader.Load** call.</span></span>

<span data-ttu-id="03892-136">Das Problem mit einzelnen und getrennten XAML-NameScopes besteht darin, dass Aufrufe der [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715)-Methode sowie direkte verwaltete Objektverweise nicht mehr für einen einheitlichen XAML-NameScope durchgeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="03892-136">The complication of having discrete and disconnected XAML namescopes is that calls to the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) method as well as direct managed object references no longer operate against a unified XAML namescope.</span></span> <span data-ttu-id="03892-137">Stattdessen impliziert das bestimmte Objekt, für das **FindName** aufgerufen wird, den Bereich. Dabei ist der Bereich der XAML-NameScope, in dem sich das aufrufende Objekt befindet.</span><span class="sxs-lookup"><span data-stu-id="03892-137">Instead, the particular object that **FindName** is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</span></span> <span data-ttu-id="03892-138">Bei direkten verwalteten Objektverweisen wird der Bereich durch die Klasse impliziert, die den Code enthält.</span><span class="sxs-lookup"><span data-stu-id="03892-138">In the direct managed object reference case, the scope is implied by the class where the code exists.</span></span> <span data-ttu-id="03892-139">In der Regel ist der CodeBehind für Laufzeitinteraktionen einer "Seite" mit App-Inhalt in der partiellen Klasse vorhanden, auf der die "Seite" für den Stamm basiert. Aus diesem Grund fungiert der XAML-NameScope XAML-Stamm-NameScope.</span><span class="sxs-lookup"><span data-stu-id="03892-139">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</span></span>

<span data-ttu-id="03892-140">Wenn Sie [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) aufrufen, um ein benanntes Objekt aus dem XAML-Stamm-NameScope abzurufen, findet die Methode keine Objekte aus einem mit [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) erstellten einzelnen XAML-NameScope.</span><span class="sxs-lookup"><span data-stu-id="03892-140">If you call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048).</span></span> <span data-ttu-id="03892-141">Umgekehrt findet die Methode keine benannten Objekte im XAML-Stamm-NameScope, wenn Sie **FindName** von einem Objekt aus aufrufen, das sich in einem einzelnen XAML-NameScope befindet.</span><span class="sxs-lookup"><span data-stu-id="03892-141">Conversely, if you call **FindName** from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</span></span>

<span data-ttu-id="03892-142">Dieses Problem mit einzelnen XAML-NameScopes wirkt sich nur auf Objektsuchen nach Namen in XAML-NameScopes aus, die mithilfe des [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715)-Aufrufs durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="03892-142">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) call.</span></span>

<span data-ttu-id="03892-143">Um Verweise auf Objekte abzurufen, die in einem anderen XAML-NameScope definiert werden, stehen mehrere Vorgehensweisen zur Verfügung:</span><span class="sxs-lookup"><span data-stu-id="03892-143">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</span></span>

-   <span data-ttu-id="03892-144">Gehen Sie in einzelnen Schritten durch die ganze Struktur mit [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739) und/oder Auflistungseigenschaften, die bekanntermaßen in der Objektstruktur vorhanden sind (z. B. die von [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514) zurückgegebene Auflistung).</span><span class="sxs-lookup"><span data-stu-id="03892-144">Walk the entire tree in discrete steps with [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739) and/or collection properties that are known to exist in your object tree structure (such as the collection returned by [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514)).</span></span>
-   <span data-ttu-id="03892-145">Wenn Sie den Aufruf von einem einzelnen XAML-NameScope aus durchführen und auf den XAML-Stamm-NameScope abzielen, bietet es sich an, einen Verweis auf das gegenwärtig angezeigte Hauptfenster abzurufen.</span><span class="sxs-lookup"><span data-stu-id="03892-145">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</span></span> <span data-ttu-id="03892-146">Sie können den visuellen Stamm (das XAML-Stammelement, das auch als Inhaltsquelle bezeichnet wird) aus der aktuellen Anwendung in einer Codezeile mit dem `Window.Current.Content`-Aufruf abrufen.</span><span class="sxs-lookup"><span data-stu-id="03892-146">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call `Window.Current.Content`.</span></span> <span data-ttu-id="03892-147">Sie können dann eine Umwandlung in [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) durchführen und von diesem Bereich aus [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) aufrufen.</span><span class="sxs-lookup"><span data-stu-id="03892-147">You can then cast to [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) and call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) from this scope.</span></span>
-   <span data-ttu-id="03892-148">Wenn Sie den Aufruf vom XAML-Stamm-NameScope aus ausführen und auf ein Objekt in einem einzelnen XAML-NameScope abzielen, bietet es sich an, in Ihrem Code vorauszuplanen und einen Verweis auf das Objekt beizubehalten, das von [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) und anschließend der Hauptobjektstruktur hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="03892-148">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) and then added to the main object tree.</span></span> <span data-ttu-id="03892-149">Dieses Objekt ist jetzt ein gültiges Objekt zum Aufrufen von [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) innerhalb des einzelnen XAML-NameScopes.</span><span class="sxs-lookup"><span data-stu-id="03892-149">This object is now a valid object for calling [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) within the discrete XAML namescope.</span></span> <span data-ttu-id="03892-150">Speichern Sie dieses Objekt als globale Variable, oder übergeben Sie es mit Methodenparametern.</span><span class="sxs-lookup"><span data-stu-id="03892-150">You could keep this object available as a global variable or otherwise pass it by using method parameters.</span></span>
-   <span data-ttu-id="03892-151">Sie können Probleme hinsichtlich Namen und XAML-NameScope vermeiden, indem Sie die visuelle Struktur untersuchen.</span><span class="sxs-lookup"><span data-stu-id="03892-151">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</span></span> <span data-ttu-id="03892-152">Die [**VisualTreeHelper**](https://msdn.microsoft.com/library/windows/apps/br243038)-API ermöglicht es Ihnen, die visuelle Struktur im Hinblick auf übergeordnete Objekte und untergeordnete Auflistungen auf Grundlage von Position und Index zu durchlaufen.</span><span class="sxs-lookup"><span data-stu-id="03892-152">The [**VisualTreeHelper**](https://msdn.microsoft.com/library/windows/apps/br243038) API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</span></span>

## <a name="xaml-namescopes-in-templates"></a><span data-ttu-id="03892-153">XAML-NameScopes in Vorlagen</span><span class="sxs-lookup"><span data-stu-id="03892-153">XAML namescopes in templates</span></span>

<span data-ttu-id="03892-154">Mithilfe von Vorlagen in XAML können Sie Inhalt auf einfache Weise wiederverwenden und erneut anwenden. Vorlagen können jedoch auch Elemente mit Namen enthalten, die auf Vorlagenebene definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="03892-154">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</span></span> <span data-ttu-id="03892-155">Dieselbe Vorlage kann in einer Seite mehrmals verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="03892-155">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="03892-156">Deshalb definieren Vorlagen ihre eigenen XAML-NameScopes, und zwar unabhängig von der Seite, auf die der Stil oder die Vorlage angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="03892-156">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</span></span> <span data-ttu-id="03892-157">Betrachten Sie das folgende Beispiel:</span><span class="sxs-lookup"><span data-stu-id="03892-157">Consider this example:</span></span>

```xml
<Page
  xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
  xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  >
  <Page.Resources>
    <ControlTemplate x:Key="MyTemplate">
      ....
      <TextBlock x:Name="MyTextBlock" />
    </ControlTemplate>
  </Page.Resources>
  <StackPanel>
    <SomeControl Template="{StaticResource MyTemplate}" />
    <SomeControl Template="{StaticResource MyTemplate}" />
  </StackPanel>
</Page>
```

<span data-ttu-id="03892-158">Hier wird dieselbe Vorlage auf zwei verschiedene Steuerelemente angewendet.</span><span class="sxs-lookup"><span data-stu-id="03892-158">Here, the same template is applied to two different controls.</span></span> <span data-ttu-id="03892-159">Wenn die Vorlagen keine getrennten XAML-NameScopes enthalten würden, würde der in der Vorlage verwendete MyTextBlock-Name einen Namenskonflikt auslösen.</span><span class="sxs-lookup"><span data-stu-id="03892-159">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</span></span> <span data-ttu-id="03892-160">Jede Instanziierung der Vorlage verfügt über einen eigenen XAML-NameScope, sodass in diesem Beispiel der XAML-NameScope jeder instanziierten Vorlage genau einen Namen enthält.</span><span class="sxs-lookup"><span data-stu-id="03892-160">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span> <span data-ttu-id="03892-161">Der XAML-Stamm-NameScope enthält jedoch keinen der Vorlagennamen.</span><span class="sxs-lookup"><span data-stu-id="03892-161">However, the root XAML namescope does not contain the name from either template.</span></span>

<span data-ttu-id="03892-162">Wegen der separaten XAML-NameScopes erfordert die Suche nach benannten Elementen innerhalb einer Vorlage vom Bereich der Seite, auf die die Vorlage angewendet wird, ein anderes Verfahren.</span><span class="sxs-lookup"><span data-stu-id="03892-162">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</span></span> <span data-ttu-id="03892-163">Statt [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) für ein Objekt in der Objektstruktur aufzurufen, rufen Sie zunächst das Objekt ab, auf das die Vorlage angewendet wurde. Rufen Sie dann [**GetTemplateChild**](https://msdn.microsoft.com/library/windows/apps/br209416) auf.</span><span class="sxs-lookup"><span data-stu-id="03892-163">Rather than calling [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) on some object in the object tree, you first obtain the object that has the template applied, and then call [**GetTemplateChild**](https://msdn.microsoft.com/library/windows/apps/br209416).</span></span> <span data-ttu-id="03892-164">Wenn Sie Autor eines Steuerelements sind und eine Konvention erstellen, in der ein bestimmtes benanntes Element in einer angewendeten Vorlage das Ziel für ein Verhalten darstellt, das vom Steuerelement selbst definiert wird, können Sie die **GetTemplateChild**-Methode aus dem Code zur Implementierung des Steuerelements verwenden.</span><span class="sxs-lookup"><span data-stu-id="03892-164">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the **GetTemplateChild** method from your control implementation code.</span></span> <span data-ttu-id="03892-165">Die **GetTemplateChild**-Methode ist geschützt, sodass nur der Steuerelementautor Zugriff darauf hat.</span><span class="sxs-lookup"><span data-stu-id="03892-165">The **GetTemplateChild** method is protected, so only the control author has access to it.</span></span> <span data-ttu-id="03892-166">Außerdem gibt es Konventionen, die Steuerelementautoren befolgen sollten, um Teile und Vorlagenteile zu benennen und diese als auf die Steuerelementklasse angewendete Attributwerte zu melden.</span><span class="sxs-lookup"><span data-stu-id="03892-166">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</span></span> <span data-ttu-id="03892-167">Diese Vorgehensweise macht die Namen wichtiger Teile für die Benutzer von Steuerelementen erkennbar, die möglicherweise eine andere Vorlage anwenden möchten, die die benannten Teile ersetzen müsste, um die Funktionalität der Steuerelemente aufrechtzuerhalten.</span><span class="sxs-lookup"><span data-stu-id="03892-167">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</span></span>

## <a name="related-topics"></a><span data-ttu-id="03892-168">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="03892-168">Related topics</span></span>

* [<span data-ttu-id="03892-169">Übersicht über XAML</span><span class="sxs-lookup"><span data-stu-id="03892-169">XAML overview</span></span>](xaml-overview.md)
* [<span data-ttu-id="03892-170">x:Name-Attribut</span><span class="sxs-lookup"><span data-stu-id="03892-170">x:Name attribute</span></span>](x-name-attribute.md)
* [<span data-ttu-id="03892-171">Schnellstart: Steuerelementvorlagen</span><span class="sxs-lookup"><span data-stu-id="03892-171">Quickstart: Control templates</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)
* [**<span data-ttu-id="03892-172">XamlReader.Load</span><span class="sxs-lookup"><span data-stu-id="03892-172">XamlReader.Load</span></span>**](https://msdn.microsoft.com/library/windows/apps/br228048)
* [**<span data-ttu-id="03892-173">FindName</span><span class="sxs-lookup"><span data-stu-id="03892-173">FindName</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208715)
 

