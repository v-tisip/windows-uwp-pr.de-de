---
author: jwmsft
description: Wir beschreiben das Programmierkonzept von Ereignissen in einer Windows-Runtime-app, bei Verwendung von c#, Visual Basic oder für VisualC++-komponentenerweiterungen (C++ / CX) als Programmiersprache und XAML-Code für die UI-Definition.
title: Übersicht über Ereignisse und Routingereignisse
ms.assetid: 34C219E8-3EFB-45BC-8BBD-6FD937698832
ms.author: jimwalk
ms.date: 07/12/2018
ms.topic: article
keywords: Windows10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 1ec2986594b043fa088450609e655f4b56b95e25
ms.sourcegitcommit: ca96031debe1e76d4501621a7680079244ef1c60
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/30/2018
ms.locfileid: "5821758"
---
# <a name="events-and-routed-events-overview"></a><span data-ttu-id="046d7-104">Übersicht über Ereignisse und Routingereignisse</span><span class="sxs-lookup"><span data-stu-id="046d7-104">Events and routed events overview</span></span>

**<span data-ttu-id="046d7-105">Wichtige APIs</span><span class="sxs-lookup"><span data-stu-id="046d7-105">Important APIs</span></span>**
-   [**<span data-ttu-id="046d7-106">UIElement</span><span class="sxs-lookup"><span data-stu-id="046d7-106">UIElement</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208911)
-   [**<span data-ttu-id="046d7-107">RoutedEventArgs</span><span class="sxs-lookup"><span data-stu-id="046d7-107">RoutedEventArgs</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208809)

<span data-ttu-id="046d7-108">Wir beschreiben das Programmierkonzept von Ereignissen in einer Windows-Runtime-app, bei Verwendung von c#, Visual Basic oder für VisualC++-komponentenerweiterungen (C++ / CX) als Programmiersprache und XAML-Code für die UI-Definition.</span><span class="sxs-lookup"><span data-stu-id="046d7-108">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or VisualC++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</span></span> <span data-ttu-id="046d7-109">Sie können im Rahmen der Deklarationen für UI-Elemente Handler für Ereignisse in XAML zuweisen. Alternativ können Sie Handler im Code hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="046d7-109">You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</span></span> <span data-ttu-id="046d7-110">Die Windows-Runtime unterstützt *Routingereignisse*: Bestimmte Eingabeereignisse und Datenereignisse können von anderen Objekten behandelt werden als dem Objekt, von dem das Ereignis ausgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="046d7-110">Windows Runtime supports *routed events*: certain input events and data events can be handled by objects beyond the object that fired the event.</span></span> <span data-ttu-id="046d7-111">Routingereignisse sind hilfreich, wenn Sie Steuerelementvorlagen definieren oder Seiten oder Layoutcontainer verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-111">Routed events are useful when you define control templates, or use pages or layout containers.</span></span>

## <a name="events-as-a-programming-concept"></a><span data-ttu-id="046d7-112">Ereignisse als Programmierkonzept</span><span class="sxs-lookup"><span data-stu-id="046d7-112">Events as a programming concept</span></span>

<span data-ttu-id="046d7-113">Grundsätzlich sind Ereigniskonzepte bei der Programmierung einer Windows-Runtime-App mit dem Ereignismodell in den meisten gängigen Programmiersprachen vergleichbar.</span><span class="sxs-lookup"><span data-stu-id="046d7-113">Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</span></span> <span data-ttu-id="046d7-114">Wenn Sie bereits mit .NET- oder C++-Ereignissen vertraut sind, kommen Sie sofort zurecht.</span><span class="sxs-lookup"><span data-stu-id="046d7-114">If you know how to work with Microsoft .NET or C++ events already, you have a head start.</span></span> <span data-ttu-id="046d7-115">Für verschiedene allgemeine Aufgaben, wie das Hinzufügen von Handlern, müssen Sie jedoch nicht allzu viel über Ereignismodellkonzepte wissen.</span><span class="sxs-lookup"><span data-stu-id="046d7-115">But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</span></span>

<span data-ttu-id="046d7-116">Wenn Sie C#, Visual Basic oder C++/CX als Programmiersprache verwenden, wird die UI im Markup (XAML) definiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-116">When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</span></span> <span data-ttu-id="046d7-117">In der XAML-Markupsyntax ähneln einige der Prinzipien, nach denen UI-Ereignisse zwischen Markupelementen und Laufzeitcodeentitäten verbunden werden, denen anderer Webtechnologien (z.B. ASP.NET oder HTML5).</span><span class="sxs-lookup"><span data-stu-id="046d7-117">In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</span></span>

<span data-ttu-id="046d7-118">**Hinweis:** der Code, der die Laufzeitlogik für eine mit XAML definierte UI bereitstellt wird häufig als *Code-Behind* oder Code-Behind-Datei bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="046d7-118">**Note**The code that provides the runtime logic for a XAML-defined UI is often referred to as *code-behind* or the code-behind file.</span></span> <span data-ttu-id="046d7-119">In den Projektmappenansichten von Microsoft Visual Studio wird diese Beziehung grafisch dargestellt. Dabei ist die CodeBehind-Datei eine abhängige und geschachtelte Datei zu der XAML-Seite, auf die sie sich bezieht.</span><span class="sxs-lookup"><span data-stu-id="046d7-119">In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</span></span>

## <a name="buttonclick-an-introduction-to-events-and-xaml"></a><span data-ttu-id="046d7-120">Button.Click: Einführung in Ereignisse und XAML</span><span class="sxs-lookup"><span data-stu-id="046d7-120">Button.Click: an introduction to events and XAML</span></span>

<span data-ttu-id="046d7-121">Zu den häufigsten Programmieraufgaben für eine Windows-Runtime-App gehört es, Benutzereingaben für die UI zu erfassen.</span><span class="sxs-lookup"><span data-stu-id="046d7-121">One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</span></span> <span data-ttu-id="046d7-122">So kann Ihre UI beispielsweise eine Schaltfläche enthalten, auf die der Benutzer klicken muss, um Informationen zu senden oder einen Zustand zu ändern.</span><span class="sxs-lookup"><span data-stu-id="046d7-122">For example, your UI might have a button that the user must click to submit info or to change state.</span></span>

<span data-ttu-id="046d7-123">Sie definieren die UI für Ihre Windows-Runtime-App mittels XAML-Generierung.</span><span class="sxs-lookup"><span data-stu-id="046d7-123">You define the UI for your Windows Runtime app by generating XAML.</span></span> <span data-ttu-id="046d7-124">Bei diesem XAML handelt es sich meist um die Ausgabe einer Designoberfläche in Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="046d7-124">This XAML is usually the output from a design surface in Visual Studio.</span></span> <span data-ttu-id="046d7-125">Sie können das XAML auch in einem Nur-Text-Editor oder im XAML-Editor eines Drittanbieters schreiben.</span><span class="sxs-lookup"><span data-stu-id="046d7-125">You can also write the XAML in a plain-text editor or a third-party XAML editor.</span></span> <span data-ttu-id="046d7-126">Beim Generieren dieses XAML können Sie Ereignishandler für einzelne UI-Elemente verknüpfen, während Sie gleichzeitig alle anderen XAML-Attribute definieren, die Eigenschaftswerte dieses UI-Elements einrichten.</span><span class="sxs-lookup"><span data-stu-id="046d7-126">While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</span></span>

<span data-ttu-id="046d7-127">Zur Ereignisverknüpfung in XAML gehört, dass Sie den Namen der Handlermethode, die Sie bereits definiert haben oder später im CodeBehind definieren werden, als Zeichenfolge angeben.</span><span class="sxs-lookup"><span data-stu-id="046d7-127">To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</span></span> <span data-ttu-id="046d7-128">Diese XAML definiert beispielsweise ein [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265)-Objekt mit anderen Eigenschaften ([x:Name-Attribut](x-name-attribute.md), [**Content**](https://msdn.microsoft.com/library/windows/apps/br209366)), die als Attribute zugewiesen sind, und verknüpft einen Handler für das [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737)-Ereignis der Schaltfläche durch einen Verweis auf eine Methode namens `ShowUpdatesButton_Click`:</span><span class="sxs-lookup"><span data-stu-id="046d7-128">For example, this XAML defines a [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) object with other properties ([x:Name attribute](x-name-attribute.md), [**Content**](https://msdn.microsoft.com/library/windows/apps/br209366)) assigned as attributes, and wires a handler for the button's [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) event by referencing a method named `ShowUpdatesButton_Click`:</span></span>

```xaml
<Button x:Name="showUpdatesButton"
  Content="{Binding ShowUpdatesText}"
  Click="ShowUpdatesButton_Click"/>
```

<span data-ttu-id="046d7-129">**Tipp:** *Ereignisverknüpfung* ist ein Begriff der Programmiersprache.</span><span class="sxs-lookup"><span data-stu-id="046d7-129">\**Tip\*\*\*Event wiring* is a programming term.</span></span> <span data-ttu-id="046d7-130">Er bezieht sich auf den Prozess oder Code, mit dem Sie angeben, dass Vorkommen eines Ereignisses eine benannte Handlermethode aufrufen sollen.</span><span class="sxs-lookup"><span data-stu-id="046d7-130">It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</span></span> <span data-ttu-id="046d7-131">In den meisten prozeduralen Codemodellen handelt es sich bei der Ereignisverknüpfung um impliziten oder expliziten „AddHandler“-Code, der sowohl das Ereignis als auch die Methode benennt und in der Regel eine Zielobjektinstanz verwendet.</span><span class="sxs-lookup"><span data-stu-id="046d7-131">In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</span></span> <span data-ttu-id="046d7-132">In XAML ist "AddHandler" implizit und die Ereignisverknüpfung umfasst nur das Benennen des Ereignisses als Attributnamen eines Objektelement und das Benennen des Handlers als Wert dieses Attributs.</span><span class="sxs-lookup"><span data-stu-id="046d7-132">In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</span></span>

<span data-ttu-id="046d7-133">Sie schreiben den eigentlichen Handler in der Programmiersprache, die Sie für Ihren gesamten App-Code oder CodeBehind verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-133">You write the actual handler in the programming language that you're using for all your app's code and code-behind.</span></span> <span data-ttu-id="046d7-134">Mit dem Attribut `Click="ShowUpdatesButton_Click"` haben Sie einen Vertrag erstellt, mit dem beim Kompilieren des Markups und Analysieren des XAML sowohl der XAML-Markupkompilierschritt in der Erstellungsaktion Ihrer IDE als auch die mögliche XAML-Analyse beim Laden der App eine Methode mit dem Namen `ShowUpdatesButton_Click` finden können, die Teil des App-Codes ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-134">With the attribute `Click="ShowUpdatesButton_Click"`, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named `ShowUpdatesButton_Click` as part of the app's code.</span></span> `ShowUpdatesButton_Click` <span data-ttu-id="046d7-135">muss eine Methode darstellen, die eine kompatible Methodensignatur (basierend auf einem Delegaten) für jeden Handler des [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737)-Ereignisses implementiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-135">must be a method that implements a compatible method signature (based on a delegate) for any handler of the [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) event.</span></span> <span data-ttu-id="046d7-136">Dieser Code definiert z.B. den `ShowUpdatesButton_Click`-Handler.</span><span class="sxs-lookup"><span data-stu-id="046d7-136">For example, this code defines the `ShowUpdatesButton_Click` handler.</span></span>

```csharp
private void ShowUpdatesButton_Click (object sender, RoutedEventArgs e) 
{
    Button b = sender as Button;
    //more logic to do here...
}
```

```vb
Private Sub ShowUpdatesButton_Click(ByVal sender As Object, ByVal e As RoutedEventArgs)
    Dim b As Button = CType(sender, Button)
    '  more logic to do here...
End Sub
```

```cppwinrt
void winrt::MyNamespace::implementation::BlankPage::ShowUpdatesButton_Click(Windows::Foundation::IInspectable const& sender, Windows::UI::Xaml::RoutedEventArgs const& e)
{
    auto b{ sender.as<Windows::UI::Xaml::Controls::Button>() };
    // More logic to do here.
}
```

```cpp
void MyNamespace::BlankPage::ShowUpdatesButton_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e) 
{
    Button^ b = (Button^) sender;
    //more logic to do here...
}
```

<span data-ttu-id="046d7-137">In diesem Beispiel basiert die `ShowUpdatesButton_Click`-Methode auf dem [**RoutedEventHandler**](https://msdn.microsoft.com/library/windows/apps/br208812)-Delegaten.</span><span class="sxs-lookup"><span data-stu-id="046d7-137">In this example, the `ShowUpdatesButton_Click` method is based on the [**RoutedEventHandler**](https://msdn.microsoft.com/library/windows/apps/br208812) delegate.</span></span> <span data-ttu-id="046d7-138">Sie wissen, dass dies der zu verwendende Delegat ist, weil er in der Syntax für die [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737)-Methode auf der MSDN-Referenzseite aufgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-138">You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) method on the MSDN reference page.</span></span>

<span data-ttu-id="046d7-139">**Tipp:** Visual Studio bietet eine bequeme Möglichkeit zum Benennen des ereignishandlers und zum Definieren der Handlermethode während der Bearbeitung XAML.</span><span class="sxs-lookup"><span data-stu-id="046d7-139">**Tip**Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</span></span> <span data-ttu-id="046d7-140">Wenn Sie den Attributnamen des Ereignisses im XAML-Text-Editor bereitstellen, warten Sie einen Moment, bis eine Microsoft IntelliSense-Liste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-140">When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</span></span> <span data-ttu-id="046d7-141">Wenn Sie in der Liste auf **&lt;Neuer Ereignishandler&gt;** klicken, schlägt Microsoft Visual Studio einen Methodennamen vor, der auf dem **x:Name** des Elements (oder der Typbezeichnung), dem Ereignisnamen und einem numerischen Suffix basiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-141">If you click **&lt;New Event Handler&gt;** from the list, Microsoft Visual Studio will suggest a method name based on the element's **x:Name** (or type name), the event name, and a numeric suffix.</span></span> <span data-ttu-id="046d7-142">Anschließend können Sie mit der rechten Maustaste auf den ausgewählten Ereignishandler und dann mit der linken Maustaste auf **Zum Ereignishandler navigieren** klicken.</span><span class="sxs-lookup"><span data-stu-id="046d7-142">You can then right-click the selected event handler name and click **Navigate to Event Handler**.</span></span> <span data-ttu-id="046d7-143">Dadurch navigieren Sie direkt zu der neu eingefügten Ereignishandlerdefinition, wie sie in der Code-Editoransicht Ihrer CodeBehind-Datei für die XAML-Seite angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-143">This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</span></span> <span data-ttu-id="046d7-144">Der Ereignishandler hat bereits die richtige Signatur, einschließlich des *sender*-Parameters und der Ereignisdatenklasse, die von dem Ereignis verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-144">The event handler already has the correct signature, including the *sender* parameter and the event data class that the event uses.</span></span> <span data-ttu-id="046d7-145">Wenn zudem bereits eine Handlermethode mit der richtigen Signatur im CodeBehind vorhanden ist, wird der Name dieser Methode zusammen mit der Option **&lt;Neuer Ereignishandler&gt;** im Auto-Vervollständigen-Dropdown angezeigt.</span><span class="sxs-lookup"><span data-stu-id="046d7-145">Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the **&lt;New Event Handler&gt;** option.</span></span> <span data-ttu-id="046d7-146">Sie können auch die Tabulatortaste drücken, anstatt auf die IntelliSense-Listenelemente zu klicken.</span><span class="sxs-lookup"><span data-stu-id="046d7-146">You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</span></span>

## <a name="defining-an-event-handler"></a><span data-ttu-id="046d7-147">Definieren eines Ereignishandlers</span><span class="sxs-lookup"><span data-stu-id="046d7-147">Defining an event handler</span></span>

<span data-ttu-id="046d7-148">Für Objekte, die UI-Elemente darstellen und in XAML deklariert werden, wird Ereignishandlercode in der partiellen Klasse definiert, die als CodeBehind für eine XAML-Seite fungiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-148">For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</span></span> <span data-ttu-id="046d7-149">Ereignishandler sind Methoden, die Sie als Teil der Ihrem XAML zugeordneten partiellen Klasse schreiben.</span><span class="sxs-lookup"><span data-stu-id="046d7-149">Event handlers are methods that you write as part of the partial class that is associated with your XAML.</span></span> <span data-ttu-id="046d7-150">Diese Ereignishandler basieren auf den Delegaten, die von einem bestimmten Ereignis verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-150">These event handlers are based on the delegates that a particular event uses.</span></span> <span data-ttu-id="046d7-151">Die Ereignishandlermethoden können öffentlich oder privat sein.</span><span class="sxs-lookup"><span data-stu-id="046d7-151">Your event handler methods can be public or private.</span></span> <span data-ttu-id="046d7-152">Der private Zugriff funktioniert, weil der vom XAML erstellte Handler und die Instanz letztendlich durch die Codegenerierung verbunden werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-152">Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</span></span> <span data-ttu-id="046d7-153">Im Allgemeinen wird empfohlen, die Ereignishandlermethoden in der Klasse öffentlich zu machen.</span><span class="sxs-lookup"><span data-stu-id="046d7-153">In general, we recommend that you make your event handler methods private in the class.</span></span>

<span data-ttu-id="046d7-154">**Hinweis:** Ereignishandler für C++ nicht in partiellen Klassen definiert, sie im Header als private Klassenmember deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-154">**Note**Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</span></span> <span data-ttu-id="046d7-155">Bei den Erstellungsaktionen für ein C++-Projekt wird Code generiert, der das XAML-Typsystem und das CodeBehind-Modell für C++ unterstützt.</span><span class="sxs-lookup"><span data-stu-id="046d7-155">The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</span></span>

### <a name="the-sender-parameter-and-event-data"></a><span data-ttu-id="046d7-156">Der *sender*-Parameter und Ereignisdaten</span><span class="sxs-lookup"><span data-stu-id="046d7-156">The *sender* parameter and event data</span></span>

<span data-ttu-id="046d7-157">Der Handler, den Sie für das Ereignis schreiben, kann auf zwei Werte zugreifen. Diese Werte sind jedes Mal als Eingabe verfügbar, wenn der Handler aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-157">The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</span></span> <span data-ttu-id="046d7-158">Der erste Wert ist *sender*. Dabei handelt es sich um einen Verweis auf das Objekt, dem der Handler angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-158">The first such value is *sender*, which is a reference to the object where the handler is attached.</span></span> <span data-ttu-id="046d7-159">Der *sender*-Parameter ist als **Object**-Basistyp typisiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-159">The *sender* parameter is typed as the base **Object** type.</span></span> <span data-ttu-id="046d7-160">Häufig wird *sender* in einen präziseren Typ umgewandelt.</span><span class="sxs-lookup"><span data-stu-id="046d7-160">A common technique is to cast *sender* to a more precise type.</span></span> <span data-ttu-id="046d7-161">Diese Maßnahme ist nützlich, wenn Sie beabsichtigen, den Zustand direkt für das *sender*-Objekt zu überprüfen oder zu ändern.</span><span class="sxs-lookup"><span data-stu-id="046d7-161">This technique is useful if you expect to check or change state on the *sender* object itself.</span></span> <span data-ttu-id="046d7-162">Abhängig davon, wo der Handler angefügt wird, und von anderen Designmerkmalen wissen Sie bei Ihrem eigenen App-Design in der Regel, dass es sich um einen Typ handelt, in den *sender* sicher umgewandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-162">Based on your own app design, you usually know a type that is safe to cast *sender* to, based on where the handler is attached or other design specifics.</span></span>

<span data-ttu-id="046d7-163">Den zweiten Wert stellen Ereignisdaten dar. In der Regel sind diese in Syntaxdefinitionen als *e*-Parameter enthalten.</span><span class="sxs-lookup"><span data-stu-id="046d7-163">The second value is event data, which generally appears in syntax definitions as the *e* parameter.</span></span> <span data-ttu-id="046d7-164">Wenn Sie feststellen möchten, welche Eigenschaften für Ereignisdaten verfügbar sind, prüfen Sie den *e*-Parameter des Delegaten, der dem behandelten Ereignis zugewiesen ist. Verwenden Sie dann IntelliSense oder den Objektkatalog in Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="046d7-164">You can discover which properties for event data are available by looking at the *e* parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</span></span> <span data-ttu-id="046d7-165">Sie können auch in der Referenzdokumentation von Windows Runtime nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="046d7-165">Or you can use the Windows Runtime reference documentation.</span></span>

<span data-ttu-id="046d7-166">Bei einigen Ereignissen ist die Kenntnis der speziellen Eigenschaftswerte der Ereignisdaten so wichtig wie die Kenntnis, dass das Ereignis eingetreten ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-166">For some events, the event data's specific property values are as important as knowing that the event occurred.</span></span> <span data-ttu-id="046d7-167">Das gilt speziell bei Eingabeereignissen.</span><span class="sxs-lookup"><span data-stu-id="046d7-167">This is especially true of the input events.</span></span> <span data-ttu-id="046d7-168">Bei Zeigerereignissen kann die Position des Zeigers beim Auslösen des Ereignisses wichtig sein.</span><span class="sxs-lookup"><span data-stu-id="046d7-168">For pointer events, the position of the pointer when the event occurred might be important.</span></span> <span data-ttu-id="046d7-169">Bei Tastaturereignissen wird durch alle möglichen Tastendrücke ein [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941)- und [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942)-Ereignis ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="046d7-169">For keyboard events, all possible key presses fire a [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) event.</span></span> <span data-ttu-id="046d7-170">Um zu bestimmen, welche Taste von einem Benutzer gedrückt wurde, müssen Sie auf die [**KeyRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943072)-Klasse zugreifen, die für den Ereignishandler verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-170">To determine which key a user pressed, you must access the [**KeyRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943072) that is available to the event handler.</span></span> <span data-ttu-id="046d7-171">Weitere Informationen zur Behandlung von Eingabeereignissen finden Sie unter [Tastaturinteraktionen](https://msdn.microsoft.com/library/windows/apps/mt185607) und [Behandeln von Zeigereingaben](https://msdn.microsoft.com/library/windows/apps/mt404610).</span><span class="sxs-lookup"><span data-stu-id="046d7-171">For more info about handling input events, see [Keyboard interactions](https://msdn.microsoft.com/library/windows/apps/mt185607) and [Handle pointer input](https://msdn.microsoft.com/library/windows/apps/mt404610).</span></span> <span data-ttu-id="046d7-172">Bei Eingabeereignissen und Eingabeszenarien gibt es häufig weitere Überlegungen, die in diesem Thema nicht behandelt werden, wie das Erfassen des Zeigers bei Zeigerereignissen oder Zusatztasten und Plattformtastencodes für Tastaturereignisse.</span><span class="sxs-lookup"><span data-stu-id="046d7-172">Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</span></span>

### <a name="event-handlers-that-use-the-async-pattern"></a><span data-ttu-id="046d7-173">Ereignishandler, die das **async**-Muster verwenden</span><span class="sxs-lookup"><span data-stu-id="046d7-173">Event handlers that use the **async** pattern</span></span>

<span data-ttu-id="046d7-174">In einigen Fällen wird die Verwendung von APIs empfohlen, die innerhalb eines Ereignishandlers ein **async**-Muster verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-174">In some cases you'll want to use APIs that use an **async** pattern within an event handler.</span></span> <span data-ttu-id="046d7-175">Beispielsweise können Sie einen [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) auf einer [**AppBar**](https://msdn.microsoft.com/library/windows/apps/hh701927) verwenden, um eine Dateiauswahl anzuzeigen und mit dieser zu interagieren.</span><span class="sxs-lookup"><span data-stu-id="046d7-175">For example, you might use a [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) in an [**AppBar**](https://msdn.microsoft.com/library/windows/apps/hh701927) to display a file picker and interact with it.</span></span> <span data-ttu-id="046d7-176">Viele der Dateiauswahl-APIs sind jedoch asynchron.</span><span class="sxs-lookup"><span data-stu-id="046d7-176">However, many of the file picker APIs are asynchronous.</span></span> <span data-ttu-id="046d7-177">Sie müssen innerhalb eines **async**/awaitable-Bereichs aufgerufen werden. Dies wird vom Compiler erzwungen.</span><span class="sxs-lookup"><span data-stu-id="046d7-177">They have to be called within an **async**/awaitable scope, and the compiler will enforce this.</span></span> <span data-ttu-id="046d7-178">Sie können dem Ereignishandler das **async**-Schlüsselwort hinzuzufügen, sodass der Handler nun **async** **void** ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-178">So what you can do is add the **async** keyword to your event handler such that the handler is now **async** **void**.</span></span> <span data-ttu-id="046d7-179">Nun kann der Ereignishandler **async**/awaitable-Aufrufe ausführen.</span><span class="sxs-lookup"><span data-stu-id="046d7-179">Now your event handler is permitted to make **async**/awaitable calls.</span></span>

<span data-ttu-id="046d7-180">Ein Beispiel für die Benutzerinteraktions-Ereignisbehandlung mit dem **async**-Muster finden Sie unter [Dateizugriff und -auswahl](https://msdn.microsoft.com/library/windows/apps/jj655411) (in der Reihe [Erstellen Ihrer ersten Windows-Runtime-App mit C# oder Visual Basic](https://msdn.microsoft.com/library/windows/apps/hh974581)).</span><span class="sxs-lookup"><span data-stu-id="046d7-180">For an example of user-interaction event handling using the **async** pattern, see [File access and pickers](https://msdn.microsoft.com/library/windows/apps/jj655411) (part of the[Create your first Windows Runtime app using C# or Visual Basic](https://msdn.microsoft.com/library/windows/apps/hh974581) series).</span></span> <span data-ttu-id="046d7-181">Siehe auch [Aufrufen asynchroner APIs in C].</span><span class="sxs-lookup"><span data-stu-id="046d7-181">See also [Call asynchronous APIs in C).</span></span>

## <a name="adding-event-handlers-in-code"></a><span data-ttu-id="046d7-182">Hinzufügen von Ereignishandlern im Code</span><span class="sxs-lookup"><span data-stu-id="046d7-182">Adding event handlers in code</span></span>

<span data-ttu-id="046d7-183">Es gibt noch andere Möglichkeiten als XAML, um einem Objekt einen Ereignishandler zuzuweisen.</span><span class="sxs-lookup"><span data-stu-id="046d7-183">XAML is not the only way to assign an event handler to an object.</span></span> <span data-ttu-id="046d7-184">Sie können die spezielle Syntax zum Hinzufügen von Ereignishandlern einer Sprache nutzen, um bestimmten Objekten (auch Objekten, die in XAML nicht verwendet werden können) Ereignishandler im Code hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="046d7-184">To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</span></span>

<span data-ttu-id="046d7-185">In C# wird für die Syntax der `+=`-Operator verwendet.</span><span class="sxs-lookup"><span data-stu-id="046d7-185">In C#, the syntax is to use the `+=` operator.</span></span> <span data-ttu-id="046d7-186">Sie registrieren den Handler, indem Sie auf der rechten Seite des Operators auf den Namen der Ereignishandlermethode verweisen.</span><span class="sxs-lookup"><span data-stu-id="046d7-186">You register the handler by referencing the event handler method name on the right side of the operator.</span></span>

<span data-ttu-id="046d7-187">Wenn Objekten, die in der Laufzeit-UI angezeigt werden, Ereignishandler per Code hinzugefügt werden, ist es üblich, diese Handler als Reaktion auf ein Objektlebensdauer-Ereignis oder einen Rückruf hinzuzufügen, wie z.B. [**Loaded**](https://msdn.microsoft.com/library/windows/apps/br208723) oder [**OnApplyTemplate**](https://msdn.microsoft.com/library/windows/apps/br208737). Die Ereignishandler für das relevante Objekt stehen dann zur Laufzeit für Ereignisse bereit, die von Benutzern eingeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-187">If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as [**Loaded**](https://msdn.microsoft.com/library/windows/apps/br208723) or [**OnApplyTemplate**](https://msdn.microsoft.com/library/windows/apps/br208737), so that the event handlers on the relevant object are ready for user-initiated events at run time.</span></span> <span data-ttu-id="046d7-188">Dieses Beispiel zeigt eine XAML-Gliederung der Seitenstruktur und führt anschließend die C#-Sprachsyntax für das Hinzufügen eines Ereignishandlers zu einem Objekt auf.</span><span class="sxs-lookup"><span data-stu-id="046d7-188">This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</span></span>

```xaml
<Grid x:Name="LayoutRoot" Loaded="LayoutRoot_Loaded">
  <StackPanel>
    <TextBlock Name="textBlock1">Put the pointer over this text</TextBlock>
...
  </StackPanel>
</Grid>
```

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += textBlock1_PointerEntered;
    textBlock1.PointerExited += textBlock1_PointerExited;
}
```

<span data-ttu-id="046d7-189">**Hinweis:** eine ausführlichere Syntax.</span><span class="sxs-lookup"><span data-stu-id="046d7-189">**Note**A more verbose syntax exists.</span></span> <span data-ttu-id="046d7-190">2005 wurde in C# der Rückschluss auf Delegaten als neues Feature eingeführt. Damit kann der Compiler die neue Delegatinstanz ableiten, und die vorherige, einfachere Syntax kann verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-190">In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</span></span> <span data-ttu-id="046d7-191">Die Funktion der ausführlichen Syntax entspricht dem vorherigen Beispiel. Vor der Registrierung wird jedoch explizit eine neue Delegatinstanz erstellt. Der Delegatrückschluss wird somit nicht genutzt.</span><span class="sxs-lookup"><span data-stu-id="046d7-191">The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</span></span> <span data-ttu-id="046d7-192">Diese explizite Syntax ist zwar nicht so üblich, aber dennoch in einigen Codebeispielen anzutreffen.</span><span class="sxs-lookup"><span data-stu-id="046d7-192">This explicit syntax is less common, but you might still see it in some code examples.</span></span>

```csharp
void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
{
    textBlock1.PointerEntered += new PointerEventHandler(textBlock1_PointerEntered);
    textBlock1.PointerExited += new MouseEventHandler(textBlock1_PointerExited);
}
```

<span data-ttu-id="046d7-193">Für Visual Basic-Syntax gibt es zwei Möglichkeiten</span><span class="sxs-lookup"><span data-stu-id="046d7-193">There are two possibilities for Visual Basic syntax.</span></span> <span data-ttu-id="046d7-194">Sie können eine parallele C#-Syntax verwenden und den Instanzen die Handler direkt anfügen.</span><span class="sxs-lookup"><span data-stu-id="046d7-194">One is to parallel the C# syntax and attach handlers directly to instances.</span></span> <span data-ttu-id="046d7-195">Dazu benötigen Sie das **AddHandler**-Schlüsselwort und den **AddressOf**-Operator, der den Handlermethodennamen dereferenziert.</span><span class="sxs-lookup"><span data-stu-id="046d7-195">This requires the **AddHandler** keyword and also the **AddressOf** operator that dereferences the handler method name.</span></span>

<span data-ttu-id="046d7-196">Die zweite Möglichkeit für die Visual Basic-Syntax besteht darin, das **Handles**-Schlüsselwort für Ereignishandler zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-196">The other option for Visual Basic syntax is to use the **Handles** keyword on event handlers.</span></span> <span data-ttu-id="046d7-197">Das ist in Fällen angebracht, in denen beim Laden voraussichtlich Handler für Objekte vorhanden sind und für die Objektlebensdauer bestehen bleiben.</span><span class="sxs-lookup"><span data-stu-id="046d7-197">This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</span></span> <span data-ttu-id="046d7-198">Wenn Sie **Handles** für ein in XAML definiertes Objekt verwenden, müssen Sie einen **Name** / **x:Name** bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="046d7-198">Using **Handles** on an object that is defined in XAML requires that you provide a **Name** / **x:Name**.</span></span> <span data-ttu-id="046d7-199">Dieser Name wird zum Instanzenqualifizierer, der für den *Instance.Event*-Teil der **Handles**-Syntax benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-199">This name becomes the instance qualifier that is needed for the *Instance.Event* part of the **Handles** syntax.</span></span> <span data-ttu-id="046d7-200">In diesem Fall benötigen Sie keinen Ereignishandler, der auf der Objektlebensdauer basiert, um das Anfügen der anderen Ereignishandler einzuleiten. Die **Handles**-Verbindungen werden beim Kompilieren der XAML-Seite erstellt.</span><span class="sxs-lookup"><span data-stu-id="046d7-200">In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the **Handles** connections are created when you compile your XAML page.</span></span>

```vb
Private Sub textBlock1_PointerEntered(ByVal sender As Object, ByVal e As PointerRoutedEventArgs) Handles textBlock1.PointerEntered
' ...
End Sub
```

<span data-ttu-id="046d7-201">**Hinweis:** Visual Studio und die zugehörige XAML-Entwurfsoberfläche in der Regel instanzbehandlung Instanz-Behandlung anstelle des Schlüsselworts **behandelt** .</span><span class="sxs-lookup"><span data-stu-id="046d7-201">**Note**Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the **Handles** keyword.</span></span> <span data-ttu-id="046d7-202">Das Erstellen der Ereignishandlerverknüpfung in XAML ist Teil eines typischen Designer-Entwickler-Workflows, und die **Handles**-Schlüsselworttechnik ist mit dem Verknüpfen der Ereignishandler in XAML nicht kompatibel.</span><span class="sxs-lookup"><span data-stu-id="046d7-202">This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the **Handles** keyword technique is incompatible with wiring the event handlers in XAML.</span></span>

<span data-ttu-id="046d7-203">In C++ / CX verwenden Sie auch die **+=** Syntax, es gibt jedoch Unterschiede zum Allgemeinen C#-Format:</span><span class="sxs-lookup"><span data-stu-id="046d7-203">In C++/CX, you also use the **+=** syntax, but there are differences from the basic C# form:</span></span>

-   <span data-ttu-id="046d7-204">Es gibt keinen Rückschluss auf Delegaten. Sie müssen deshalb **ref new** für die Delegatinstanz verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-204">No delegate inference exists, so you must use **ref new** for the delegate instance.</span></span>
-   <span data-ttu-id="046d7-205">Der Delegatkonstruktor besitzt zwei Parameter und benötigt das Zielobjekt als ersten Parameter.</span><span class="sxs-lookup"><span data-stu-id="046d7-205">The delegate constructor has two parameters, and requires the target object as the first parameter.</span></span> <span data-ttu-id="046d7-206">Normalerweise geben Sie **this** an.</span><span class="sxs-lookup"><span data-stu-id="046d7-206">Typically you specify **this**.</span></span>
-   <span data-ttu-id="046d7-207">Der Delegatenkonstruktor erfordert die Methodenadresse als zweiten Parameter, sodass der **&**-Verweisoperator vor dem Methodennamen steht.</span><span class="sxs-lookup"><span data-stu-id="046d7-207">The delegate constructor requires the method address as the second parameter, so the **&** reference operator precedes the method name.</span></span>

```cppwinrt
textBlock1().PointerEntered({this, &MainPage::TextBlock1_PointerEntered });
```

```cpp
textBlock1->PointerEntered += 
ref new PointerEventHandler(this, &BlankPage::textBlock1_PointerEntered);
```

### <a name="removing-event-handlers-in-code"></a><span data-ttu-id="046d7-208">Entfernen von Ereignishandlern im Code</span><span class="sxs-lookup"><span data-stu-id="046d7-208">Removing event handlers in code</span></span>

<span data-ttu-id="046d7-209">Das Entfernen von Ereignishandlern im Code ist in der Regel nicht erforderlich, auch wenn sie von Ihnen im Code hinzugefügt wurden.</span><span class="sxs-lookup"><span data-stu-id="046d7-209">It's not usually necessary to remove event handlers in code, even if you added them in code.</span></span> <span data-ttu-id="046d7-210">Das Verhalten der Objektlebensdauer für die meisten Windows-Runtime-Objekte, z.B. Seiten und Steuerelemente, vernichtet die Objekte, wenn die Verbindung mit dem Haupt-[**Fenster**](https://msdn.microsoft.com/library/windows/apps/br209041) und der dazugehörigen visuellen Struktur getrennt wird. Vorhandene Delegatverweise werden ebenfalls vernichtet.</span><span class="sxs-lookup"><span data-stu-id="046d7-210">The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) and its visual tree, and any delegate references are destroyed too.</span></span> <span data-ttu-id="046d7-211">In .NET erfolgt dies durch eine Garbage Collection, und in Windows-Runtime mit C++/CX werden standardmäßig schwache Verweise verwendet.</span><span class="sxs-lookup"><span data-stu-id="046d7-211">.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</span></span>

<span data-ttu-id="046d7-212">In einigen seltenen Fällen sollten Ereignishandler explizit entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-212">There are some rare cases where you do want to remove event handlers explicitly.</span></span> <span data-ttu-id="046d7-213">Dazu zählen:</span><span class="sxs-lookup"><span data-stu-id="046d7-213">These include:</span></span>

-   <span data-ttu-id="046d7-214">Für statische Ereignisse hinzugefügte Handler, für die keine konventionelle Garbage Collection durchgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-214">Handlers you added for static events, which can't get garbage-collected in a conventional way.</span></span> <span data-ttu-id="046d7-215">Die Ereignisse der Klassen [**CompositionTarget**](https://msdn.microsoft.com/library/windows/apps/br228126) und [**Clipboard**](https://msdn.microsoft.com/library/windows/apps/br205867) sind Beispiele für statische Ereignisse in der Windows-Runtime-API.</span><span class="sxs-lookup"><span data-stu-id="046d7-215">Examples of static events in the Windows Runtime API are the events of the [**CompositionTarget**](https://msdn.microsoft.com/library/windows/apps/br228126) and [**Clipboard**](https://msdn.microsoft.com/library/windows/apps/br205867) classes.</span></span>
-   <span data-ttu-id="046d7-216">Testen Sie Code, wenn Sie Handler sofort entfernen möchten, oder Code, in dem alte und neue Ereignishandler für ein Ereignis zur Laufzeit ausgetauscht werden sollen.</span><span class="sxs-lookup"><span data-stu-id="046d7-216">Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</span></span>
-   <span data-ttu-id="046d7-217">Die Implementierung eines benutzerdefinierten **remove**-Accessors</span><span class="sxs-lookup"><span data-stu-id="046d7-217">The implementation of a custom **remove** accessor.</span></span>
-   <span data-ttu-id="046d7-218">Benutzerdefinierte statische Ereignisse</span><span class="sxs-lookup"><span data-stu-id="046d7-218">Custom static events.</span></span>
-   <span data-ttu-id="046d7-219">Handler für Seitennavigationen</span><span class="sxs-lookup"><span data-stu-id="046d7-219">Handlers for page navigations.</span></span>

<span data-ttu-id="046d7-220">[**FrameworkElement.Unloaded**](https://msdn.microsoft.com/library/windows/apps/br208748) oder [**Page.NavigatedFrom**](https://msdn.microsoft.com/library/windows/apps/br227507) sind mögliche Ereignisauslöser mit entsprechenden Positionen in der Zustandsverwaltung und der Objektlebensdauer, sodass sie zum Entfernen von Handlern für andere Ereignisse verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="046d7-220">[**FrameworkElement.Unloaded**](https://msdn.microsoft.com/library/windows/apps/br208748) or [**Page.NavigatedFrom**](https://msdn.microsoft.com/library/windows/apps/br227507) are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</span></span>

<span data-ttu-id="046d7-221">Beispielsweise können Sie mit diesem Code einen Ereignishandler mit dem Namen **textBlock1\_PointerEntered** aus dem Zielobjekt **textBlock1** entfernen.</span><span class="sxs-lookup"><span data-stu-id="046d7-221">For example, you can remove an event handler named **textBlock1\_PointerEntered** from the target object **textBlock1** using this code.</span></span>

```csharp
textBlock1.PointerEntered -= textBlock1_PointerEntered;
```

```vb
RemoveHandler textBlock1.PointerEntered, AddressOf textBlock1_PointerEntered
```

<span data-ttu-id="046d7-222">Sie können Handler auch in solchen Fällen entfernen, in denen das Ereignis über ein XAML-Attribut hinzugefügt wurde, was bedeutet, dass der Handler in generiertem Code hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="046d7-222">You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</span></span> <span data-ttu-id="046d7-223">Dies ist einfacher, wenn Sie einen **Name**-Wert für das Element bereitstellen, dem der Handler angehängt wurde, da hierdurch später ein Objektverweis für den Code bereitgestellt wird. Sie können jedoch auch in der Objektstruktur nach dem erforderlichen Objekt suchen, wenn kein **Name** für das Objekt vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-223">This is easier to do if you provided a **Name** value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no **Name**.</span></span>

<span data-ttu-id="046d7-224">Wenn Sie einen Ereignishandler in C++/CX entfernen müssen, benötigen Sie ein Registrierungstoken, das Sie im Rückgabewert der `+=`-Ereignishandlerregistrierung erhalten haben sollten.</span><span class="sxs-lookup"><span data-stu-id="046d7-224">If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the `+=` event handler registration.</span></span> <span data-ttu-id="046d7-225">Der Grund ist, dass es sich bei dem Wert, den Sie für die rechte Seite der Aufhebung der `-=`-Registrierung in C++/CX-Syntax verwenden, um das Token handelt, nicht beim Methodennamen.</span><span class="sxs-lookup"><span data-stu-id="046d7-225">That's because the value you use for the right side of the `-=` deregistration in the C++/CX syntax is the token, not the method name.</span></span> <span data-ttu-id="046d7-226">Für C++/CX können Sie als XAML-Attribut hinzugefügte Handler nicht entfernen, da der generierte C++/CX-Code kein Token speichert.</span><span class="sxs-lookup"><span data-stu-id="046d7-226">For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</span></span>

## <a name="routed-events"></a><span data-ttu-id="046d7-227">Routingereignisse</span><span class="sxs-lookup"><span data-stu-id="046d7-227">Routed events</span></span>

<span data-ttu-id="046d7-228">Die Windows-Runtime mit C#, Microsoft Visual Basic oder C++/CX unterstützt das Konzept von Routingereignissen für eine Gruppe von Ereignissen, die für die meisten UI-Elementen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-228">The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</span></span> <span data-ttu-id="046d7-229">Diese Ereignisse werden für Eingabe- und Benutzerinteraktionsszenarien verwendet und in der [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911)-Basisklasse implementiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-229">These events are for input and user interaction scenarios, and they are implemented on the [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) base class.</span></span> <span data-ttu-id="046d7-230">Die folgenden Eingabeereignisse sind Routingereignisse:</span><span class="sxs-lookup"><span data-stu-id="046d7-230">Here's a list of input events that are routed events:</span></span>

-   [**<span data-ttu-id="046d7-231">DoubleTapped</span><span class="sxs-lookup"><span data-stu-id="046d7-231">DoubleTapped</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208922)
-   [**<span data-ttu-id="046d7-232">DragEnter</span><span class="sxs-lookup"><span data-stu-id="046d7-232">DragEnter</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208923)
-   [**<span data-ttu-id="046d7-233">DragLeave</span><span class="sxs-lookup"><span data-stu-id="046d7-233">DragLeave</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208924)
-   [**<span data-ttu-id="046d7-234">DragOver</span><span class="sxs-lookup"><span data-stu-id="046d7-234">DragOver</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208925)
-   [**<span data-ttu-id="046d7-235">Drop</span><span class="sxs-lookup"><span data-stu-id="046d7-235">Drop</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208926)
-   [**<span data-ttu-id="046d7-236">Holding</span><span class="sxs-lookup"><span data-stu-id="046d7-236">Holding</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208928)
-   [**<span data-ttu-id="046d7-237">KeyDown</span><span class="sxs-lookup"><span data-stu-id="046d7-237">KeyDown</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208941)
-   [**<span data-ttu-id="046d7-238">KeyUp</span><span class="sxs-lookup"><span data-stu-id="046d7-238">KeyUp</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208942)
-   [**<span data-ttu-id="046d7-239">ManipulationCompleted</span><span class="sxs-lookup"><span data-stu-id="046d7-239">ManipulationCompleted</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208945)
-   [**<span data-ttu-id="046d7-240">ManipulationDelta</span><span class="sxs-lookup"><span data-stu-id="046d7-240">ManipulationDelta</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208946)
-   [**<span data-ttu-id="046d7-241">ManipulationInertiaStarting</span><span class="sxs-lookup"><span data-stu-id="046d7-241">ManipulationInertiaStarting</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208947)
-   [**<span data-ttu-id="046d7-242">ManipulationStarted</span><span class="sxs-lookup"><span data-stu-id="046d7-242">ManipulationStarted</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208950)
-   [**<span data-ttu-id="046d7-243">ManipulationStarting</span><span class="sxs-lookup"><span data-stu-id="046d7-243">ManipulationStarting</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208951)
-   [**<span data-ttu-id="046d7-244">PointerCanceled</span><span class="sxs-lookup"><span data-stu-id="046d7-244">PointerCanceled</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208964)
-   [**<span data-ttu-id="046d7-245">PointerCaptureLost</span><span class="sxs-lookup"><span data-stu-id="046d7-245">PointerCaptureLost</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208965)
-   [**<span data-ttu-id="046d7-246">PointerEntered</span><span class="sxs-lookup"><span data-stu-id="046d7-246">PointerEntered</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208968)
-   [**<span data-ttu-id="046d7-247">PointerExited</span><span class="sxs-lookup"><span data-stu-id="046d7-247">PointerExited</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208969)
-   [**<span data-ttu-id="046d7-248">PointerMoved</span><span class="sxs-lookup"><span data-stu-id="046d7-248">PointerMoved</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208970)
-   [**<span data-ttu-id="046d7-249">PointerPressed</span><span class="sxs-lookup"><span data-stu-id="046d7-249">PointerPressed</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208971)
-   [**<span data-ttu-id="046d7-250">PointerReleased</span><span class="sxs-lookup"><span data-stu-id="046d7-250">PointerReleased</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208972)
-   [**<span data-ttu-id="046d7-251">PointerWheelChanged</span><span class="sxs-lookup"><span data-stu-id="046d7-251">PointerWheelChanged</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208973)
-   [**<span data-ttu-id="046d7-252">RightTapped</span><span class="sxs-lookup"><span data-stu-id="046d7-252">RightTapped</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208984)
-   [**<span data-ttu-id="046d7-253">Tapped</span><span class="sxs-lookup"><span data-stu-id="046d7-253">Tapped</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208985)
-   [**<span data-ttu-id="046d7-254">GotFocus</span><span class="sxs-lookup"><span data-stu-id="046d7-254">GotFocus</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208927)
-   [**<span data-ttu-id="046d7-255">LostFocus</span><span class="sxs-lookup"><span data-stu-id="046d7-255">LostFocus</span></span>**](https://msdn.microsoft.com/library/windows/apps/br208943)

<span data-ttu-id="046d7-256">Ein Routingereignis ist ein Ereignis, das möglicherweise von einem untergeordneten Objekt an jedes seiner übergeordneten Objekte in der Objektstruktur weitergeleitet (*geroutet*) wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-256">A routed event is an event that is potentially passed on (*routed*) from a child object to each of its successive parent objects in an object tree.</span></span> <span data-ttu-id="046d7-257">Die XAML-Struktur Ihrer UI kommt dieser Struktur nahe, wobei der Stamm der Struktur dem Stammelement im XAML entspricht.</span><span class="sxs-lookup"><span data-stu-id="046d7-257">The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</span></span> <span data-ttu-id="046d7-258">Die tatsächliche Objektstruktur kann sich von der XAML-Elementschachtelung unterscheiden, da die Objektstruktur keine XAML-Sprachfeatures wie Eigenschaftenelementtags enthält.</span><span class="sxs-lookup"><span data-stu-id="046d7-258">The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</span></span> <span data-ttu-id="046d7-259">Routingereignisse durchlaufen die Struktur nach dem *Bubblingkonzept* von untergeordneten XAML-Objektelementen, die das Ereignis auslösen, zu den übergeordneten Objekten, in denen sie enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="046d7-259">You can conceive of the routed event as *bubbling* from any XAML object element child element that fires the event, toward the parent object element that contains it.</span></span> <span data-ttu-id="046d7-260">Das Ereignis und seine Ereignisdaten können für mehrere Objekte entlang der Ereignisroute behandelt werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-260">The event and its event data can be handled on multiple objects along the event route.</span></span> <span data-ttu-id="046d7-261">Wenn kein Element über Handler verfügt, wird die Route u.U. bis zum Stammelement fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="046d7-261">If no element has handlers, the route potentially keeps going until the root element is reached.</span></span>

<span data-ttu-id="046d7-262">Wenn Sie Webtechnologien wie Dynamic HTML (DHTML) oder HTML5 kennen, sind Sie möglicherweise bereits mit dem *Bubbling*-Ereigniskonzept vertraut.</span><span class="sxs-lookup"><span data-stu-id="046d7-262">If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the *bubbling* event concept.</span></span>

<span data-ttu-id="046d7-263">Wenn für ein Routingereignis ein Bubbling durch die zugehörige Ereignisroute erfolgt, greifen alle angefügten Ereignishandler auf eine freigegebene Instanz von Ereignisdaten zu.</span><span class="sxs-lookup"><span data-stu-id="046d7-263">When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</span></span> <span data-ttu-id="046d7-264">Deshalb werden Änderungen an Ereignisdaten an den nächsten Handler weitergegeben, wenn einer der Handler Schreibzugriff auf Ereignisdaten besitzt. Die Daten entsprechen dann möglicherweise nicht mehr den ursprünglichen Ereignisdaten.</span><span class="sxs-lookup"><span data-stu-id="046d7-264">Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</span></span> <span data-ttu-id="046d7-265">Wenn ein Ereignis ein Routingereignisverhalten besitzt, wird in der Referenzdokumentation entsprechend darauf hingewiesen.</span><span class="sxs-lookup"><span data-stu-id="046d7-265">When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</span></span>

### <a name="the-originalsource-property-of-routedeventargs"></a><span data-ttu-id="046d7-266">Die Eigenschaft **OriginalSource** von **RoutedEventArgs**</span><span class="sxs-lookup"><span data-stu-id="046d7-266">The **OriginalSource** property of **RoutedEventArgs**</span></span>

<span data-ttu-id="046d7-267">Wenn ein Ereignis entlang einer Route ein Bubbling durchläuft, ist *sender* nicht mehr das gleiche Objekt, das das Ereignis ausgelöst hat.</span><span class="sxs-lookup"><span data-stu-id="046d7-267">When an event bubbles up an event route, *sender* is no longer the same object as the event-raising object.</span></span> <span data-ttu-id="046d7-268">Stattdessen ist *sender* das Objekt, an das der aufgerufene Handler angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-268">Instead, *sender* is the object where the handler that is being invoked is attached.</span></span>

<span data-ttu-id="046d7-269">In einigen Fällen interessieren Sie sich nicht für das *sender*-Objekt, sondern eher dafür, auf welchem der möglichen untergeordneten Objekte sich der Mauszeiger beim Auslösen eines Zeigerereignisses befindet oder welches Objekt in einer größeren UI beim Drücken einer Taste den Fokus hatte.</span><span class="sxs-lookup"><span data-stu-id="046d7-269">In some cases, *sender* is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</span></span> <span data-ttu-id="046d7-270">Für diese Fälle können Sie den Wert der [**OriginalSource**](https://msdn.microsoft.com/library/windows/apps/br208810)-Eigenschaft verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-270">For these cases, you can use the value of the [**OriginalSource**](https://msdn.microsoft.com/library/windows/apps/br208810) property.</span></span> <span data-ttu-id="046d7-271">An allen Punkten in der Route meldet **OriginalSource** das ursprüngliche Objekt, von dem das Ereignis ausgelöst wurde, und nicht das Objekt, dem der Handler angefügt ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-271">At all points on the route, **OriginalSource** reports the original object that fired the event, instead of the object where the handler is attached.</span></span> <span data-ttu-id="046d7-272">Bei [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911)-Eingabeereignissen ist das ursprüngliche Objekt jedoch häufig ein Objekt, das nicht direkt im XAML für die UI-Definition auf Seitenebene sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-272">However, for [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</span></span> <span data-ttu-id="046d7-273">Stattdessen kann das ursprüngliche Quellobjekt ein Vorlagenteil eines Steuerelements sein.</span><span class="sxs-lookup"><span data-stu-id="046d7-273">Instead, that original source object might be a templated part of a control.</span></span> <span data-ttu-id="046d7-274">Wenn der Benutzer beispielsweise mit dem Mauszeiger auf die äußere Kante eines [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) zeigt, ist **OriginalSource** für die meisten Zeigerereignissen ein [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250)-Vorlagenbestandteil in [**Template**](https://msdn.microsoft.com/library/windows/apps/br209465), nicht **Button** selbst.</span><span class="sxs-lookup"><span data-stu-id="046d7-274">For example, if the user hovers the pointer over the very edge of a [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265), for most pointer events the **OriginalSource** is a [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) template part in the [**Template**](https://msdn.microsoft.com/library/windows/apps/br209465), not the **Button** itself.</span></span>

<span data-ttu-id="046d7-275">**Tipp:** Eingabe-Eventbubbling ist besonders hilfreich, wenn Sie ein vorlagenbasiertes Steuerelement erstellen.</span><span class="sxs-lookup"><span data-stu-id="046d7-275">**Tip**Input event bubbling is especially useful if you are creating a templated control.</span></span> <span data-ttu-id="046d7-276">Auf jedes Steuerelement, das eine Vorlage besitzt, kann durch seinen Consumer eine neue Vorlage angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-276">Any control that has a template can have a new template applied by its consumer.</span></span> <span data-ttu-id="046d7-277">Der Consumer, der eine Arbeitsvorlage erneut zu erstellen versucht, kann versehentlich in der Standardvorlage deklarierten Ereignisbehandlungscode entfernen.</span><span class="sxs-lookup"><span data-stu-id="046d7-277">The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</span></span> <span data-ttu-id="046d7-278">Sie können dennoch eine Ereignisbehandlung auf Steuerelementebene bereitstellen, indem Sie Handler als Teil der [**OnApplyTemplate**](https://msdn.microsoft.com/library/windows/apps/br208737)-Überschreibung in der Klassendefinition anfügen.</span><span class="sxs-lookup"><span data-stu-id="046d7-278">You can still provide control-level event handling by attaching handlers as part of the [**OnApplyTemplate**](https://msdn.microsoft.com/library/windows/apps/br208737) override in the class definition.</span></span> <span data-ttu-id="046d7-279">Anschließend können Sie die Eingabeereignisse abfangen, die bei der Instanziierung per Bubbling zum Stamm des Steuerelements weitergeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-279">Then you can catch the input events that bubble up to the control's root on instantiation.</span></span>

### <a name="the-handled-property"></a><span data-ttu-id="046d7-280">Die Eigenschaft **Handled**</span><span class="sxs-lookup"><span data-stu-id="046d7-280">The **Handled** property</span></span>

<span data-ttu-id="046d7-281">Einige Ereignisdatenklassen für bestimmte Routingereignisse enthalten eine Eigenschaft mit dem Namen **Handled**.</span><span class="sxs-lookup"><span data-stu-id="046d7-281">Several event data classes for specific routed events contain a property named **Handled**.</span></span> <span data-ttu-id="046d7-282">Beispiele finden Sie unter [**PointerRoutedEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/hh943079), [**KeyRoutedEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073) und [**DragEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/br242375).</span><span class="sxs-lookup"><span data-stu-id="046d7-282">For examples, see [**PointerRoutedEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/hh943079), [**KeyRoutedEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073), [**DragEventArgs.Handled**](https://msdn.microsoft.com/library/windows/apps/br242375).</span></span> <span data-ttu-id="046d7-283">In allen Fällen ist **Handled** eine festlegbare boolesche Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="046d7-283">In all cases **Handled** is a settable Boolean property.</span></span>

<span data-ttu-id="046d7-284">Wenn die Eigenschaft **Handled** auf **true** festgelegt wird, wirkt sich dies auf das Ereignissystemverhalten aus.</span><span class="sxs-lookup"><span data-stu-id="046d7-284">Setting the **Handled** property to **true** influences the event system behavior.</span></span> <span data-ttu-id="046d7-285">Wenn **Handled** auf **true** festgelegt, wird das Routing für die meisten Ereignishandler beendet. Das Ereignis wird nicht über die Route weitergeleitet, um andere angefügte Handler über dieses spezielle Ereignis zu informieren.</span><span class="sxs-lookup"><span data-stu-id="046d7-285">When **Handled** is **true**, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</span></span> <span data-ttu-id="046d7-286">Was „behandelt“ im Kontext des Ereignisses bedeutet und wie Ihre App auf ein behandeltes Ereignis reagiert, liegt in Ihrem Ermessen.</span><span class="sxs-lookup"><span data-stu-id="046d7-286">What "handled" means in the context of the event and how your app responds to it is up to you.</span></span> <span data-ttu-id="046d7-287">Im Grunde ist **Handled** ein einfaches Protokoll, mit dem im App-Code angegeben werden kann, dass das Auftreten eines Ereignisses nicht per Bubbling an Container weitergeleitet werden muss, da Ihre App-Logik sich um die notwendigen Schritte gekümmert hat.</span><span class="sxs-lookup"><span data-stu-id="046d7-287">Basically, **Handled** is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</span></span> <span data-ttu-id="046d7-288">Im Gegensatz dazu müssen Sie jedoch darauf achten, dass Sie keine Ereignisse behandeln, bei denen ein Bubbling auftreten sollte, damit integrierte System- oder Steuerelementverhaltensweisen angewendet werden können. Das Behandeln von Ereignissen auf niedriger Ebene innerhalb der Teile oder Elemente eines Steuerelements eines Auswahlsteuerelements kann z.B. nachteilig sein.</span><span class="sxs-lookup"><span data-stu-id="046d7-288">Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act. For example, handling low-level events within the parts or items of a selection control can be detrimental.</span></span> <span data-ttu-id="046d7-289">Das Auswahlsteuerelement sucht möglicherweise nach Eingabeereignissen, um festzustellen, ob die Auswahl geändert werden muss.</span><span class="sxs-lookup"><span data-stu-id="046d7-289">The selection control might be looking for input events to know that the selection should change.</span></span>

<span data-ttu-id="046d7-290">Nicht alle Routingereignisse können eine Route auf diese Weise abbrechen, da sie die Eigenschaft **Handled** nicht besitzen.</span><span class="sxs-lookup"><span data-stu-id="046d7-290">Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a **Handled** property.</span></span> <span data-ttu-id="046d7-291">Beispielsweise führen [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/br208927) und [**LostFocus**](https://msdn.microsoft.com/library/windows/apps/br208943) Bubbling aus. Sie führen dieses Bubbling jedoch stets bis zum Stamm aus, und ihre Ereignisdatenklassen besitzen die Eigenschaft **Handled** nicht, die dieses Verhalten beeinflussen kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-291">For example, [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/br208927) and [**LostFocus**](https://msdn.microsoft.com/library/windows/apps/br208943) do bubble, but they always bubble all the way to the root, and their event data classes don't have a **Handled** property that can influence that behavior.</span></span>

##  <a name="input-event-handlers-in-controls"></a><span data-ttu-id="046d7-292">Eingabeereignishandler in Steuerelementen</span><span class="sxs-lookup"><span data-stu-id="046d7-292">Input event handlers in controls</span></span>

<span data-ttu-id="046d7-293">Bei bestimmten Windows-Runtime-Steuerelementen wird das **Handled**-Konzept manchmal intern für Eingabeereignisse verwendet.</span><span class="sxs-lookup"><span data-stu-id="046d7-293">Specific Windows Runtime controls sometimes use the **Handled** concept for input events internally.</span></span> <span data-ttu-id="046d7-294">Dadurch kann der Anschein erweckt werden, dass niemals ein Eingabeereignis eintritt, weil es vom Benutzercode nicht verarbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-294">This can make it seem like an input event never occurs, because your user code can't handle it.</span></span> <span data-ttu-id="046d7-295">Beispielsweise enthält die Klasse [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) Logik, mit der gezielt das allgemeine Eingabeereignis [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971) behandelt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-295">For example, the [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) class includes logic that deliberately handles the general input event [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/br208971).</span></span> <span data-ttu-id="046d7-296">Der Grund hierfür ist, dass Schaltflächen ein [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737)-Ereignis auslösen, das durch Eingaben mit gedrücktem Zeiger sowie durch andere Eingabemodi initiiert wird (z.B. durch Tasten wie die EINGABETASTE, die die Schaltfläche aufrufen können, wenn sie den Fokus besitzt).</span><span class="sxs-lookup"><span data-stu-id="046d7-296">It does so because buttons fire a [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</span></span> <span data-ttu-id="046d7-297">Im Rahmen des Klassendesigns von **Button** wird das Rohdateneingabe-Ereignis konzeptionell behandelt. Klassenconsumer wie Ihr Benutzercode können stattdessen mit dem steuerungsrelevanten **Click**-Ereignis interagieren.</span><span class="sxs-lookup"><span data-stu-id="046d7-297">For purposes of the class design of **Button**, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant **Click** event.</span></span> <span data-ttu-id="046d7-298">In den entsprechenden Themen zu den speziellen Steuerelementklassen in der API-Referenz für die Windows-Runtime wird häufig das von der Klasse implementierte Ereignisbehandlungsverhalten erwähnt.</span><span class="sxs-lookup"><span data-stu-id="046d7-298">Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</span></span> <span data-ttu-id="046d7-299">In einigen Fällen können Sie das Verhalten ändern, indem Sie \**On\*\*\*Event*-Methoden überschreiben.</span><span class="sxs-lookup"><span data-stu-id="046d7-299">In some cases, you can change the behavior by overriding \**On\*\*\*Event* methods.</span></span> <span data-ttu-id="046d7-300">Sie können beispielsweise die Art ändern, wie Ihre von [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683) abgeleitete Klasse auf Tasteneingaben reagiert, indem Sie [**Control.OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/hh967982) überschreiben.</span><span class="sxs-lookup"><span data-stu-id="046d7-300">For example, you can change how your [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683) derived class reacts to key input by overriding [**Control.OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/hh967982).</span></span>

##  <a name="registering-handlers-for-already-handled-routed-events"></a><span data-ttu-id="046d7-301">Registrieren von Handlern für bereits behandelte Routingereignisse</span><span class="sxs-lookup"><span data-stu-id="046d7-301">Registering handlers for already-handled routed events</span></span>

<span data-ttu-id="046d7-302">Weiter oben wurde erwähnt, dass die meisten Handler nicht aufgerufen werden, wenn **Handled** auf **true** festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-302">Earlier we said that setting **Handled** to **true** prevents most handlers from being called.</span></span> <span data-ttu-id="046d7-303">Die Methode [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) bietet jedoch eine Technik, um einen Handler anzufügen, der für die Route immer aufgerufen wird. Das geschieht selbst dann, wenn für andere Handler an früherer Stelle in der Route **Handled** auf **true** in den geteilten Ereignisdaten festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="046d7-303">But the [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set **Handled** to **true** in the shared event data.</span></span> <span data-ttu-id="046d7-304">Diese Technik ist nützlich, wenn ein von Ihnen verwendetes Steuerelement das Ereignis in seiner inneren Zusammensetzung behandelt hat. Sie eignet sich auch für spezielle Steuerelementlogik.</span><span class="sxs-lookup"><span data-stu-id="046d7-304">This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</span></span> <span data-ttu-id="046d7-305">bei der Sie weiterhin mit einer Steuerelementinstanz oder Ihrer App-UI auf das Ereignis reagieren möchten.</span><span class="sxs-lookup"><span data-stu-id="046d7-305">but you still want to respond to it from a control instance, or your app UI.</span></span> <span data-ttu-id="046d7-306">Diese Technik sollte jedoch mit Bedacht eingesetzt werden, da sie dem Zweck von **Handled** widersprechen und die beabsichtigten Interaktionen des Steuerelements verhindern kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-306">But use this technique with caution, because it can contradict the purpose of **Handled** and possibly break a control's intended interactions.</span></span>

<span data-ttu-id="046d7-307">Nur Routingereignisse mit entsprechenden Routingereignisbezeichnern können die Technik zur [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399)-Ereignisbehandlung nutzen, da der Bezeichner als Eingabe für die **AddHandler**-Methode erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-307">Only the routed events that have a corresponding routed event identifier can use the [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) event handling technique, because the identifier is a required input of the **AddHandler** method.</span></span> <span data-ttu-id="046d7-308">In der Referenzdokumentation zu [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) finden Sie eine Liste der Ereignisse, für die Routingereignisbezeichner verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="046d7-308">See the reference documentation for [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) for a list of events that have routed event identifiers available.</span></span> <span data-ttu-id="046d7-309">Diese Liste stimmt größtenteils mit der bereits gezeigten Liste mit Routingereignissen überein.</span><span class="sxs-lookup"><span data-stu-id="046d7-309">For the most part this is the same list of routed events we showed you earlier.</span></span> <span data-ttu-id="046d7-310">Die letzten beiden Ereignisse in der Liste, [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/br208927) und [**LostFocus**](https://msdn.microsoft.com/library/windows/apps/br208943), stellen eine Ausnahme dar, da sie keinen Routingereignisbezeichner besitzen. Daher können Sie **AddHandler** nicht für diese Ereignisse verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-310">The exception is that the last two in the list: [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/br208927) and [**LostFocus**](https://msdn.microsoft.com/library/windows/apps/br208943) don't have a routed event identifier, so you can't use **AddHandler** for those.</span></span>

## <a name="routed-events-outside-the-visual-tree"></a><span data-ttu-id="046d7-311">Routingereignisse außerhalb der visuellen Struktur</span><span class="sxs-lookup"><span data-stu-id="046d7-311">Routed events outside the visual tree</span></span>

<span data-ttu-id="046d7-312">Bestimmte Objekte sind Bestandteil einer Beziehung mit der primären visuellen Struktur. Diese ist konzeptionell, wie z.B. eine Überlagerung über die visuellen Hauptobjekte.</span><span class="sxs-lookup"><span data-stu-id="046d7-312">Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</span></span> <span data-ttu-id="046d7-313">Diese bestimmten Objekte gehören nicht zu den üblichen Beziehungen zwischen übergeordneten und untergeordneten Elementen, mit denen alle Strukturelemente mit dem visuellen Stamm verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="046d7-313">These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</span></span> <span data-ttu-id="046d7-314">Das betrifft jedes angezeigte [**Popup**](https://msdn.microsoft.com/library/windows/apps/br227842)- oder [**ToolTip**](https://msdn.microsoft.com/library/windows/apps/br227608)-Element.</span><span class="sxs-lookup"><span data-stu-id="046d7-314">This is the case for any displayed [**Popup**](https://msdn.microsoft.com/library/windows/apps/br227842) or [**ToolTip**](https://msdn.microsoft.com/library/windows/apps/br227608).</span></span> <span data-ttu-id="046d7-315">Wenn Sie Routingereignisse eines **Popup**- oder **ToolTip**-Elements behandeln möchten, platzieren Sie die Handler für bestimmte UI-Elemente innerhalb des **Popup**- oder **ToolTip**-Elements und nicht direkt für die **Popup**- oder **ToolTip**-Elemente.</span><span class="sxs-lookup"><span data-stu-id="046d7-315">If you want to handle routed events from a **Popup** or **ToolTip**, place the handlers on specific UI elements that are within the **Popup** or **ToolTip** and not the **Popup** or **ToolTip** elements themselves.</span></span> <span data-ttu-id="046d7-316">Verlassen Sie sich nicht auf das Routing innerhalb einer Zusammensetzung, die für **Popup**- **ToolTip**-Inhalt ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-316">Don't rely on routing inside any compositing that is performed for **Popup** or **ToolTip** content.</span></span> <span data-ttu-id="046d7-317">Das Ereignisrouting für geroutete Ereignisse funktioniert nur entlang der visuellen Hauptstruktur.</span><span class="sxs-lookup"><span data-stu-id="046d7-317">This is because event routing for routed events works only along the main visual tree.</span></span> <span data-ttu-id="046d7-318">Ein **Popup**- oder **ToolTip**-Element wird nicht als übergeordnetes Element untergeordneter UI-Elemente betrachtet und empfängt das Routingereignis in keinem Fall, auch wenn es versucht, Elemente wie den **Popup**-Standardhintergrund als Erfassungsbereich für Eingabeereignisse zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-318">A **Popup** or **ToolTip** is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the **Popup** default background as the capture area for input events.</span></span>

## <a name="hit-testing-and-input-events"></a><span data-ttu-id="046d7-319">Treffertests und Eingabeereignisse</span><span class="sxs-lookup"><span data-stu-id="046d7-319">Hit testing and input events</span></span>

<span data-ttu-id="046d7-320">Das Bestimmen, ob und wo auf der UI ein Element für die Maus-, Touch und Stifteingabe sichtbar ist, wird als *Treffertests* bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="046d7-320">Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called *hit testing*.</span></span> <span data-ttu-id="046d7-321">Bei Toucheingabeaktionen und interaktionsspezifischen Ereignissen oder Manipulationsereignissen, die aus einer Toucheingabeaktion resultieren, muss ein Element bei Treffertests sichtbar sein, damit es der Ereignisquelle entsprechen und das der Aktion zugeordnete Ereignis auslösen kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-321">For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</span></span> <span data-ttu-id="046d7-322">Andernfalls durchläuft die Aktion das Element bis zu zugrunde liegenden oder übergeordneten Elementen in der visuellen Struktur, die mit dieser Eingabe interagieren könnte.</span><span class="sxs-lookup"><span data-stu-id="046d7-322">Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</span></span> <span data-ttu-id="046d7-323">Treffertests werden von mehreren Faktoren beeinflusst. Sie können jedoch feststellen, ob ein bestimmtes Element Eingabeereignisse auslösen kann, indem Sie die zugehörige Eigenschaft [**IsHitTestVisible**](https://msdn.microsoft.com/library/windows/apps/br208933) überprüfen.</span><span class="sxs-lookup"><span data-stu-id="046d7-323">There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its [**IsHitTestVisible**](https://msdn.microsoft.com/library/windows/apps/br208933) property.</span></span> <span data-ttu-id="046d7-324">Diese Eigenschaft gibt nur dann **true** zurück, wenn das Element die folgenden Kriterien erfüllt:</span><span class="sxs-lookup"><span data-stu-id="046d7-324">This property returns **true** only if the element meets these criteria:</span></span>

-   <span data-ttu-id="046d7-325">Der [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992)-Eigenschaftenwert des Elements ist [**Visible**](https://msdn.microsoft.com/library/windows/apps/br209006).</span><span class="sxs-lookup"><span data-stu-id="046d7-325">The element's [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) property value is [**Visible**](https://msdn.microsoft.com/library/windows/apps/br209006).</span></span>
-   <span data-ttu-id="046d7-326">Der Wert der Eigenschaft **Background** oder **Fill** ist nicht **null**.</span><span class="sxs-lookup"><span data-stu-id="046d7-326">The element's **Background** or **Fill** property value is not **null**.</span></span> <span data-ttu-id="046d7-327">Ein Wert **null** für [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) führt zu Transparenz und Unsichtbarkeit von Treffertests.</span><span class="sxs-lookup"><span data-stu-id="046d7-327">A **null** [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) value results in transparency and hit test invisibility.</span></span> <span data-ttu-id="046d7-328">(Wenn Sie ein Element transparent machen und zugleich Treffertests für das Element ermöglichen möchten, verwenden Sie einen [**Transparent**](https://msdn.microsoft.com/library/windows/apps/hh748061)-Pinsel anstelle von **null**.)</span><span class="sxs-lookup"><span data-stu-id="046d7-328">(To make an element transparent but also hit testable, use a [**Transparent**](https://msdn.microsoft.com/library/windows/apps/hh748061) brush instead of **null**.)</span></span>

<span data-ttu-id="046d7-329">**Hinweis:** **Hintergrund** und **Füllen Sie** sind nicht von [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911)definiert, und stattdessen durch verschiedene abgeleitete Klassen wie [**Steuerelement**](https://msdn.microsoft.com/library/windows/apps/br209390) und [**Form**](/uwp/api/Windows.UI.Xaml.Shapes.Shape)definiert sind.</span><span class="sxs-lookup"><span data-stu-id="046d7-329">**Note\*\*\*\*Background** and **Fill** aren't defined by [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911), and are instead defined by different derived classes such as [**Control**](https://msdn.microsoft.com/library/windows/apps/br209390) and [**Shape**](/uwp/api/Windows.UI.Xaml.Shapes.Shape).</span></span> <span data-ttu-id="046d7-330">Die von Ihnen für Vorder- und Hintergrundeigenschaften verwendeten Implikationen von Pinseln sind jedoch für Treffertests und Eingabeereignisse identisch. Dabei ist es unerheblich, welche Unterklasse die Eigenschaften implementiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-330">But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</span></span>

-   <span data-ttu-id="046d7-331">Wenn das Element ein Steuerelement ist, muss dessen Wert für die Eigenschaft [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/br209419) **true** sein.</span><span class="sxs-lookup"><span data-stu-id="046d7-331">If the element is a control, its [**IsEnabled**](https://msdn.microsoft.com/library/windows/apps/br209419) property value must be **true**.</span></span>
-   <span data-ttu-id="046d7-332">Das Element muss im Layout über reale Dimensionen verfügen.</span><span class="sxs-lookup"><span data-stu-id="046d7-332">The element must have actual dimensions in layout.</span></span> <span data-ttu-id="046d7-333">Ein Element, bei dem [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) und [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) 0 sind, kann keine Eingabeereignisse auslösen.</span><span class="sxs-lookup"><span data-stu-id="046d7-333">An element where either [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) and [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) are 0 won't fire input events.</span></span>

<span data-ttu-id="046d7-334">Bei einigen Steuerelementen sind besondere Regeln bezüglich Treffertests zu beachten.</span><span class="sxs-lookup"><span data-stu-id="046d7-334">Some controls have special rules for hit testing.</span></span> <span data-ttu-id="046d7-335">Beispielsweise besitzt [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) die Eigenschaft **Background** nicht. Dennoch können innerhalb des gesamten Bereichs der zugehörigen Dimensionen Treffertests ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-335">For example, [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) has no **Background** property, but is still hit testable within the entire region of its dimensions.</span></span> <span data-ttu-id="046d7-336">[**Image**](https://msdn.microsoft.com/library/windows/apps/br242752) und [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926)-Steuerelemente können in den zugehörigen definierten Rechtecksdimensionen auf Treffer getestet werden. Dabei ist es unerheblich, ob in der Medienquelldatei transparente Inhalte wie Alphakanäle angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-336">[**Image**](https://msdn.microsoft.com/library/windows/apps/br242752) and [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926) controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</span></span> <span data-ttu-id="046d7-337">[**WebView**](https://msdn.microsoft.com/library/windows/apps/br227702)-Steuerelemente weisen ein spezielles Treffertestverhalten auf, da die Eingabe durch das gehostete HTML behandelt werden kann und Skriptereignisse auslösen kann.</span><span class="sxs-lookup"><span data-stu-id="046d7-337">[**WebView**](https://msdn.microsoft.com/library/windows/apps/br227702) controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</span></span>

<span data-ttu-id="046d7-338">Für die meisten [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)-Klassen und [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250)-Elemente können im eigenen Hintergrund zwar keine Treffertests ausgeführt werden, sie können jedoch dennoch Benutzereingabeereignisse verarbeiten, die von den in ihnen integrierten Elementen weitergeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="046d7-338">Most [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) classes and [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</span></span>

<span data-ttu-id="046d7-339">Elemente, die sich an der gleichen Position wie ein Benutzereingabeereignis befinden, können unabhängig davon ermittelt werden, ob sie für Treffertests infrage kommen.</span><span class="sxs-lookup"><span data-stu-id="046d7-339">You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</span></span> <span data-ttu-id="046d7-340">Rufen Sie dazu die [**FindElementsInHostCoordinates**](https://msdn.microsoft.com/library/windows/apps/br243039)-Methode auf.</span><span class="sxs-lookup"><span data-stu-id="046d7-340">To do this, call the [**FindElementsInHostCoordinates**](https://msdn.microsoft.com/library/windows/apps/br243039) method.</span></span> <span data-ttu-id="046d7-341">Wie der Name nahe legt, findet diese Methode die Elemente an einer Position relativ zu einem angegebenen Hostelement.</span><span class="sxs-lookup"><span data-stu-id="046d7-341">As the name implies, this method finds the elements at a location relative to a specified host element.</span></span> <span data-ttu-id="046d7-342">Transformationen und Layoutänderungen können sich jedoch auf das Koordinatensystem eines Elements auswirken und somit die an einer bestimmten Position gefundenen Elemente beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="046d7-342">However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</span></span>

## <a name="commanding"></a><span data-ttu-id="046d7-343">Steuerung</span><span class="sxs-lookup"><span data-stu-id="046d7-343">Commanding</span></span>

<span data-ttu-id="046d7-344">Eine geringe Anzahl von UI-Elementen unterstützt die *Steuerung*.</span><span class="sxs-lookup"><span data-stu-id="046d7-344">A small number of UI elements support *commanding*.</span></span> <span data-ttu-id="046d7-345">Die Steuerung verwendet eingabebezogene Routingereignisse in der zugrunde liegenden Implementierung und ermöglicht die Verarbeitung verwandter UI-Eingaben (eine bestimmte Zeigeraktion oder Zugriffstaste) durch das Aufrufen eines einzelnen Befehlshandlers.</span><span class="sxs-lookup"><span data-stu-id="046d7-345">Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</span></span> <span data-ttu-id="046d7-346">Wenn die Steuerung für ein UI-Element verfügbar ist, sollten Sie dessen Steuerungs-APIs anstelle einzelner Eingabeereignisse verwenden.</span><span class="sxs-lookup"><span data-stu-id="046d7-346">If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</span></span> <span data-ttu-id="046d7-347">Normalerweise verwenden Sie einen **Binding**-Verweis auf Eigenschaften einer Klasse, die das Ansichtsmodell für Daten definiert.</span><span class="sxs-lookup"><span data-stu-id="046d7-347">You typically use a **Binding** reference into properties of a class that defines the view model for data.</span></span> <span data-ttu-id="046d7-348">Die Eigenschaften enthalten benannte Befehle, die sprachspezifische **ICommand**-Befehlsmuster implementieren.</span><span class="sxs-lookup"><span data-stu-id="046d7-348">The properties hold named commands that implement the language-specific **ICommand** commanding pattern.</span></span> <span data-ttu-id="046d7-349">Weitere Informationen finden Sie unter [**ButtonBase.Command**](https://msdn.microsoft.com/library/windows/apps/br227740).</span><span class="sxs-lookup"><span data-stu-id="046d7-349">For more info, see [**ButtonBase.Command**](https://msdn.microsoft.com/library/windows/apps/br227740).</span></span>

## <a name="custom-events-in-the-windows-runtime"></a><span data-ttu-id="046d7-350">Benutzerdefinierte Ereignisse in der Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="046d7-350">Custom events in the Windows Runtime</span></span>

<span data-ttu-id="046d7-351">Beim Definieren von benutzerdefinierten Ereignissen hängen die Vorgehensweise beim Hinzufügen des Ereignisses und die Bedeutung für Ihren Klassenentwurf erheblich von der verwendeten Programmiersprache ab.</span><span class="sxs-lookup"><span data-stu-id="046d7-351">For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</span></span>

-   <span data-ttu-id="046d7-352">Für C# und Visual Basic definieren Sie ein CLR-Ereignis.</span><span class="sxs-lookup"><span data-stu-id="046d7-352">For C# and Visual Basic, you are defining a CLR event.</span></span> <span data-ttu-id="046d7-353">Sie können das .NET-Standardereignismuster verwenden, es sei denn, Sie verwenden benutzerdefinierte Accessoren (**add**/**remove**).</span><span class="sxs-lookup"><span data-stu-id="046d7-353">You can use the standard .NET event pattern, so long as you aren't using custom accessors (**add**/**remove**).</span></span> <span data-ttu-id="046d7-354">Zusätzliche Tipps:</span><span class="sxs-lookup"><span data-stu-id="046d7-354">Additional tips:</span></span>
    -   <span data-ttu-id="046d7-355">Für den Ereignishandler empfiehlt sich die Verwendung von [**System.EventHandler<TEventArgs>**](https://msdn.microsoft.com/library/windows/apps/xaml/db0etb8x.aspx), da die Übersetzung in den generischen Windows-Runtime-Ereignisdelegaten [**EventHandler<T>**](https://msdn.microsoft.com/library/windows/apps/br206577)integriert ist.</span><span class="sxs-lookup"><span data-stu-id="046d7-355">For the event handler it's a good idea to use [**System.EventHandler<TEventArgs>**](https://msdn.microsoft.com/library/windows/apps/xaml/db0etb8x.aspx) because it has built-in translation to the Windows Runtime generic event delegate [**EventHandler<T>**](https://msdn.microsoft.com/library/windows/apps/br206577).</span></span>
    -   <span data-ttu-id="046d7-356">Basieren Sie Ihre Ereignisdatenklasse nicht auf [**System.EventArgs**](https://msdn.microsoft.com/library/windows/apps/xaml/system.eventargs.aspx), da dann keine Übersetzung in die Windows-Runtime erfolgt.</span><span class="sxs-lookup"><span data-stu-id="046d7-356">Don't base your event data class on [**System.EventArgs**](https://msdn.microsoft.com/library/windows/apps/xaml/system.eventargs.aspx) because it doesn't translate to the Windows Runtime.</span></span> <span data-ttu-id="046d7-357">Verwenden Sie eine vorhandene Ereignisdatenklasse oder gar keine Basisklasse.</span><span class="sxs-lookup"><span data-stu-id="046d7-357">Use an existing event data class or no base class at all.</span></span>
    -   <span data-ttu-id="046d7-358">Wenn Sie benutzerdefinierte Accessoren verwenden, lesen Sie [Benutzerdefinierte Ereignisse und Ereignis-Accessoren in Windows-Runtime-Komponenten](https://msdn.microsoft.com/library/windows/apps/xaml/hh972883.aspx).</span><span class="sxs-lookup"><span data-stu-id="046d7-358">If you are using custom accessors, see [Custom events and event accessors in Windows Runtime Components](https://msdn.microsoft.com/library/windows/apps/xaml/hh972883.aspx).</span></span>
    -   <span data-ttu-id="046d7-359">Wenn Ihnen das .NET-Standardereignismuster nicht bekannt ist, lesen Sie unter [Definieren von Ereignissen für benutzerdefinierte Silverlight-Klassen](http://msdn.microsoft.com/library/dd833067.aspx).</span><span class="sxs-lookup"><span data-stu-id="046d7-359">If you're not clear on what the standard .NET event pattern is, see [Defining Events for Custom Silverlight Classes](http://msdn.microsoft.com/library/dd833067.aspx).</span></span> <span data-ttu-id="046d7-360">Dieser Inhalt wurde zwar für MicrosoftSilverlight verfasst, stellt aber dennoch einen hilfreichen Überblick über den Code und die Konzepte für das .NET-Standardereignismuster dar.</span><span class="sxs-lookup"><span data-stu-id="046d7-360">This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</span></span>
-   <span data-ttu-id="046d7-361">Für C++/CX lesen Sie [Ereignisse (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh755799.aspx).</span><span class="sxs-lookup"><span data-stu-id="046d7-361">For C++/CX, see [Events (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh755799.aspx).</span></span>
    -   <span data-ttu-id="046d7-362">Verwenden Sie auch für Ihre eigenen Verwendungen von benutzerdefinierten Ereignissen benannte Verweise.</span><span class="sxs-lookup"><span data-stu-id="046d7-362">Use named references even for your own usages of custom events.</span></span> <span data-ttu-id="046d7-363">Verwenden Sie nicht Lambda für benutzerdefinierte Ereignisse, da dadurch u.U. ein Zirkelverweis erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-363">Don't use lambda for custom events, it can create a circular reference.</span></span>

<span data-ttu-id="046d7-364">Sie können ein benutzerdefiniertes Routingereignis nicht für die Windows-Runtime deklarieren; Routingereignisse sind auf den Satz aus der Windows-Runtime beschränkt.</span><span class="sxs-lookup"><span data-stu-id="046d7-364">You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</span></span>

<span data-ttu-id="046d7-365">Das Definieren eines benutzerdefinierten Ereignisses erfolgt in der Regel im Rahmen der Definition eines benutzerdefinierten Steuerelements.</span><span class="sxs-lookup"><span data-stu-id="046d7-365">Defining a custom event is usually done as part of the exercise of defining a custom control.</span></span> <span data-ttu-id="046d7-366">Eine Abhängigkeitseigenschaft mit einem Rückruf für Eigenschaftsänderungen ist ein gängiges Muster, genau wie das Definieren eines benutzerdefinierten Ereignisses, das in manchen oder in allen Fällen durch den Abhängigkeitseigenschaftsrückruf ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="046d7-366">It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</span></span> <span data-ttu-id="046d7-367">Benutzer Ihres Steuerelements haben keinen Zugriff auf den von Ihnen definierten Rückruf für Eigenschaftsänderungen; die beste Methode ist das Bereitstellen eines Benachrichtigungsereignisses.</span><span class="sxs-lookup"><span data-stu-id="046d7-367">Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</span></span> <span data-ttu-id="046d7-368">Weitere Informationen finden Sie unter [Benutzerdefinierte Abhängigkeitseigenschaften](custom-dependency-properties.md).</span><span class="sxs-lookup"><span data-stu-id="046d7-368">For more info, see [Custom dependency properties](custom-dependency-properties.md).</span></span>

## <a name="related-topics"></a><span data-ttu-id="046d7-369">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="046d7-369">Related topics</span></span>

* [<span data-ttu-id="046d7-370">Übersicht über XAML</span><span class="sxs-lookup"><span data-stu-id="046d7-370">XAML overview</span></span>](xaml-overview.md)
* [<span data-ttu-id="046d7-371">Schnellstart: Fingereingabe</span><span class="sxs-lookup"><span data-stu-id="046d7-371">Quickstart: Touch input</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/hh465387)
* [<span data-ttu-id="046d7-372">Tastaturinteraktionen</span><span class="sxs-lookup"><span data-stu-id="046d7-372">Keyboard interactions</span></span>](https://msdn.microsoft.com/library/windows/apps/mt185607)
* [<span data-ttu-id="046d7-373">.NET-Ereignisse und -Delegate</span><span class="sxs-lookup"><span data-stu-id="046d7-373">.NET events and delegates</span></span>](http://go.microsoft.com/fwlink/p/?linkid=214364)
* [<span data-ttu-id="046d7-374">Erstellen von Komponenten für die Windows-Runtime</span><span class="sxs-lookup"><span data-stu-id="046d7-374">Creating Windows Runtime components</span></span>](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)
* [**<span data-ttu-id="046d7-375">AddHandler</span><span class="sxs-lookup"><span data-stu-id="046d7-375">AddHandler</span></span>**](https://msdn.microsoft.com/library/windows/apps/hh702399)
