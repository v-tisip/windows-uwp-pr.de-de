---
ms.assetid: E1943DCE-833F-48AE-8402-CD48765B24FC
title: Optimieren von Anhalten/Fortsetzen
description: Erstellen Sie Apps für die Universelle Windows-Plattform (UWP), die die Verwendung des Prozesslebensdauer-Systems optimieren und nach dem Anhalten oder Beenden effizient fortgesetzt werden.
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 06af6241bdd75efdd3ff71e02f74252d60540669
ms.sourcegitcommit: b5c9c18e70625ab770946b8243f3465ee1013184
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/28/2018
ms.locfileid: "7993336"
---
# <a name="optimize-suspendresume"></a><span data-ttu-id="f76e9-104">Optimieren von Anhalten/Fortsetzen</span><span class="sxs-lookup"><span data-stu-id="f76e9-104">Optimize suspend/resume</span></span>


<span data-ttu-id="f76e9-105">Erstellen Sie Apps für die Universelle Windows-Plattform (UWP), die die Verwendung des Prozesslebensdauer-Systems optimieren und nach dem Anhalten oder Beenden effizient fortgesetzt werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-105">Create Universal Windows Platform (UWP) apps that streamline their use of the process lifetime system to resume efficiently after suspension or termination.</span></span>

## <a name="launch"></a><span data-ttu-id="f76e9-106">Starten</span><span class="sxs-lookup"><span data-stu-id="f76e9-106">Launch</span></span>

<span data-ttu-id="f76e9-107">Überprüfen Sie beim Reaktivieren einer angehaltenen/beendeten App, ob das Reaktivieren lange gedauert hat.</span><span class="sxs-lookup"><span data-stu-id="f76e9-107">When reactivating an app following suspend/terminate, check to see if a long time has elapsed.</span></span> <span data-ttu-id="f76e9-108">Ist dies der Fall, empfiehlt es sich unter Umständen, anstelle der veralteten Daten des Benutzers wieder die Hauptseite der App anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-108">If so, consider returning to the main landing page of the app instead of showing the user stale data.</span></span> <span data-ttu-id="f76e9-109">Dies beschleunigt auch den Start.</span><span class="sxs-lookup"><span data-stu-id="f76e9-109">This will also result in faster startup.</span></span>

<span data-ttu-id="f76e9-110">Überprüfen Sie während der Aktivierung immer „PreviousExecutionState“ des EventArgs-Parameters (bei gestarteten Aktivierungen etwa „LaunchActivatedEventArgs.PreviousExecutionState“).</span><span class="sxs-lookup"><span data-stu-id="f76e9-110">During activation, always check the PreviousExecutionState of the event args parameter (for example, for launched activations check LaunchActivatedEventArgs.PreviousExecutionState).</span></span> <span data-ttu-id="f76e9-111">Vergeuden Sie bei „ClosedByUser“ oder „NotRunning“ keine Zeit mit der Wiederherstellung des zuvor gespeicherten Zustands.</span><span class="sxs-lookup"><span data-stu-id="f76e9-111">If the value is ClosedByUser or NotRunning, don’t waste time restoring previously saved state.</span></span> <span data-ttu-id="f76e9-112">Stellen Sie in diesem Fall besser eine frische Benutzeroberfläche bereit, die außerdem schneller geladen wird.</span><span class="sxs-lookup"><span data-stu-id="f76e9-112">In this case, the right thing is to provide a fresh experience – and it will result in faster startup.</span></span>

<span data-ttu-id="f76e9-113">Bei der Wiederherstellung des zuvor gespeicherten Zustands empfiehlt es sich unter Umständen, den Zustand nachzuverfolgen und nur bei Bedarf wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-113">Instead of eagerly restoring previously saved state, consider keep track of that state, and only restoring it on demand.</span></span> <span data-ttu-id="f76e9-114">Ein Beispiel: Angenommen, Ihre App wurde angehalten, hat den Zustand dreier Seiten gespeichert und wurde dann beendet.</span><span class="sxs-lookup"><span data-stu-id="f76e9-114">For example, consider a situation where your app was previously suspended, saved state for 3 pages, and was then terminated.</span></span> <span data-ttu-id="f76e9-115">Wenn dem Benutzer beim nächsten Start die dritte Seite angezeigt werden soll, verzichten Sie auf die Wiederherstellung des Zustands der ersten beiden Seiten.</span><span class="sxs-lookup"><span data-stu-id="f76e9-115">Upon relaunch, if you decide to return the user to the 3rd page, do not eagerly restore the state for the first 2 pages.</span></span> <span data-ttu-id="f76e9-116">Speichern Sie stattdessen diesen Zustand, und verwenden Sie ihn nur bei Bedarf.</span><span class="sxs-lookup"><span data-stu-id="f76e9-116">Instead, hold on to this state and only use it once you know you need it.</span></span>

## <a name="while-running"></a><span data-ttu-id="f76e9-117">Während der Ausführung</span><span class="sxs-lookup"><span data-stu-id="f76e9-117">While running</span></span>

<span data-ttu-id="f76e9-118">Es empfiehlt sich nicht, auf das Anhalteereignis zu warten und dann umfangreiche Zustandsdaten zu speichern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-118">As a best practice, don’t wait for the suspend event and then persist a large amount of state.</span></span> <span data-ttu-id="f76e9-119">Stattdessen sollte die Anwendung während der Ausführung schrittweise kleinere Mengen an Zustandsdaten speichern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-119">Instead, your application should incrementally persist smaller amounts of state as it runs.</span></span> <span data-ttu-id="f76e9-120">Dies gilt insbesondere für umfangreiche Apps, denen beim Anhalten unter Umständen nicht genügend Zeit bleibt, um alles auf einmal zu speichern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-120">This is especially important for large apps that are at risk of running out of time during suspend if they try to save everything at once.</span></span>

<span data-ttu-id="f76e9-121">Sie müssen allerdings einen guten Kompromiss zwischen inkrementeller Speicherung und Leistung der ausgeführten App finden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-121">However, you need to find a good balance between incremental saving and performance of your app while running.</span></span> <span data-ttu-id="f76e9-122">Ein gutes Modell wäre, geänderte (und damit zu speichernde) Daten inkrementell nachzuverfolgen und das Anhalteereignis als Signal für die tatsächliche Speicherung der Daten zu nutzen. Das geht schneller als alle Daten zu speichern oder den gesamten Zustand der App zu prüfen, um zu entscheiden, was gespeichert werden muss.</span><span class="sxs-lookup"><span data-stu-id="f76e9-122">A good tradeoff is to incrementally keep track of the data that has changed (and therefore needs to be saved) – and use the suspend event to actually save that data (which is faster than saving all data or examining the entire state of app to decide what to save).</span></span>

<span data-ttu-id="f76e9-123">Ermitteln Sie den Zeitpunkt für die Zustandsspeicherung nicht auf der Grundlage des Fensterereignisses „Activated“ oder „VisibilityChanged“.</span><span class="sxs-lookup"><span data-stu-id="f76e9-123">Don’t use the window Activated or VisibilityChanged events to decide when to save state.</span></span> <span data-ttu-id="f76e9-124">Wenn der Benutzer Ihre App verlässt, wird das Fenster zwar deaktiviert, die App wird jedoch erst etwas später (etwa nach zehn Sekunden) angehalten.</span><span class="sxs-lookup"><span data-stu-id="f76e9-124">When the user switches away from your app, the window is deactivated, but the system waits a short amount of time (about 10 seconds) before suspending the app.</span></span> <span data-ttu-id="f76e9-125">Dies dient zur Verbesserung der Reaktionszeit für den Fall, dass der Benutzer schnell wieder zu Ihrer App zurückkehrt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-125">This is to give a more responsive experience in case the user switches back to your app rapidly.</span></span> <span data-ttu-id="f76e9-126">Warten Sie mit dem Ausführen der Anhaltelogik auf das Eintreten des Anhalteereignisses.</span><span class="sxs-lookup"><span data-stu-id="f76e9-126">Wait for the suspend event before running suspend logic.</span></span>

## <a name="suspend"></a><span data-ttu-id="f76e9-127">Anhalten</span><span class="sxs-lookup"><span data-stu-id="f76e9-127">Suspend</span></span>

<span data-ttu-id="f76e9-128">Verringern Sie den Speicherbedarf Ihrer angehaltenen App.</span><span class="sxs-lookup"><span data-stu-id="f76e9-128">During suspend, reduce the footprint of your app.</span></span> <span data-ttu-id="f76e9-129">Wenn Ihre angehaltene App weniger Arbeitsspeicher beansprucht, reagiert das gesamte System schneller, und es müssen weniger angehaltene Apps (einschließlich Ihrer eigenen) beendet werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-129">If your app uses less memory while suspended, the overall system will be more responsive and fewer suspended apps (including yours) will be terminated.</span></span> <span data-ttu-id="f76e9-130">Achten Sie dabei jedoch darauf, den Speicherbedarf nicht so weit zu verringern, dass sich die Fortsetzung der App erheblich verlangsamt, weil Ihre App erst wieder große Datenmengen in den Arbeitsspeicher laden muss.</span><span class="sxs-lookup"><span data-stu-id="f76e9-130">However, balance this with the need for snappy resumes: don’t reduce footprint so much that resume slows down considerably while your app reloads lots of data into memory.</span></span>

<span data-ttu-id="f76e9-131">Bei verwalteten Apps wird nach Abschluss der Suspend-Handler der App ein GarbageCollection-Durchlauf ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-131">For managed apps, the system will run a garbage collection pass after the app’s suspend handlers complete.</span></span> <span data-ttu-id="f76e9-132">Machen Sie sich das zunutze, indem Sie Verweise auf Objekte freigeben, die zur Verringerung des Speicherbedarfs der angehaltenen App beitragen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-132">Make sure to take advantage of this by releasing references to objects that will help reduce the app’s footprint while suspended.</span></span>

<span data-ttu-id="f76e9-133">Im Idealfall ist die Anhaltelogik Ihrer App in weniger als einer Sekunde abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-133">Ideally, your app will finish with suspend logic in less than 1 second.</span></span> <span data-ttu-id="f76e9-134">Je kürzer der Anhaltevorgang, desto besser. Dies kommt der Reaktionsgeschwindigkeit von anderen Apps und Teilen des Systems zugute.</span><span class="sxs-lookup"><span data-stu-id="f76e9-134">The faster you can suspend, the better – that will result in a snappier user experience for other apps and parts of the system.</span></span> <span data-ttu-id="f76e9-135">Bei Bedarf kann die Anhaltelogik bis zu fünf Sekunden (Desktopgeräte) bzw. bis zu zehn Sekunden (mobile Geräte) dauern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-135">If you must, your suspend logic can take up to 5 seconds on desktop devices or 10 seconds on mobile devices.</span></span> <span data-ttu-id="f76e9-136">Nach diesem Zeitlimit wird die App abrupt beendet.</span><span class="sxs-lookup"><span data-stu-id="f76e9-136">If those times are exceeded, your app will be abruptly terminated.</span></span> <span data-ttu-id="f76e9-137">Das gilt es zu vermeiden. Denn wenn der Benutzer wieder zu Ihrer App wechselt, wird ein neuer Prozess gestartet, was im Vergleich zur Fortsetzung einer angehaltenen App einen deutlich langsameren Eindruck hinterlässt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-137">You don’t want this to happen – because if it does, when the user switches back to your app, a new process will be launched and the experience will feel much slower compared to resuming a suspended app.</span></span>

## <a name="resume"></a><span data-ttu-id="f76e9-138">Fortsetzen</span><span class="sxs-lookup"><span data-stu-id="f76e9-138">Resume</span></span>

<span data-ttu-id="f76e9-139">Da die meisten Apps beim Fortsetzen keinerlei besondere Aktion durchführen müssen, wird dieses Ereignis in der Regel nicht behandelt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-139">Most apps don’t need to do anything special when resumed, so typically you won’t handle this event.</span></span> <span data-ttu-id="f76e9-140">Einige Apps stellen beim Fortsetzen Verbindungen wieder her, die beim Anhalten getrennt wurden, oder aktualisieren inzwischen veraltete Daten.</span><span class="sxs-lookup"><span data-stu-id="f76e9-140">Some apps use resume to restore connections that were closed during suspend, or to refresh data that may be stale.</span></span> <span data-ttu-id="f76e9-141">Hierbei empfiehlt es sich, diese Aktivitäten nicht blindlings auszuführen, sondern die App so zu gestalten, dass sie nur bei Bedarf initiiert werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-141">Instead of doing this kind of work eagerly, design your app to initiate these activities on demand.</span></span> <span data-ttu-id="f76e9-142">Dadurch kann der Benutzer schneller zu einer angehaltenen App zurückwechseln, und es werden nur die wirklich erforderlichen Aufgaben ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-142">This will result in a faster experience when the user switches back to a suspended app, and ensures that you’re only doing work the user really needs.</span></span>

## <a name="avoid-unnecessary-termination"></a><span data-ttu-id="f76e9-143">Vermeiden unnötiger Beendigungen</span><span class="sxs-lookup"><span data-stu-id="f76e9-143">Avoid unnecessary termination</span></span>

<span data-ttu-id="f76e9-144">Das Prozesslebensdauer-System der universellen Windows-Plattform kann eine App aus den unterschiedlichsten Gründen anhalten oder beenden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-144">The UWP process lifetime system can suspend or terminate an app for a variety of reasons.</span></span> <span data-ttu-id="f76e9-145">Dieser Prozess ist so konzipiert, dass eine App schnell wieder in den Zustand versetzt werden kann, in dem sie sich befand, bevor sie angehalten oder beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="f76e9-145">This process is designed to quickly return an app to the state it was in before it was suspended or terminated.</span></span> <span data-ttu-id="f76e9-146">Im günstigsten Fall bemerkt der Benutzer nicht einmal, dass die App zwischenzeitlich nicht ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="f76e9-146">When done well, the user won’t be aware that the app ever stopped running.</span></span> <span data-ttu-id="f76e9-147">Hier folgen ein paar Tricks, mit denen Ihre UWP-App das System unterstützen kann, die Übergänge während der Lebensdauer einer App zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="f76e9-147">Here are a few tricks that your UWP app can use to help the system streamline transitions in an app’s lifetime.</span></span>

<span data-ttu-id="f76e9-148">Eine App kann angehalten werden, wenn sie vom Benutzer in den Hintergrund versetzt wird oder das System in einen Energiesparmodus wechselt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-148">An app can be suspended when the user moves it to the background or when the system enters a low power state.</span></span> <span data-ttu-id="f76e9-149">Beim Anhalten löst die App das Anhalteereignis aus. Dabei hat sie maximal fünf Sekunden Zeit, um ihre Daten zu speichern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-149">When the app is being suspended, it raises the suspending event and has up to 5 seconds to save its data.</span></span> <span data-ttu-id="f76e9-150">Wenn der Handler für das Anhalteereignis der App nicht innerhalb von fünf Sekunden abgeschlossen wird, geht das System davon aus, dass die App nicht mehr reagiert, und beendet sie.</span><span class="sxs-lookup"><span data-stu-id="f76e9-150">If the app's suspending event handler doesn't complete within 5 seconds, the system assumes the app has stopped responding and terminates it.</span></span> <span data-ttu-id="f76e9-151">Eine beendete App muss erneut den langen Startprozess durchlaufen und kann nicht einfach direkt in den Speicher geladen werden, wenn der Benutzer sie wieder aufruft.</span><span class="sxs-lookup"><span data-stu-id="f76e9-151">A terminated app has to go through the long startup process again instead of being immediately loaded into memory when a user switches to it.</span></span>

### <a name="serialize-only-when-necessary"></a><span data-ttu-id="f76e9-152">Serialisierung nur wenn erforderlich</span><span class="sxs-lookup"><span data-stu-id="f76e9-152">Serialize only when necessary</span></span>

<span data-ttu-id="f76e9-153">Viele Apps serialisieren sämtliche Daten, wenn Sie angehalten werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-153">Many apps serialize all their data on suspension.</span></span> <span data-ttu-id="f76e9-154">Wenn Sie nur einen kleinen Teil der Einstellungsdaten der App speichern möchten, sollten Sie den [**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622)-Speicher verwenden, anstatt die Daten zu serialisieren.</span><span class="sxs-lookup"><span data-stu-id="f76e9-154">If you only need to store a small amount of app settings data, however, you should use the [**LocalSettings**](https://msdn.microsoft.com/library/windows/apps/BR241622) store instead of serializing the data.</span></span> <span data-ttu-id="f76e9-155">Serialisieren Sie nur große Datenmengen, die nicht zu den Einstellungen gehören.</span><span class="sxs-lookup"><span data-stu-id="f76e9-155">Use serialization for larger amounts of data and for non-settings data.</span></span>

<span data-ttu-id="f76e9-156">Wenn Sie Ihre Daten serialisieren, sollten Sie ein erneutes Serialisieren vermeiden, wenn sich die Daten nicht geändert haben.</span><span class="sxs-lookup"><span data-stu-id="f76e9-156">When you do serialize your data, you should avoid reserializing if it hasn't changed.</span></span> <span data-ttu-id="f76e9-157">Dabei dauert es nicht nur länger, wenn die Daten serialisiert und gespeichert werden, sondern auch, wenn die Daten bei der Reaktivierung der App gelesen und deserialisiert werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-157">It takes extra time to serialize and save the data, plus extra time to read and deserialize it when the app is activated again.</span></span> <span data-ttu-id="f76e9-158">Stattdessen sollte die App feststellen, ob sich ihr Status tatsächlich geändert hat und ggf. nur die geänderten Daten serialisieren bzw. deserialisieren.</span><span class="sxs-lookup"><span data-stu-id="f76e9-158">Instead, we recommend that the app determine if its state has actually changed, and if so, serialize and deserialize only the data that changed.</span></span> <span data-ttu-id="f76e9-159">Eine empfehlenswerte Methode hierfür ist die regelmäßige Serialisierung im Hintergrund von Daten, wenn sich diese ändern.</span><span class="sxs-lookup"><span data-stu-id="f76e9-159">A good way to ensure that this happens is to periodically serialize data in the background after it changes.</span></span> <span data-ttu-id="f76e9-160">Bei dieser Methode ist bereits alles gespeichert, was beim Anhalten serialisiert werden muss, und die App kann ohne große Verzögerung angehalten werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-160">When you use this technique, everything that needs to be serialized at suspension has already been saved so there is no work to do and an app suspends quickly.</span></span>

### <a name="serializing-data-in-c-and-visual-basic"></a><span data-ttu-id="f76e9-161">Serialisieren von Daten in C# und Visual Basic</span><span class="sxs-lookup"><span data-stu-id="f76e9-161">Serializing data in C# and Visual Basic</span></span>

<span data-ttu-id="f76e9-162">Als Serialisierungstechnologien für .NET-Apps stehen die Klassen [**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx), [**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) und [**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx) zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="f76e9-162">The available choices of serialization technology for .NET apps are the [**System.Xml.Serialization.XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx), [**System.Runtime.Serialization.DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx), and [**System.Runtime.Serialization.Json.DataContractJsonSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.json.datacontractjsonserializer.aspx) classes.</span></span>

<span data-ttu-id="f76e9-163">Aus Leistungsgründen empfehlen wir die Verwendung der [**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx)-Klasse.</span><span class="sxs-lookup"><span data-stu-id="f76e9-163">From a performance perspective, we recommend using the [**XmlSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.xml.serialization.xmlserializer.aspx) class.</span></span> <span data-ttu-id="f76e9-164">Die **XmlSerializer**-Klasse zeichnet sich durch die schnellste Serialisierung und Deserialisierung sowie durch einen geringen Speicherbedarf aus.</span><span class="sxs-lookup"><span data-stu-id="f76e9-164">The **XmlSerializer** has the lowest serialization and deserialization times, and maintains a low memory footprint.</span></span> <span data-ttu-id="f76e9-165">**XmlSerializer** ist nur in wenigen Bereichen mit .NET Framework verknüpft. Im Vergleich zu den anderen Serialisierungstechnologien müssen daher für die Verwendung von **XmlSerializer** weniger Module in Ihre App geladen werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-165">The **XmlSerializer** has few dependencies on the .NET framework; this means that compared with the other serialization technologies, fewer modules need to be loaded into your app to use the **XmlSerializer**.</span></span>

<span data-ttu-id="f76e9-166">[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) vereinfacht die Serialisierung angepasster Klassen, auch wenn es größere Auswirkungen auf die Leistung als **XmlSerializer** hat.</span><span class="sxs-lookup"><span data-stu-id="f76e9-166">[**DataContractSerializer**](https://msdn.microsoft.com/library/windows/apps/xaml/system.runtime.serialization.datacontractserializer.aspx) makes it easier to serialize custom classes, although it has a larger performance impact than **XmlSerializer**.</span></span> <span data-ttu-id="f76e9-167">Wenn Sie eine bessere Leistung benötigen, denken Sie über einen Wechsel nach.</span><span class="sxs-lookup"><span data-stu-id="f76e9-167">If you need better performance, consider switching.</span></span> <span data-ttu-id="f76e9-168">Generell sollten Sie nur ein Serialisierungsprogramm laden und **XmlSerializer** vorziehen, falls Sie nicht die Funktionen eines anderen Serialisierungsprogramms benötigen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-168">In general, you should not load more than one serializer, and you should prefer **XmlSerializer** unless you need the features of another serializer.</span></span>

### <a name="reduce-memory-footprint"></a><span data-ttu-id="f76e9-169">Verringern des Speicherbedarfs</span><span class="sxs-lookup"><span data-stu-id="f76e9-169">Reduce memory footprint</span></span>

<span data-ttu-id="f76e9-170">Das System versucht, möglichst viele angehaltene Apps im Arbeitsspeicher vorzuhalten, damit der Benutzer schnell und zuverlässig zwischen den Apps wechseln kann.</span><span class="sxs-lookup"><span data-stu-id="f76e9-170">The system tries to keep as many suspended apps in memory as possible so that users can quickly and reliably switch between them.</span></span> <span data-ttu-id="f76e9-171">Solange sich eine angehaltene App im Arbeitsspeicher des Systems befindet, kann sie für Benutzerinteraktionen schnell wieder in den Vordergrund geholt werden, ohne dass ein Begrüßungsbildschirm angezeigt wird oder langwierige Ladevorgänge ausgeführt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="f76e9-171">When an app is suspended and stays in the system's memory, it can quickly be brought to the foreground for the user to interact with, without having to display a splash screen or perform a lengthy load operation.</span></span> <span data-ttu-id="f76e9-172">Sollten jedoch nicht genügend Ressourcen verfügbar sein, um eine App im Speicher zu belassen, wird die App beendet.</span><span class="sxs-lookup"><span data-stu-id="f76e9-172">If there aren't enough resources to keep an app in memory, the app is terminated.</span></span> <span data-ttu-id="f76e9-173">Die Speicherverwaltung ist also aus zwei Gründen von Bedeutung:</span><span class="sxs-lookup"><span data-stu-id="f76e9-173">This makes memory management important for two reasons:</span></span>

-   <span data-ttu-id="f76e9-174">Je mehr Speicher beim Anhalten freigegeben wird, desto geringer ist die Wahrscheinlichkeit, dass Ihre angehaltene App aufgrund unzureichender Ressourcen beendet wird.</span><span class="sxs-lookup"><span data-stu-id="f76e9-174">Freeing as much memory as possible at suspension minimizes the chances that your app is terminated because of lack of resources while it’s suspended.</span></span>
-   <span data-ttu-id="f76e9-175">Durch Verringern des Gesamtspeicherbedarfs Ihrer App verringern Sie außerdem die Wahrscheinlichkeit, dass andere angehaltene Apps beendet werden.</span><span class="sxs-lookup"><span data-stu-id="f76e9-175">Reducing the overall amount of memory your app uses reduces the chances that other apps are terminated while they are suspended.</span></span>

### <a name="release-resources"></a><span data-ttu-id="f76e9-176">Freigeben von Ressourcen</span><span class="sxs-lookup"><span data-stu-id="f76e9-176">Release resources</span></span>

<span data-ttu-id="f76e9-177">Bestimmte Objekte, beispielsweise Dateien und Geräte, beanspruchen Arbeitsspeicher in großem Umfang.</span><span class="sxs-lookup"><span data-stu-id="f76e9-177">Certain objects, such as files and devices, occupy a large amount of memory.</span></span> <span data-ttu-id="f76e9-178">Wir empfehlen, dass eine angehaltene App Handles für diese Objekte freigibt und sie erst bei Bedarf neu erstellt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-178">We recommend that during suspension, an app release handles to these objects and recreate them when needed.</span></span> <span data-ttu-id="f76e9-179">Dies ist auch eine gute Gelegenheit zum Löschen sämtlicher Zwischenspeicherungen, die bei Reaktivierung der App nicht mehr gültig sind.</span><span class="sxs-lookup"><span data-stu-id="f76e9-179">This is also a good time to purge any caches that won’t be valid when the app is resumed.</span></span> <span data-ttu-id="f76e9-180">Ein weiterer Schritt, den das XAML-Framework für Apps mit C# und Visual Basic gegebenenfalls ausführt, ist die Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="f76e9-180">An additional step the XAML framework runs on your behalf for C# and Visual Basic apps is garbage collection if it is necessary.</span></span> <span data-ttu-id="f76e9-181">Damit wird die Freigabe aller Objekte erreicht, auf die im App-Code nicht mehr verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="f76e9-181">This ensures any objects no longer referenced in app code are released.</span></span>

## <a name="resume-quickly"></a><span data-ttu-id="f76e9-182">Schnelles Reaktivieren</span><span class="sxs-lookup"><span data-stu-id="f76e9-182">Resume quickly</span></span>

<span data-ttu-id="f76e9-183">Die Ausführung einer angehaltenen App kann fortgesetzt werden, wenn sie vom Benutzer in den Vordergrund geholt wird oder wenn das System einen Energiesparmodus verlässt.</span><span class="sxs-lookup"><span data-stu-id="f76e9-183">A suspended app can be resumed when the user moves it to the foreground or when the system comes out of a low power state.</span></span> <span data-ttu-id="f76e9-184">Wenn eine angehaltene App fortgesetzt wird, wird die App-Ausführung an dem Punkt fortgesetzt, an dem sie zuvor angehalten wurde.</span><span class="sxs-lookup"><span data-stu-id="f76e9-184">When an app is resumed from the suspended state, it continues from where it was when it was suspended.</span></span> <span data-ttu-id="f76e9-185">Es gehen keine App-Daten verloren, da sie im Arbeitsspeicher gespeichert wurden. Dies gilt auch dann, wenn die App über einen längeren Zeitraum angehalten war.</span><span class="sxs-lookup"><span data-stu-id="f76e9-185">No app data is lost because it was stored in memory, even if the app was suspended for a long period of time.</span></span>

<span data-ttu-id="f76e9-186">Bei den meisten Apps ist keine Behandlung des [**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859)-Ereignisses erforderlich.</span><span class="sxs-lookup"><span data-stu-id="f76e9-186">Most apps don't need to handle the [**Resuming**](https://msdn.microsoft.com/library/windows/apps/BR205859) event.</span></span> <span data-ttu-id="f76e9-187">Bei der App-Reaktivierung besitzen die Variablen und Objekte exakt den gleichen Zustand wie beim Anhalten der App.</span><span class="sxs-lookup"><span data-stu-id="f76e9-187">When your app is resumed, variables and objects have the exact same state they had when the app was suspended.</span></span> <span data-ttu-id="f76e9-188">Behandeln Sie das **Resuming**-Ereignis nur dann, wenn Sie Daten oder Objekte aktualisieren müssen, die sich nach dem Anhalten der App möglicherweise geändert haben. Beispiele wären etwa Inhalte (z. B. aktualisierte Feeddaten), nicht mehr aktuelle Netzwerkverbindungen oder die Wiederherstellung des Zugriffs ein Gerät (etwa eine Webcam).</span><span class="sxs-lookup"><span data-stu-id="f76e9-188">Handle the **Resuming** event only if you need to update data or objects that might have changed between the time your app was suspended and when it was resumed such as: content (for example, update feed data), network connections that may have gone stale, or if you need to reacquire access to a device (for example, a webcam).</span></span>

## <a name="related-topics"></a><span data-ttu-id="f76e9-189">Verwandte Themen</span><span class="sxs-lookup"><span data-stu-id="f76e9-189">Related topics</span></span>

* [<span data-ttu-id="f76e9-190">Richtlinien für das Anhalten und Fortsetzen von Apps</span><span class="sxs-lookup"><span data-stu-id="f76e9-190">Guidelines for app suspend and resume</span></span>](https://msdn.microsoft.com/library/windows/apps/Hh465088)
 

 




