---
author: jwmsft
ms.assetid: F912161D-3767-4F35-88C0-E1ECDED692A2
title: Verbessern der Leistung bei der Garbage Collection
description: In C# und Visual Basic geschriebene UWP-Apps profitieren von der automatischen Arbeitsspeicherverwaltung des .NET Garbage Collectors. Dieser Abschnitt bietet einen Überblick über das Verhalten von .NET Garbage Collector sowie bewährte Methoden für dessen Leistungssteigerung in UWP-Apps.
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: Windows10, UWP
ms.openlocfilehash: 3b7dfb274c5a6d55204a467fc894bac5fd044048
ms.sourcegitcommit: ec18e10f750f3f59fbca2f6a41bf1892072c3692
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/14/2017
ms.locfileid: "894650"
---
# <a name="improve-garbage-collection-performance"></a><span data-ttu-id="ee6aa-105">Verbessern der Leistung bei der Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="ee6aa-105">Improve garbage collection performance</span></span>

<span data-ttu-id="ee6aa-106">\[ Aktualisiert für UWP-Apps unter Windows10.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-106">\[ Updated for UWP apps on Windows 10.</span></span> <span data-ttu-id="ee6aa-107">Artikel zu Windows8.x finden Sie im [Archiv](http://go.microsoft.com/fwlink/p/?linkid=619132). \]</span><span class="sxs-lookup"><span data-stu-id="ee6aa-107">For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \]</span></span>

<span data-ttu-id="ee6aa-108">In C# und VisualBasic geschriebene UWP-Apps profitieren von der automatischen Arbeitsspeicherverwaltung des .NETGarbage Collectors.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-108">Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</span></span> <span data-ttu-id="ee6aa-109">Dieser Abschnitt bietet einen Überblick über das Verhalten des .NETGarbage Collectors sowie über die bewährten Methoden zur Leistungssteigerung für den Garbage Collector in UWP-Apps.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-109">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</span></span> <span data-ttu-id="ee6aa-110">Weitere Informationen zur Funktionsweise des .NETGarbage Collectors sowie zu Debugging- und Leistungsanalysetools für den Garbage Collector finden Sie unter [Garbage Collection](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-110">For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see [Garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/0xy59wtx.aspx).</span></span>

<span data-ttu-id="ee6aa-111">**Hinweis**  Die Notwendigkeit, in das Standardverhalten des Garbage Collector eingreifen zu müssen, ist ein starkes Indiz für allgemeine Speicherprobleme mit Ihrer App.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-111">**Note**  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</span></span> <span data-ttu-id="ee6aa-112">Weitere Informationen finden Sie unter [Speichernutzungstool beim Debuggen in Visual Studio 2015](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-112">For more info, see [Memory Usage Tool while debugging in Visual Studio 2015](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx).</span></span> <span data-ttu-id="ee6aa-113">Dieses Thema betrifft ausschließlich C# und Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-113">This topic applies to C# and Visual Basic only.</span></span>

 

<span data-ttu-id="ee6aa-114">Der Garbage Collector bestimmt den Moment der Ausführung, indem er den Speicherverbrauch des verwalteten Heaps mit dem Aufwand für die Garbage Collection vergleicht.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-114">The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</span></span> <span data-ttu-id="ee6aa-115">Zur Ermittlung dieses Zeitpunkts unterteilt der Garbage Collector unter anderem den Heap in Generationen und erfasst größtenteils nur einen Teil des Heaps.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-115">One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</span></span> <span data-ttu-id="ee6aa-116">Der verwaltete Heap enthält drei Generationen:</span><span class="sxs-lookup"><span data-stu-id="ee6aa-116">There are three generations in the managed heap:</span></span>

-   <span data-ttu-id="ee6aa-117">Generation0.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-117">Generation 0.</span></span> <span data-ttu-id="ee6aa-118">Diese Generation enthält neu zugeordnete Objekte mit einer Größe von 85 KB oder mehr. Ab dieser Größe gehören die Objekte dem Heap für große Objekte an.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-118">This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</span></span> <span data-ttu-id="ee6aa-119">Der Heap für große Objekte wird im Rahmen der Generation2 bereinigt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-119">The large object heap is collected with generation 2 collections.</span></span> <span data-ttu-id="ee6aa-120">Bereinigungen der Generation0 werden am häufigsten ausgeführt und bereinigen kurzlebige Objekte wie lokale Variablen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-120">Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</span></span>
-   <span data-ttu-id="ee6aa-121">Generation1.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-121">Generation 1.</span></span> <span data-ttu-id="ee6aa-122">Diese Generation enthält Objekte, die nach Generation0 noch vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-122">This generation contains objects that have survived generation 0 collections.</span></span> <span data-ttu-id="ee6aa-123">Sie hat die Funktion eines Puffers zwischen den Generationen0 und2.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-123">It serves as a buffer between generation 0 and generation 2.</span></span> <span data-ttu-id="ee6aa-124">Bereinigungen der Generation1 sind seltener als Bereinigungen der Generation0 und bereinigen temporäre Objekte, die bei vorangegangenen Bereinigungen der Generation0 aktiv waren.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-124">Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</span></span> <span data-ttu-id="ee6aa-125">Eine Bereinigung der Generation1 bereinigt auch die Generation0.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-125">A generation 1 collection also collects generation 0.</span></span>
-   <span data-ttu-id="ee6aa-126">Generation2.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-126">Generation 2.</span></span> <span data-ttu-id="ee6aa-127">Diese Generation enthält langlebige Objekte, die nach den Generationen0 und1 noch vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-127">This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</span></span> <span data-ttu-id="ee6aa-128">Collections der Generation2 sind am seltensten und erfassen den gesamten verwalteten Heap – einschließlich des Heaps für große Objekte, der Objekte ab einer Größe von 85 KB enthält.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-128">Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</span></span>

<span data-ttu-id="ee6aa-129">Zur Ermittlung der Leistung des Garbage Collectors können zwei Aspekte betrachtet werden: die zum Ausführen der Garbage Collection erforderliche Zeit und die Arbeitsspeichernutzung des verwalteten Heaps.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-129">You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</span></span> <span data-ttu-id="ee6aa-130">Konzentrieren Sie sich bei einer kleinen App mit einer Heapgröße von weniger als 100MB auf die Verringerung der Arbeitsspeichernutzung.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-130">If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</span></span> <span data-ttu-id="ee6aa-131">Konzentrieren Sie sich nur dann auf die Verringerung der für die Garbage Collection benötigtenZeit, wenn der verwaltete Heap Ihrer App eine Größe von 100MB übersteigt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-131">If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</span></span> <span data-ttu-id="ee6aa-132">Hier erfahren Sie, wie der.NET Garbage Collector eine bessere Leistung erzielen kann.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-132">Here's how you can help the .NET garbage collector achieve better performance.</span></span>

## <a name="reduce-memory-consumption"></a><span data-ttu-id="ee6aa-133">Verringern der Arbeitsspeichernutzung</span><span class="sxs-lookup"><span data-stu-id="ee6aa-133">Reduce memory consumption</span></span>

### <a name="release-references"></a><span data-ttu-id="ee6aa-134">Versionsverweise</span><span class="sxs-lookup"><span data-stu-id="ee6aa-134">Release references</span></span>

<span data-ttu-id="ee6aa-135">Ein Verweis auf ein Objekt in Ihrer App verhindert die Bereinigung dieses Objekts sowie aller Objekte, auf die es verweist.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-135">A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</span></span> <span data-ttu-id="ee6aa-136">Der .NET-Compiler erkennt sehr zuverlässig, wann eine Variable nicht mehr verwendet wird, sodass Objekte, die von dieser Variablen gehalten werden, der Collection zugeführt werden können.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-136">The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</span></span> <span data-ttu-id="ee6aa-137">Manchmal ist es jedoch möglicherweise nicht ohne Weiteres ersichtlich, dass Objekte auf andere Objekte verweisen, da sich ein Teil des Objektgraphs unter Umständen im Besitz von Bibliotheken befindet, die Ihre App verwendet.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-137">But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</span></span> <span data-ttu-id="ee6aa-138">Informationen zu den Tools und Techniken, mit denen Sie ermitteln können, welche Objekte nach einer Garbage Collection noch vorhanden sind, finden Sie unter [Garbage Collection und Leistung](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-138">To learn about the tools and techniques to find out which objects survive a garbage collection, see [Garbage collection and performance](https://msdn.microsoft.com/library/windows/apps/xaml/ee851764.aspx).</span></span>

### <a name="induce-a-garbage-collection-if-its-useful"></a><span data-ttu-id="ee6aa-139">Auslösen einer Garbage Collection bei Bedarf</span><span class="sxs-lookup"><span data-stu-id="ee6aa-139">Induce a garbage collection if it’s useful</span></span>

<span data-ttu-id="ee6aa-140">Lösen Sie eine Garbage Collection nur aus, nachdem Sie die Leistung Ihrer App ermittelt haben und zu dem Schluss gekommen sind, dass sich eine Bereinigung positiv auf das Ergebnis auswirkt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-140">Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</span></span>

<span data-ttu-id="ee6aa-141">Rufen Sie zum Auslösen der Garbage Collection einer Generation [**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx) auf, wobei „n“ für die Generation steht, die Sie erfassen möchten (0, 1 oder 2).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-141">You can induce a garbage collection of a generation by calling [**GC.Collect(n)**](https://msdn.microsoft.com/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</span></span>

<span data-ttu-id="ee6aa-142">**Hinweis**  Wir empfehlen, in Ihrer App keine Garbage Collection zu erzwingen, da der Garbage Collector den besten Zeitpunkt für eine Collection anhand einer Vielzahl heuristischer Daten ermittelt und die Erzwingung einer Collection somit häufig eine unnötige Belastung der CPU darstellt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-142">**Note**  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</span></span> <span data-ttu-id="ee6aa-143">Falls Ihre App allerdings eine große Anzahl von Objekten enthält, die nicht mehr verwendet werden, und Sie den entsprechenden Arbeitsspeicher wieder für das System freigeben möchten, ist die Erzwingung einer Garbage Collection unter Umständen dennoch angemessen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-143">But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</span></span> <span data-ttu-id="ee6aa-144">So können Sie beispielsweise in einem Spiel eine Bereinigung am Ende einer Ladesequenz auslösen, um vor Spielbeginn Arbeitsspeicher freizugeben.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-144">For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</span></span>
 
<span data-ttu-id="ee6aa-145">Damit Sie nicht versehentlich zu viele Garbage Collections auslösen, können Sie [**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) auf **Optimized** festlegen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-145">To avoid inadvertently inducing too many garbage collections, you can set the [**GCCollectionMode**](https://msdn.microsoft.com/library/windows/apps/xaml/bb495757.aspx) to **Optimized**.</span></span> <span data-ttu-id="ee6aa-146">Dadurch wird der Garbage Collector angewiesen, nur dann eine Garbage Collection zu starten, wenn eine ausreichend hohe Produktivität dies rechtfertigt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-146">This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</span></span>

## <a name="reduce-garbage-collection-time"></a><span data-ttu-id="ee6aa-147">Verringern der erforderlichen Zeit für die Garbage Collection</span><span class="sxs-lookup"><span data-stu-id="ee6aa-147">Reduce garbage collection time</span></span>

<span data-ttu-id="ee6aa-148">Dieser Abschnitt gilt, wenn Sie Ihre App analysiert und eine hohe Garbage Collection-Dauer festgestellt haben.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-148">This section applies if you've analyzed your app and observed large garbage collection times.</span></span> <span data-ttu-id="ee6aa-149">Die Pausenzeiten für die Garbage Collection werden von folgenden Aspekten beeinflusst: der erforderlichen Zeit zum Ausführen eines einzelnen Garbage Collection-Durchlaufs und der Zeit, die die App insgesamt für Garbage Collections aufwendet.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-149">Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</span></span> <span data-ttu-id="ee6aa-150">Die Dauer einer Bereinigung hängt davon ab, wie viele Livedaten der Collector analysieren muss.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-150">The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</span></span> <span data-ttu-id="ee6aa-151">Die Größe der Generationen0 und1 ist zwar begrenzt, die Größe der Generation2 nimmt jedoch mit steigender Anzahl aktiver langlebiger Objekte in Ihrer App immer weiter zu.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-151">Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</span></span> <span data-ttu-id="ee6aa-152">Das bedeutet, dass auch die Bereinigungsdauer für die Generationen0 und1 begrenzt ist, während Collections der Generation2 ggf. mehr Zeit in Anspruch nehmen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-152">This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</span></span> <span data-ttu-id="ee6aa-153">Da eine Garbage Collection Arbeitsspeicher freigibt, um Zuordnungsanforderungen zu befriedigen, hängt die Ausführungshäufigkeit von Garbage Collections in erster Linie davon ab, wie viel Arbeitsspeicher Sie zuordnen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-153">How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</span></span>

<span data-ttu-id="ee6aa-154">Der Garbage Collector hält Ihre App von Zeit zu Zeit an, um Arbeiten auszuführen. Dabei wird die App aber nicht zwingend für die gesamte Dauer der Bereinigung angehalten.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-154">The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</span></span> <span data-ttu-id="ee6aa-155">Die Pausenzeiten sind für den Benutzer Ihrer App üblicherweise nicht wahrnehmbar. Dies gilt besonders bei Bereinigungen der Generationen0 und1.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-155">Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</span></span> <span data-ttu-id="ee6aa-156">Die [Hintergrund-Garbage Collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection) des .NET Garbage Collectors ermöglicht die parallele Ausführung von Bereinigungen der Generation2 während der App-Ausführung. Die App wird dabei jeweils nur ganz kurz angehalten.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-156">The [Background garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection) feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</span></span> <span data-ttu-id="ee6aa-157">Bereinigungen der Generation2 können allerdings nicht immer im Hintergrund ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-157">But it is not always possible to do a Generation 2 collection as a background collection.</span></span> <span data-ttu-id="ee6aa-158">In diesem Fall ist die Pause unter Umständen für den Benutzer wahrnehmbar, sofern der Heap entsprechend groß (über 100MB) ist.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-158">In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</span></span>

<span data-ttu-id="ee6aa-159">Häufig ausgeführte Garbage Collections können eine höhere CPU-Auslastung (und damit einen höheren Energiebedarf) sowie längere Ladezeiten oder geringere Bildfrequenzen in Ihrer Anwendung zur Folge haben.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-159">Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</span></span> <span data-ttu-id="ee6aa-160">Im Anschluss finden Sie einige Techniken, mit denen Sie die Dauer der Garbage Collection sowie Pausenzeiten für die Garbage Collection einer verwalteten UWP-App verringern können.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-160">Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</span></span>

### <a name="reduce-memory-allocations"></a><span data-ttu-id="ee6aa-161">Verringern von Arbeitsspeicherzuordnungen</span><span class="sxs-lookup"><span data-stu-id="ee6aa-161">Reduce memory allocations</span></span>

<span data-ttu-id="ee6aa-162">Wenn Sie überhaupt keine Objekte zuordnen, wird der Garbage Collector nur ausgeführt, wenn im System wenig Arbeitsspeicher vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-162">If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</span></span> <span data-ttu-id="ee6aa-163">Eine Verringerung der zugeordneten Arbeitsspeichermenge führt unmittelbar zu einer selteneren Ausführung von Garbage Collections.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-163">Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</span></span>

<span data-ttu-id="ee6aa-164">Sollten Pausen in bestimmten Bereichen Ihrer App absolut unerwünscht sein, können Sie die benötigten Objekte während einer weniger leistungskritischen Phase bereits vorab zuordnen.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-164">If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</span></span> <span data-ttu-id="ee6aa-165">So kann ein Spiel beispielsweise alle zum Spielen benötigten Objekte zuordnen, während der Ladebildschirm eines Levels angezeigt wird, damit beim Spielen keine Zuordnungen mehr erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-165">For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</span></span> <span data-ttu-id="ee6aa-166">Dadurch werden Pausen während des Spielverlaufs vermieden und ggf. höhere und einheitlichere Bildfrequenzen erzielt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-166">This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</span></span>

### <a name="reduce-generation-2-collections-by-avoiding-objects-with-a-medium-length-lifetime"></a><span data-ttu-id="ee6aa-167">Verringern von Bereinigungen der Generation2 durch Vermeidung von Objekten mittlerer Lebensdauer</span><span class="sxs-lookup"><span data-stu-id="ee6aa-167">Reduce generation 2 collections by avoiding objects with a medium-length lifetime</span></span>

<span data-ttu-id="ee6aa-168">Generationsbasierte Garbage Collections funktionieren am besten, wenn Ihre App deutlich kurzlebige und/oder deutlich langlebige Objekte enthält.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-168">Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</span></span> <span data-ttu-id="ee6aa-169">Kurzlebige Objekte werden im Rahmen der weniger aufwendigen Generationen0 und1 bereinigt, während Objekte mit langer Lebensdauer der seltener ausgeführten Bereinigung der Generation2 vorbehalten sind.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-169">Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</span></span> <span data-ttu-id="ee6aa-170">Langlebige Objekte werden während der gesamten Laufzeit Ihrer App (oder über einen längeren Zeitraum) verwendet – beispielsweise während der Anzeige einer bestimmten Seite oder während eines bestimmten Levels.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-170">Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</span></span>

<span data-ttu-id="ee6aa-171">Wenn Sie häufig temporäre Objekte erstellen, die lange genug verwendet werden, um der Generation2 zugeordnet zu werden, werden mehr der aufwendigeren Bereinigungen der Generation2 ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-171">If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</span></span> <span data-ttu-id="ee6aa-172">Die Anzahl von Collections der Generation2 lässt sich gegebenenfalls durch Wiederverwenden vorhandener Objekte oder durch schnelleres Freigeben der Objekte verringern.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-172">You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</span></span>

<span data-ttu-id="ee6aa-173">Ein gängiges Beispiel für Objekte mit mittlerer Lebensdauer sind Objekte, die zum Anzeigen von Elementen in einer Liste dienen, in der der Benutzer einen Bildlauf ausführt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-173">A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</span></span> <span data-ttu-id="ee6aa-174">Wenn Objekte erstellt werden, sobald die Elemente in der Liste in den sichtbaren Bereich rücken, und nicht mehr auf sie verwiesen wird, wenn die Elemente in der Liste den sichtbaren Bereich wieder verlassen, fällt in der App üblicherweise eine große Anzahl von Bereinigungen der Generation2 an.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-174">If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</span></span> <span data-ttu-id="ee6aa-175">In solchen Situationen können Sie für die Daten, die dem Benutzer aktiv angezeigt werden, einen Satz von Objekten vorab zuordnen und wiederverwenden. Dabei können Sie die Infos unter Verwendung kurzlebiger Objekte laden, wenn die Listenelemente in den sichtbaren Bereich rücken.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-175">In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</span></span>

### <a name="reduce-generation-2-collections-by-avoiding-large-sized-objects-with-short-lifetimes"></a><span data-ttu-id="ee6aa-176">Verringern von Bereinigungen der Generation2 durch Vermeidung großer Objekte mit kurzer Lebensdauer</span><span class="sxs-lookup"><span data-stu-id="ee6aa-176">Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</span></span>

<span data-ttu-id="ee6aa-177">Wie bereits erwähnt, wird jedes Objekt ab einer Größe von 85 KB dem Heap für große Objekte (Large Object Heap, LOH) zugeordnet und im Rahmen der Generation2 erfasst.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-177">Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</span></span> <span data-ttu-id="ee6aa-178">Falls Sie über temporäre Variablen (beispielsweise Puffer) mit einer Größe von mehr als 85KB verfügen, werden diese durch eine Bereinigung der Generation2 bereinigt.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-178">If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</span></span> <span data-ttu-id="ee6aa-179">Indem Sie die Größe der temporären Variablen auf unter 85 KB beschränken, können Sie in Ihrer App die Anzahl von Collections der Generation2 verringern.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-179">Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</span></span> <span data-ttu-id="ee6aa-180">Eine gängige Technik ist die Erstellung eines Pufferpools und die Wiederverwendung von Objekten aus dem Pool, um umfangreiche temporäre Zuordnungen zu vermeiden.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-180">One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</span></span>

### <a name="avoid-reference-rich-objects"></a><span data-ttu-id="ee6aa-181">Vermeiden von Objekten mit vielen Verweisen</span><span class="sxs-lookup"><span data-stu-id="ee6aa-181">Avoid reference-rich objects</span></span>

<span data-ttu-id="ee6aa-182">Der Garbage Collector folgt den Verweisen zwischen Objekten, um zu ermitteln, bei welchen Objekten es sich um Liveobjekte handelt. Den Ausgangspunkt bildet dabei jeweils der Stamm in Ihrer App.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-182">The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</span></span> <span data-ttu-id="ee6aa-183">Weitere Informationen finden Sie unter [Vorgänge während einer Garbage Collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-183">For more info, see [What happens during a garbage collection](https://msdn.microsoft.com/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection).</span></span> <span data-ttu-id="ee6aa-184">Enthält ein Objekt eine Vielzahl von Verweisen, bedeutet dies einen höheren Aufwand für den Garbage Collector.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-184">If an object contains many references, then there is more work for the garbage collector to do.</span></span> <span data-ttu-id="ee6aa-185">Eine gängige Technik (besonders bei großen Objekten) ist das Konvertieren von Objekten mit vielen Verweisen in Objekte ohne Verweise (beispielsweise, indem anstelle eines Verweises ein Index gespeichert wird).</span><span class="sxs-lookup"><span data-stu-id="ee6aa-185">A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</span></span> <span data-ttu-id="ee6aa-186">Diese Technik funktioniert natürlich nur, wenn diese Vorgehensweise logisch möglich ist.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-186">Of course this technique works only when it is logically possible to do so.</span></span>

<span data-ttu-id="ee6aa-187">Das Ersetzen von Objektverweisen durch Indizes kann sich für Ihre App als komplizierte Änderung mit Störpotenzial erweisen und ist besonders für große Objekte mit einer Vielzahl von Verweisen gedacht.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-187">Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</span></span> <span data-ttu-id="ee6aa-188">Führen Sie diesen Schritt nur aus, wenn Sie in Ihrer App eine hohe Garbage Collection-Dauer feststellen, die auf Objekte mit vielen Verweisen zurückzuführen ist.</span><span class="sxs-lookup"><span data-stu-id="ee6aa-188">Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</span></span>

 

 




