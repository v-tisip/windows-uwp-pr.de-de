---
author: jwmsft
ms.assetid: DE5B084C-DAC1-430B-A15B-5B3D5FB698F7
title: Optimieren von Animationen, Medien und Bildern
description: Erstellen Sie UWP-Apps (Universelle Windows-Plattform) mit flüssigen Animationen, hoher Bildfrequenz und leistungsstarker Medienaufzeichnung und -wiedergabe.
ms.author: jimwalk
ms.date: 02/08/2017
ms.topic: article
keywords: Windows 10, UWP
ms.localizationpriority: medium
ms.openlocfilehash: 66704daaca67dae2ba4f5a3882f5885ff333d2ce
ms.sourcegitcommit: f2c9a050a9137a473f28b613968d5782866142c6
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 11/09/2018
ms.locfileid: "6250318"
---
# <a name="optimize-animations-media-and-images"></a><span data-ttu-id="6533c-104">Optimieren von Animationen, Medien und Bildern</span><span class="sxs-lookup"><span data-stu-id="6533c-104">Optimize animations, media, and images</span></span>


<span data-ttu-id="6533c-105">Erstellen Sie UWP-Apps (Universelle Windows-Plattform) mit flüssigen Animationen, hoher Bildfrequenz und leistungsstarker Medienaufzeichnung und -wiedergabe.</span><span class="sxs-lookup"><span data-stu-id="6533c-105">Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</span></span>

## <a name="make-animations-smooth"></a><span data-ttu-id="6533c-106">Reibungsloses Einbinden von Animationen</span><span class="sxs-lookup"><span data-stu-id="6533c-106">Make animations smooth</span></span>

<span data-ttu-id="6533c-107">Ein wesentlicher Aspekt der UWP-Apps sind reibungslose Interaktionen.</span><span class="sxs-lookup"><span data-stu-id="6533c-107">A key aspect of UWP apps is smooth interactions.</span></span> <span data-ttu-id="6533c-108">Dazu zählen Fingereingabemanipulationen, die sozusagen am Finger „kleben“, flüssige Übergänge und Animationen sowie kleine Bewegungen, die Eingabefeedback liefern.</span><span class="sxs-lookup"><span data-stu-id="6533c-108">This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</span></span> <span data-ttu-id="6533c-109">Das XAML-Framework verfügt über einen so genannten Kompositionsthread, der für die Zusammenstellung und Animation der visuellen Elemente einer App vorgesehen ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-109">In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</span></span> <span data-ttu-id="6533c-110">Da der Kompositionsthread vom UI-Thread (dem Thread, der den Framework- und den Entwicklercode ausführt) getrennt ist, können Apps unabhängig von komplizierten Layoutdurchläufen oder erweiterten Berechnungen eine gleichmäßige Bildfrequenz und flüssige Animationen erzielen.</span><span class="sxs-lookup"><span data-stu-id="6533c-110">Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</span></span> <span data-ttu-id="6533c-111">In diesem Abschnitt erfahren Sie, wie Sie mithilfe des Kompositionsthreads butterweiche App-Animationen auf den Bildschirm zaubern.</span><span class="sxs-lookup"><span data-stu-id="6533c-111">This section shows how to use the composition thread to keep an app’s animations buttery smooth.</span></span> <span data-ttu-id="6533c-112">Weitere Informationen zu Animationen finden Sie unter [Übersicht über Animationen](https://msdn.microsoft.com/library/windows/apps/Mt187350).</span><span class="sxs-lookup"><span data-stu-id="6533c-112">For more info about animations, see [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350).</span></span> <span data-ttu-id="6533c-113">Informationen zum Verbessern der Reaktionsfähigkeit bei rechenintensiven Vorgängen finden Sie unter [Sicherstellen der Reaktionsfähigkeit des UI-Threads](keep-the-ui-thread-responsive.md).</span><span class="sxs-lookup"><span data-stu-id="6533c-113">To learn about increasing an app’s responsiveness while performing intensive computations, see [Keep the UI thread responsive](keep-the-ui-thread-responsive.md).</span></span>

### <a name="use-independent-instead-of-dependent-animations"></a><span data-ttu-id="6533c-114">Verwenden unabhängiger Animationen anstelle von abhängigen Animationen</span><span class="sxs-lookup"><span data-stu-id="6533c-114">Use independent instead of dependent animations</span></span>

<span data-ttu-id="6533c-115">Unabhängige Animationen können zum Zeitpunkt der Erstellung von Anfang bis Ende berechnet werden, da sich Änderungen an der animierten Eigenschaft nicht auf die restlichen Objekte einer Szene auswirken.</span><span class="sxs-lookup"><span data-stu-id="6533c-115">Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</span></span> <span data-ttu-id="6533c-116">Unabhängige Animationen können daher im Kompositionsthread und nicht im UI-Thread ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-116">Independent animations can therefore run on the composition thread instead of the UI thread.</span></span> <span data-ttu-id="6533c-117">Dadurch ist gewährleistet, dass die Animationen flüssig verlaufen, denn der Kompositionsthread wird in einem gleichmäßigen Rhythmus aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-117">This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</span></span>

<span data-ttu-id="6533c-118">Alle diese Animationsarten sind garantiert unabhängig:</span><span class="sxs-lookup"><span data-stu-id="6533c-118">All of these types of animations are guaranteed to be independent:</span></span>

-   <span data-ttu-id="6533c-119">Objektanimationen mit Keyframes</span><span class="sxs-lookup"><span data-stu-id="6533c-119">Object animations using key frames</span></span>
-   <span data-ttu-id="6533c-120">Animationen ohne Dauer</span><span class="sxs-lookup"><span data-stu-id="6533c-120">Zero-duration animations</span></span>
-   <span data-ttu-id="6533c-121">Animationen der Eigenschaften [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) und [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772)</span><span class="sxs-lookup"><span data-stu-id="6533c-121">Animations to the [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/Hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/Hh759772) properties</span></span>
-   <span data-ttu-id="6533c-122">Animationen der [**UIElement.Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity)-Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="6533c-122">Animations to the [**UIElement.Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) property</span></span>
-   <span data-ttu-id="6533c-123">Animationen von Eigenschaften vom Typ [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush), wenn auf die untergeordnete Eigenschaft [**SolidColorBrush.Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) abgezielt wird</span><span class="sxs-lookup"><span data-stu-id="6533c-123">Animations to properties of type [**Brush**](/uwp/api/Windows.UI.Xaml.Media.Brush) when targeting the [**SolidColorBrush.Color**](/uwp/api/Windows.UI.Xaml.Media.SolidColorBrush.Color) subproperty</span></span>
-   <span data-ttu-id="6533c-124">Animationen der folgenden [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911)-Eigenschaften, wenn auf untergeordneten Eigenschaften dieser Rückgabewerttypen abgezielt wird:</span><span class="sxs-lookup"><span data-stu-id="6533c-124">Animations to the following [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) properties when targeting subproperties of these return value types:</span></span>

    -   [**<span data-ttu-id="6533c-125">RenderTransform</span><span class="sxs-lookup"><span data-stu-id="6533c-125">RenderTransform</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.rendertransform)
    -   [**<span data-ttu-id="6533c-126">Transform3D</span><span class="sxs-lookup"><span data-stu-id="6533c-126">Transform3D</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d)
    -   [**<span data-ttu-id="6533c-127">Projection</span><span class="sxs-lookup"><span data-stu-id="6533c-127">Projection</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.projection)
    -   [**<span data-ttu-id="6533c-128">Clip</span><span class="sxs-lookup"><span data-stu-id="6533c-128">Clip</span></span>**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.clip)

<span data-ttu-id="6533c-129">Abhängige Animationen wirken sich auf das Layout aus und können nicht ohne zusätzliche Angaben aus dem UI-Thread berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-129">Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</span></span> <span data-ttu-id="6533c-130">Abhängige Animationen umfassen Änderungen an Eigenschaften wie [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) und [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height).</span><span class="sxs-lookup"><span data-stu-id="6533c-130">Dependent animations include modifications to properties like [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) and [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height).</span></span> <span data-ttu-id="6533c-131">Abhängige Animationen werden standardmäßig nicht ausgeführt und erfordern die Zustimmung des App-Entwicklers.</span><span class="sxs-lookup"><span data-stu-id="6533c-131">By default, dependent animations are not run and require an opt-in from the app developer.</span></span> <span data-ttu-id="6533c-132">Werden sie aktiviert, laufen sie flüssig ab, solange der UI-Thread nicht blockiert wird. Ist das Framework oder die App dagegen stark mit anderen Vorgängen des UI-Threads ausgelastet, beginnen die Animationen zu ruckeln.</span><span class="sxs-lookup"><span data-stu-id="6533c-132">When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</span></span>

<span data-ttu-id="6533c-133">Nahezu alle Animationen im XAML-Framework sind standardmäßig unabhängig. Sie können diese Optimierung jedoch mithilfe einiger Schritte deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="6533c-133">Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</span></span> <span data-ttu-id="6533c-134">Vorsicht ist besonders bei folgenden Szenarien geboten:</span><span class="sxs-lookup"><span data-stu-id="6533c-134">Beware of these scenarios particularly:</span></span>

-   <span data-ttu-id="6533c-135">Beim Festlegen der [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356)-Eigenschaft, um die Ausführung einer abhängigen Animation im UI-Thread zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="6533c-135">Setting the [**EnableDependentAnimation**](https://msdn.microsoft.com/library/windows/apps/BR210356) property to allow a dependent animation to run on the UI thread.</span></span> <span data-ttu-id="6533c-136">Beim Konvertieren dieser Animationen in eine unabhängige Version.</span><span class="sxs-lookup"><span data-stu-id="6533c-136">Convert these animations into an independent version.</span></span> <span data-ttu-id="6533c-137">Animieren Sie beispielsweise [**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) und [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) anstelle der Eigenschaften [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) und [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) eines Objekts.</span><span class="sxs-lookup"><span data-stu-id="6533c-137">For example animate [**ScaleTransform.ScaleX**](https://msdn.microsoft.com/library/windows/apps/BR242946) and [**ScaleTransform.ScaleY**](https://msdn.microsoft.com/library/windows/apps/BR242948) instead of the [**Width**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Width) and [**Height**](/uwp/api/Windows.UI.Xaml.FrameworkElement.Height) of an object.</span></span> <span data-ttu-id="6533c-138">Objekte wie Bilder und Text können ohne Weiteres skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-138">Don’t be afraid to scale objects like images and text.</span></span> <span data-ttu-id="6533c-139">Das Framework wendet die bilineare Skalierung nur während der Animierung von [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) an.</span><span class="sxs-lookup"><span data-stu-id="6533c-139">The framework applies bilinear scaling only while the [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) is being animated.</span></span> <span data-ttu-id="6533c-140">Bilder/Texte werden in der endgültigen Größe neu gerastert, um zu gewährleisten, dass sie stets gut erkennbar sind.</span><span class="sxs-lookup"><span data-stu-id="6533c-140">The image/text will be rerasterized at the final size to ensure it’s always clear.</span></span>
-   <span data-ttu-id="6533c-141">Bei Verwendung framespezifischer Updates. Hierbei handelt es sich de facto um abhängige Animationen.</span><span class="sxs-lookup"><span data-stu-id="6533c-141">Making per frame updates, which are effectively dependent animations.</span></span> <span data-ttu-id="6533c-142">Ein Beispiel hierfür ist das Anwenden von Transformationen im Handler des [**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127)-Ereignisses.</span><span class="sxs-lookup"><span data-stu-id="6533c-142">An example of this is applying transformations in the handler of the [**CompositonTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) event.</span></span>
-   <span data-ttu-id="6533c-143">Beim Ausführen einer beliebigen, als unabhängig geltenden Animation in einem Element, bei dem die [**CacheMode**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.cachemode)-Eigenschaft auf **BitmapCache** festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-143">Running any animation considered independent in an element with the [**CacheMode**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.cachemode) property set to **BitmapCache**.</span></span> <span data-ttu-id="6533c-144">Dies wird als abhängige Animation betrachtet, da der Cache für jeden Frame neu gerastert werden muss.</span><span class="sxs-lookup"><span data-stu-id="6533c-144">This is considered dependent because the cache must be re-rasterized for each frame.</span></span>

### <a name="dont-animate-a-webview-or-mediaplayerelement"></a><span data-ttu-id="6533c-145">Animieren Sie keine WebView- oder MediaPlayerElement-Objekte.</span><span class="sxs-lookup"><span data-stu-id="6533c-145">Don't animate a WebView or MediaPlayerElement</span></span>

<span data-ttu-id="6533c-146">Webinhalte innerhalb eines [**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702)-Steuerelements werden nicht direkt vom XAML-Framework gerendert. Zudem ist das Zusammenfügen mit dem Rest der Szene mit zusätzlichem Aufwand verbunden.</span><span class="sxs-lookup"><span data-stu-id="6533c-146">Web content within a [**WebView**](https://msdn.microsoft.com/library/windows/apps/BR227702) control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</span></span> <span data-ttu-id="6533c-147">Dieser Zusatzaufwand erhöht sich, wenn das animierte Steuerelement über den Bildschirm bewegt wird. Dies kann unter Umständen zu Synchronisierungsproblemen führen (der HTML-Inhalt könnte z. B. nicht synchron mit dem restlichen XAML-Inhalt der Seite sein).</span><span class="sxs-lookup"><span data-stu-id="6533c-147">This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</span></span> <span data-ttu-id="6533c-148">Wenn Sie ein **WebView**-Steuerelement animieren müssen, ersetzen Sie es für die Dauer der Animation durch ein [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webviewbrush.aspx)-Objekt.</span><span class="sxs-lookup"><span data-stu-id="6533c-148">When you need to animate a **WebView** control, swap it with a [**WebViewBrush**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webviewbrush.aspx) for the duration of the animation.</span></span>

<span data-ttu-id="6533c-149">Auch das Animieren eines [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx)-Objekts ist nicht empfehlenswert.</span><span class="sxs-lookup"><span data-stu-id="6533c-149">Animating a [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is a similarly bad idea.</span></span> <span data-ttu-id="6533c-150">Abgesehen von den Leistungsbeeinträchtigungen kann dies im wiedergegebenen Videoinhalt zu Bildstörungen und anderen Artefakten führen.</span><span class="sxs-lookup"><span data-stu-id="6533c-150">Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</span></span>

> <span data-ttu-id="6533c-151">**Hinweis:**  die Empfehlungen in diesem Artikel für **MediaPlayerElement** gelten auch für [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926).</span><span class="sxs-lookup"><span data-stu-id="6533c-151">**Note** The recommendations in this article for **MediaPlayerElement** also apply to [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/br242926).</span></span> <span data-ttu-id="6533c-152">**MediaPlayerElement** ist nur in Windows10, Version 1607 verfügbar. Wenn Sie daher eine App für eine frühere Version von Windows verwenden, müssen Sie **MediaElement** verwenden.</span><span class="sxs-lookup"><span data-stu-id="6533c-152">**MediaPlayerElement** is only available in Windows 10, version 1607, so if you are creating an app for a previous version of Windows you need to use **MediaElement**.</span></span>

### <a name="use-infinite-animations-sparingly"></a><span data-ttu-id="6533c-153">Setzen Sie Endlosanimationen sparsam ein.</span><span class="sxs-lookup"><span data-stu-id="6533c-153">Use infinite animations sparingly</span></span>

<span data-ttu-id="6533c-154">Die meisten Animationen werden für einen bestimmten Zeitraum ausgeführt. Wenn Sie die [**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207)-Eigenschaft jedoch auf „Forever“ festlegen, kann die Animation ohne zeitliche Begrenzung ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-154">Most animations execute for a specified amount of time, but setting the [**Timeline.Duration**](https://msdn.microsoft.com/library/windows/apps/BR243207) property to Forever allows an animation to run indefinitely.</span></span> <span data-ttu-id="6533c-155">Wir empfehlen, Endlosanimationen möglichst sparsam einzusetzen, da solche Animationen fortlaufend CPU-Ressourcen verbrauchen. Dadurch kann die CPU unter Umständen nicht in den Stromsparmodus oder in den Leerlauf wechseln, was wiederum einen höheren Energieverbrauch zur Folge hat.</span><span class="sxs-lookup"><span data-stu-id="6533c-155">We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</span></span>

<span data-ttu-id="6533c-156">Das Hinzufügen eines Handlers für [**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) ist vergleichbar mit dem Ausführen eines Endlosanimation.</span><span class="sxs-lookup"><span data-stu-id="6533c-156">Adding a handler for [**CompositionTarget.Rendering**](https://msdn.microsoft.com/library/windows/apps/BR228127) is similar to running an infinite animation.</span></span> <span data-ttu-id="6533c-157">Normalerweise ist der UI-Thread nur aktiv, wenn es etwas für ihn zu tun gibt. Fügen Sie jedoch einen Handler für dieses Ereignis hinzu, muss er in jedem Frame ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-157">Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</span></span> <span data-ttu-id="6533c-158">Entfernen Sie den Handler, wenn es nichts zu tun gibt, und registrieren Sie ihn erneut, wenn er wieder benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-158">Remove the handler when there is no work to be done and reregister it when it’s needed again.</span></span>

### <a name="use-the-animation-library"></a><span data-ttu-id="6533c-159">Nutzen Sie die Animationsbibliothek.</span><span class="sxs-lookup"><span data-stu-id="6533c-159">Use the animation library</span></span>

<span data-ttu-id="6533c-160">Der [**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232)-Namespace umfasst eine Bibliothek mit schnellen Hochleistungsanimationen, deren Erscheinungsbild mit anderen Windows-Animation konsistent ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-160">The [**Windows.UI.Xaml.Media.Animation**](https://msdn.microsoft.com/library/windows/apps/BR243232) namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</span></span> <span data-ttu-id="6533c-161">Die relevanten Klassen enthalten „Design“ in ihrem Namen und werden in [Übersicht über Animationen](https://msdn.microsoft.com/library/windows/apps/Mt187350) beschrieben.</span><span class="sxs-lookup"><span data-stu-id="6533c-161">The relevant classes have "Theme" in their name, and are described in [Animations overview](https://msdn.microsoft.com/library/windows/apps/Mt187350).</span></span> <span data-ttu-id="6533c-162">Diese Bibliothek unterstützt viele gängige Animationsszenarien, z.B. die Animation der ersten Ansicht einer App oder die Erstellung von Zustands- und Inhaltsübergängen.</span><span class="sxs-lookup"><span data-stu-id="6533c-162">This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</span></span> <span data-ttu-id="6533c-163">Wir empfehlen, die Animationsbibliothek so oft wie möglich zu nutzen, um die Leistung und Konsistenz für UWP-UI zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="6533c-163">We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</span></span>

> <span data-ttu-id="6533c-164">**Hinweis:**  die animationsbibliothek kann nicht alle mögliche Eigenschaften animiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-164">**Note** The animation library can't animate all possible properties.</span></span> <span data-ttu-id="6533c-165">Informationen zu XAML-Szenarien, bei denen die Animationsbibliothek nicht verwendet werden kann, finden Sie unter [Storyboardanimationen](https://msdn.microsoft.com/library/windows/apps/Mt187354).</span><span class="sxs-lookup"><span data-stu-id="6533c-165">For XAML scenarios where the animation library doesn't apply, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354).</span></span>


### <a name="animate-compositetransform3d-properties-independently"></a><span data-ttu-id="6533c-166">Eigenständiges Animieren von CompositeTransform3D-Eigenschaften</span><span class="sxs-lookup"><span data-stu-id="6533c-166">Animate CompositeTransform3D properties independently</span></span>

<span data-ttu-id="6533c-167">Sie können jede [**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714)-Eigenschaft eigenständig animieren. Wenden Sie daher nur die Animationen an, die Sie benötigen.</span><span class="sxs-lookup"><span data-stu-id="6533c-167">You can animate each property of a [**CompositeTransform3D**](https://msdn.microsoft.com/library/windows/apps/Dn914714) independently, so apply only the animations you need.</span></span> <span data-ttu-id="6533c-168">Beispiele und weitere Informationen finden Sie unter [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d).</span><span class="sxs-lookup"><span data-stu-id="6533c-168">For examples and more info, see [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d).</span></span> <span data-ttu-id="6533c-169">Weitere Informationen zum Animieren von Transformationen finden Sie unter [Storyboardanimationen](https://msdn.microsoft.com/library/windows/apps/Mt187354) und [Keyframeanimationen und Animationen für Beschleunigungsfunktionen](https://msdn.microsoft.com/library/windows/apps/Mt187352).</span><span class="sxs-lookup"><span data-stu-id="6533c-169">For more info about animating transforms, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/Mt187354) and [Key-frame and easing function animations](https://msdn.microsoft.com/library/windows/apps/Mt187352).</span></span>

## <a name="optimize-media-resources"></a><span data-ttu-id="6533c-170">Optimieren von Medienressourcen</span><span class="sxs-lookup"><span data-stu-id="6533c-170">Optimize media resources</span></span>

<span data-ttu-id="6533c-171">Audio, Video und Bilder sind verlockende Arten von Inhalten, die in den meisten Apps zum Einsatz kommen.</span><span class="sxs-lookup"><span data-stu-id="6533c-171">Audio, video, and images are compelling forms of content that the majority of apps use.</span></span> <span data-ttu-id="6533c-172">Da immer mehr Medieninhalte aufgezeichnet und anstelle von SD-Qualität immer häufiger HD-Qualität verwendet wird, steigt der Ressourcenbedarf für die Speicherung, Decodierung und Wiedergabe dieser Inhalte.</span><span class="sxs-lookup"><span data-stu-id="6533c-172">As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</span></span> <span data-ttu-id="6533c-173">Das XAML-Framework nutzt die neuesten Features der UWP-Medienmodule, sodass Apps kostenlos von diesen Verbesserungen profitieren.</span><span class="sxs-lookup"><span data-stu-id="6533c-173">The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</span></span> <span data-ttu-id="6533c-174">Hier werden einige zusätzliche Tricks erläutert, mit denen Sie Medien in Ihrer UWP-App optimal nutzen können.</span><span class="sxs-lookup"><span data-stu-id="6533c-174">Here we explain some additional tricks that allow you to get the most out media in your UWP app.</span></span>

### <a name="release-media-streams"></a><span data-ttu-id="6533c-175">Freigeben von Mediendatenströmen</span><span class="sxs-lookup"><span data-stu-id="6533c-175">Release media streams</span></span>

<span data-ttu-id="6533c-176">Mediendateien sind die gängigsten und aufwendigsten Ressourcen, die von Apps genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-176">Media files are some of the most common and expensive resources apps typically use.</span></span> <span data-ttu-id="6533c-177">Da Mediendateien den Speicherbedarf Ihrer App beträchtlich steigern können, ist es wichtig, das Handle für die Medien unverzüglich freizugeben, sobald die App sie nicht mehr verwendet.</span><span class="sxs-lookup"><span data-stu-id="6533c-177">Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</span></span>

<span data-ttu-id="6533c-178">Wenn Ihre App also beispielsweise ein [**RandomAccessStream**](/uwp/api/Windows.Storage.Streams.RandomAccessStream)- oder [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718)-Objekt verwendet, müssen Sie die close-Methode für das Objekt aufrufen, sobald die App es nicht mehr verwendet. Dadurch wird das zugrundeliegende Objekt freigegeben.</span><span class="sxs-lookup"><span data-stu-id="6533c-178">For example, if your app working with a [**RandomAccessStream**](/uwp/api/Windows.Storage.Streams.RandomAccessStream) or an [**IInputStream**](https://msdn.microsoft.com/library/windows/apps/BR241718) object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</span></span>

### <a name="display-full-screen-video-playback-when-possible"></a><span data-ttu-id="6533c-179">Anzeigen der Videowiedergabe im Vollbildmodus (sofern möglich)</span><span class="sxs-lookup"><span data-stu-id="6533c-179">Display full screen video playback when possible</span></span>

<span data-ttu-id="6533c-180">Verwenden Sie in UWP-Apps stets die [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.isfullwindow.aspx)-Eigenschaft für das [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx), um das vollständige Rendern des Fensters zu aktivieren bzw. zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="6533c-180">In UWP apps, always use the [**IsFullWindow**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.isfullwindow.aspx) property on the [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) to enable and disable full window rendering.</span></span> <span data-ttu-id="6533c-181">Dies stellt sicher, dass während der Medienwiedergabe Optimierungen auf Systemebene genutzt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-181">This insures system level optimizations are used during media playback.</span></span>

<span data-ttu-id="6533c-182">Das XAML-Framework kann die Darstellung von Videoinhalten optimieren, wenn nur das Video gerendert wird. Dies senkt den Energieverbrauch und erhöht die Bildfrequenz.</span><span class="sxs-lookup"><span data-stu-id="6533c-182">The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</span></span> <span data-ttu-id="6533c-183">Um eine möglichst effiziente Medienwiedergabe zu erhalten, legen Sie die Größe eines **MediaPlayerElement**-Objekts auf die Breite und Höhe des Bildschirms fest. Zeigen Sie außerdem keine weiteren XAML-Elemente an.</span><span class="sxs-lookup"><span data-stu-id="6533c-183">For most efficient media playback set the size of a **MediaPlayerElement** to be the width and height of the screen and don’t display other XAML elements</span></span>

<span data-ttu-id="6533c-184">Es gibt durchaus berechtigte Gründe für die Überlagerung von XAML-Elementen auf einem **MediaPlayerElement**-Objekt, das die gesamte Höhe und Breite des Bildschirms einnimmt, beispielsweise für Untertitel oder kurzzeitig angezeigte Transportsteuerelemente.</span><span class="sxs-lookup"><span data-stu-id="6533c-184">There are legitimate reasons to overlay XAML elements on a **MediaPlayerElement** that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</span></span> <span data-ttu-id="6533c-185">Stellen Sie sicher, dass diese Elemente ausgeblendet werden (durch Festlegen von `Visibility="Collapsed"`), wenn sie nicht benötigt werden, um die Medienwiedergabe wieder in den effizientesten Zustand zu versetzen.</span><span class="sxs-lookup"><span data-stu-id="6533c-185">Make sure to hide these elements (set `Visibility="Collapsed"`) when they are not needed to put media playback back into its most efficient state.</span></span>

### <a name="display-deactivation-and-conserving-power"></a><span data-ttu-id="6533c-186">Deaktivieren des Displays und Einsparen von Energie</span><span class="sxs-lookup"><span data-stu-id="6533c-186">Display deactivation and conserving power</span></span>

<span data-ttu-id="6533c-187">Um ein Deaktivieren des Displays zu verhindern, wenn keine Benutzeraktion mehr festgestellt werden kann (z. B. bei der Wiedergabe eines Videos in einer App), können Sie [**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818) aufrufen.</span><span class="sxs-lookup"><span data-stu-id="6533c-187">To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call [**DisplayRequest.RequestActive**](https://msdn.microsoft.com/library/windows/apps/BR241818).</span></span>

<span data-ttu-id="6533c-188">Um Energie zu sparen und den Akku zu schonen, wird empfohlen, [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) aufzurufen und die Displayanforderung freizugeben, sobald diese nicht mehr benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-188">To conserve power and battery life, you should call [**DisplayRequest.RequestRelease**](https://msdn.microsoft.com/library/windows/apps/BR241819) to release the display request as soon as it is no longer required.</span></span>

<span data-ttu-id="6533c-189">Unten sind einige Situationen aufgeführt, in denen Sie die Displayanforderung freigeben sollten:</span><span class="sxs-lookup"><span data-stu-id="6533c-189">Here are some situations when you should release the display request:</span></span>

-   <span data-ttu-id="6533c-190">Die Videowiedergabe wird angehalten, z.B. per Benutzeraktion, wird gepuffert oder aufgrund begrenzter Bandbreite angepasst.</span><span class="sxs-lookup"><span data-stu-id="6533c-190">Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</span></span>
-   <span data-ttu-id="6533c-191">Die Wiedergabe wird gestoppt.</span><span class="sxs-lookup"><span data-stu-id="6533c-191">Playback stops.</span></span> <span data-ttu-id="6533c-192">Beispielsweise ist die Wiedergabe des Videos beendet oder die Darstellung vorüber.</span><span class="sxs-lookup"><span data-stu-id="6533c-192">For example, the video is done playing or the presentation is over.</span></span>
-   <span data-ttu-id="6533c-193">Ein Wiedergabefehler ist aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="6533c-193">A playback error has occurred.</span></span> <span data-ttu-id="6533c-194">Es können beispielsweise Probleme mit der Netzwerkverbindung bestehen, oder eine Datei kann beschädigt sein.</span><span class="sxs-lookup"><span data-stu-id="6533c-194">For example, network connectivity issues or a corrupted file.</span></span>

### <a name="put-other-elements-to-the-side-of-embedded-video"></a><span data-ttu-id="6533c-195">Platzieren anderer Elemente neben dem eingebetteten Video</span><span class="sxs-lookup"><span data-stu-id="6533c-195">Put other elements to the side of embedded video</span></span>

<span data-ttu-id="6533c-196">Apps bieten häufig eine eingebettete Ansicht, bei der das Video innerhalb einer Seite wiedergegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-196">Often apps offer an embedded view where video is played within a page.</span></span> <span data-ttu-id="6533c-197">Es ist nun keine Vollbildoptimierung mehr verfügbar, da das [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) nicht die gesamte Seitengröße einnimmt und außerdem auch andere XAML-Objekte gezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-197">Now you obviously lost the full screen optimization because the [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is not the size of the page and there are other XAML objects drawn.</span></span> <span data-ttu-id="6533c-198">Achten Sie darauf, nicht versehentlich in diesen Modus zu wechseln, indem Sie einen Rahmen um ein **MediaPlayerElement**-Objekt zeichnen.</span><span class="sxs-lookup"><span data-stu-id="6533c-198">Beware of unintentionally entering this mode by drawing a border around a **MediaPlayerElement**.</span></span>

<span data-ttu-id="6533c-199">Zeichnen Sie keine XAML-Elemente im Vordergrund des Videos, wenn sich dieses im eingebetteten Modus befindet.</span><span class="sxs-lookup"><span data-stu-id="6533c-199">Don’t draw XAML elements on top of video when it’s in embedded mode.</span></span> <span data-ttu-id="6533c-200">Andernfalls bedeutet dies einen Zusatzaufwand beim Erstellen der Szene.</span><span class="sxs-lookup"><span data-stu-id="6533c-200">If you do, the framework is forced to do a little extra work to compose the scene.</span></span> <span data-ttu-id="6533c-201">Ein gutes Optimierungsbeispiel für diese Situation ist das Platzieren von Transportsteuerelementen unterhalb eines eingebetteten Medienelements (anstatt im Vordergrund des Videos).</span><span class="sxs-lookup"><span data-stu-id="6533c-201">Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</span></span> <span data-ttu-id="6533c-202">In diesem Bild steht der rote Balken für eine Gruppe von Transportsteuerelementen (Wiedergabe, Pause, Stopp usw.).</span><span class="sxs-lookup"><span data-stu-id="6533c-202">In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</span></span>

![MediaPlayerElement mit überlagerten Elementen](images/videowithoverlay.png)

<span data-ttu-id="6533c-204">Platzieren Sie diese Steuerelemente nicht im Vordergrund eines Mediums, das sich nicht im Vollbildmodus befindet.</span><span class="sxs-lookup"><span data-stu-id="6533c-204">Don’t place these controls on top of media that is not full screen.</span></span> <span data-ttu-id="6533c-205">Positionieren Sie die Transportsteuerelemente stattdessen irgendwo außerhalb des Bereichs, in dem das Medium gerendert wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-205">Instead place the transport controls somewhere outside of the area where the media is being rendered.</span></span> <span data-ttu-id="6533c-206">Im nächsten Bild befinden sich die Steuerelemente unterhalb des Mediums.</span><span class="sxs-lookup"><span data-stu-id="6533c-206">In the next image, the controls are placed below the media.</span></span>

![MediaPlayerElement mit benachbarten Elementen](images/videowithneighbors.png)

### <a name="delay-setting-the-source-for-a-mediaplayerelement"></a><span data-ttu-id="6533c-208">Verzögern des Festlegens der Quelle für ein MediaPlayerElement</span><span class="sxs-lookup"><span data-stu-id="6533c-208">Delay setting the source for a MediaPlayerElement</span></span>

<span data-ttu-id="6533c-209">Medienmodule sind aufwendige Objekte, und das XAML-Framework verzögert das Laden von DLLs sowie das Erstellen großer Objekte so lange wie möglich.</span><span class="sxs-lookup"><span data-stu-id="6533c-209">Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</span></span> <span data-ttu-id="6533c-210">Das [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) ist gezwungen, diese Arbeit auszuführen, nachdem dessen Quelle über die Eigenschaft [**Source**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.source.aspx) festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="6533c-210">The [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx) is forced to do this work after its source is set via the [**Source**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.source.aspx) property.</span></span> <span data-ttu-id="6533c-211">Indem Sie dies festlegen, wenn der Benutzer wirklich ein Medium wiedergeben möchte, verzögern Sie den Großteil des Aufwands für das **MediaPlayerElement**-Objekt so weit wie möglich.</span><span class="sxs-lookup"><span data-stu-id="6533c-211">Setting this when the user is really ready to play media delays the majority of the cost associated with the **MediaPlayerElement** as long as possible.</span></span>

### <a name="set-mediaplayerelementpostersource"></a><span data-ttu-id="6533c-212">Festlegen von MediaElement.PosterSource</span><span class="sxs-lookup"><span data-stu-id="6533c-212">Set MediaPlayerElement.PosterSource</span></span>

<span data-ttu-id="6533c-213">Durch Festlegen von [**MediaPlayerElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.postersource.aspx) kann XAML einige GPU-Ressourcen freigeben, die andernfalls verwendet würden.</span><span class="sxs-lookup"><span data-stu-id="6533c-213">Setting [**MediaPlayerElement.PosterSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.postersource.aspx) enables XAML to release some GPU resources that would have otherwise been used.</span></span> <span data-ttu-id="6533c-214">Diese API ermöglicht es einer App, so wenig Arbeitsspeicher wie möglich zu beanspruchen.</span><span class="sxs-lookup"><span data-stu-id="6533c-214">This API allows an app to use as little memory as possible.</span></span>

### <a name="improve-media-scrubbing"></a><span data-ttu-id="6533c-215">Verbessern des Medien-Scrubbings</span><span class="sxs-lookup"><span data-stu-id="6533c-215">Improve media scrubbing</span></span>

<span data-ttu-id="6533c-216">Bei Medienplattformen ist es immer eine besondere Herausforderung, dafür zu sorgen, dass das Scrubbing möglichst gut reagiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-216">Scrubbing is always a tough task for media platforms to make really responsive.</span></span> <span data-ttu-id="6533c-217">Üblicherweise wird hierzu der Wert eines Schiebereglers geändert.</span><span class="sxs-lookup"><span data-stu-id="6533c-217">Generally people accomplish this by changing the value of a Slider.</span></span> <span data-ttu-id="6533c-218">Im Folgenden finden Sie einige Tipps für eine möglichst effiziente Verwendung:</span><span class="sxs-lookup"><span data-stu-id="6533c-218">Here are a couple tips on how to make this as efficient as possible:</span></span>

-   <span data-ttu-id="6533c-219">Aktualisieren Sie den Wert des [**Schiebereglers**](https://msdn.microsoft.com/library/windows/apps/BR209614) basierend auf einem Timer, der die [**Position**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.position.aspx) auf [**MediaPlayerElement.MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.mediaplayer.aspx) abfragt.</span><span class="sxs-lookup"><span data-stu-id="6533c-219">Update the value of [**Slider**](https://msdn.microsoft.com/library/windows/apps/BR209614) based on a timer that queries the [**Position**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.position.aspx) on the [**MediaPlayerElement.MediaPlayer**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.mediaplayer.aspx).</span></span> <span data-ttu-id="6533c-220">Stellen Sie sicher, dass Sie eine geeignete Aktualisierungsfrequenz für den Timer verwenden.</span><span class="sxs-lookup"><span data-stu-id="6533c-220">Make sure to use a reasonable update frequency for your timer.</span></span> <span data-ttu-id="6533c-221">Die Eigenschaft **Position** wird während der Wiedergabe nur alle 250Millisekunden aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-221">The **Position** property only updates every 250 millisecond during playback.</span></span>
-   <span data-ttu-id="6533c-222">Die Größe der Schrittfrequenz für den Schieberegler muss gemäß der Videolänge skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-222">The size of the step frequency on the Slider must scale with the length of the video.</span></span>
-   <span data-ttu-id="6533c-223">Abonnieren Sie die Ereignisse [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerpressed.aspx), [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointermoved.aspx) und [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) für den Schieberegler, um die [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.playbackrate.aspx)-Eigenschaft auf „0“ festzulegen, wenn der Benutzer den Ziehpunkt des Schiebereglers bewegt.</span><span class="sxs-lookup"><span data-stu-id="6533c-223">Subscribe to the [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerpressed.aspx), [**PointerMoved**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointermoved.aspx), [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) events on the slider to set the [**PlaybackRate**](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplaybacksession.playbackrate.aspx) property to 0 when the user drags the thumb of the slider.</span></span>
-   <span data-ttu-id="6533c-224">Legen Sie die Medienposition im [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx)-Ereignishandler manuell auf den Wert der Schiebereglerposition fest, um beim Scrubbing eine optimale Ziehpunktausrichtung zu gewährleisten.</span><span class="sxs-lookup"><span data-stu-id="6533c-224">In the [**PointerReleased**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.pointerreleased.aspx) event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</span></span>

### <a name="match-video-resolution-to-device-resolution"></a><span data-ttu-id="6533c-225">Anpassen der Videoauflösung an die Geräteauflösung</span><span class="sxs-lookup"><span data-stu-id="6533c-225">Match video resolution to device resolution</span></span>

<span data-ttu-id="6533c-226">Die Videodecodierung benötigt sehr viel Arbeitsspeicher sowie sehr viele GPU-Zyklen. Entscheiden Sie sich daher für ein Videoformat, das der Auflösung, mit der das Video wiedergegeben wird, am nächsten kommt.</span><span class="sxs-lookup"><span data-stu-id="6533c-226">Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</span></span> <span data-ttu-id="6533c-227">Es bringt nichts, die Ressourcen zur Decodierung eines 1080-Videos zu verwenden, wenn es ohnehin auf eine deutlich geringere Größe skaliert wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-227">There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</span></span> <span data-ttu-id="6533c-228">Bei vielen Apps liegt ein Video nicht in mehreren Auflösungen vor. Ist dies jedoch der Fall, verwenden Sie möglichst eine Codierung, die der Anzeigeauflösung am nächsten kommt.</span><span class="sxs-lookup"><span data-stu-id="6533c-228">Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</span></span>

### <a name="choose-recommended-formats"></a><span data-ttu-id="6533c-229">Wählen empfohlener Formate</span><span class="sxs-lookup"><span data-stu-id="6533c-229">Choose recommended formats</span></span>

<span data-ttu-id="6533c-230">Die Wahl des Medienformats kann ein sensibles Thema sein und ist häufig abhängig von geschäftspolitischen Entscheidungen.</span><span class="sxs-lookup"><span data-stu-id="6533c-230">Media format selection can be a sensitive topic and is often driven by business decisions.</span></span> <span data-ttu-id="6533c-231">Im Hinblick auf die Leistung von UWP empfehlen wir H.264-Video als primäres Videoformat sowie AAC und MP3 als bevorzugte Audioformate.</span><span class="sxs-lookup"><span data-stu-id="6533c-231">From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</span></span> <span data-ttu-id="6533c-232">Bei der lokalen Dateiwiedergabe ist MP4 der bevorzugte Dateicontainer für Videoinhalte.</span><span class="sxs-lookup"><span data-stu-id="6533c-232">For local file playback, MP4 is the preferred file container for video content.</span></span> <span data-ttu-id="6533c-233">Die Decodierung von H.264 wird von den meisten aktuellen Grafikkarten beschleunigt.</span><span class="sxs-lookup"><span data-stu-id="6533c-233">H.264 decoding is accelerated through most recent graphics hardware.</span></span> <span data-ttu-id="6533c-234">Zudem gilt es zu berücksichtigen, dass die Beschleunigung bei vielen der auf dem Markt erhältlichen Grafikkarten häufig auf eine partielle Beschleunigung (oder auf die IDCT-Ebene) beschränkt ist und keine Hardwareauslagerung für die gesamte Datenstromebene (VLD-Modus) stattfindet, obwohl die Hardwarebeschleunigung für die VC-1-Decodierung weitgehend verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-234">Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</span></span>

<span data-ttu-id="6533c-235">Wenn die Kontrolle über die Videoinhaltsgenerierung vollständig bei Ihnen liegt, müssen Sie ein möglichst ausgeglichenes Verhältnis zwischen Komprimierungseffizienz und GOP-Struktur finden.</span><span class="sxs-lookup"><span data-stu-id="6533c-235">If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</span></span> <span data-ttu-id="6533c-236">Eine relativ geringe GOP-Größe bei B-Bildern kann die Leistung bei Such- oder Trickmodi verbessern.</span><span class="sxs-lookup"><span data-stu-id="6533c-236">Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</span></span>

<span data-ttu-id="6533c-237">Verwenden Sie für kurze Audioeffekte mit geringer Latenz (beispielsweise in Spielen) WAV-Dateien mit nicht komprimierten PCM-Daten, um den für komprimierte Audioformate typischen Verarbeitungsmehraufwand zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="6533c-237">When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</span></span>


## <a name="optimize-image-resources"></a><span data-ttu-id="6533c-238">Optimieren von Bildressourcen</span><span class="sxs-lookup"><span data-stu-id="6533c-238">Optimize image resources</span></span>

### <a name="scale-images-to-the-appropriate-size"></a><span data-ttu-id="6533c-239">Skalieren von Bildern auf eine angemessene Größe</span><span class="sxs-lookup"><span data-stu-id="6533c-239">Scale images to the appropriate size</span></span>

<span data-ttu-id="6533c-240">Bilder werden in sehr hohen Auflösungen erfasst, was dazu führen kann, dass Apps mehr CPU beim Decodieren der Bilddaten und mehr Arbeitsspeicher nach dem Laden vom Datenträger belegen.</span><span class="sxs-lookup"><span data-stu-id="6533c-240">Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</span></span> <span data-ttu-id="6533c-241">Es ist jedoch nicht sehr sinnvoll, ein Bild in hoher Auflösung zu decodieren und im Arbeitsspeicher zu speichern, nur um es dann kleiner als in seiner ursprünglichen Größe anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="6533c-241">But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</span></span> <span data-ttu-id="6533c-242">Erstellen Sie stattdessen eine Version des Bilds in der genauen Größe, in der es auf dem Bildschirm gezeichnet wird. Verwenden Sie hierzu die Eigenschaften [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) und [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241).</span><span class="sxs-lookup"><span data-stu-id="6533c-242">Instead, create a version of the image at the exact size it will be drawn on-screen using the [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) properties.</span></span>

<span data-ttu-id="6533c-243">Nicht empfohlen:</span><span class="sxs-lookup"><span data-stu-id="6533c-243">Don't do this:</span></span>

```xaml
<Image Source="ms-appx:///Assets/highresCar.jpg"
       Width="300" Height="200"/>    <!-- BAD CODE DO NOT USE.-->
```

<span data-ttu-id="6533c-244">Empfohlene Vorgehensweise:</span><span class="sxs-lookup"><span data-stu-id="6533c-244">Instead, do this:</span></span>

```xaml
<Image>
    <Image.Source>
    <BitmapImage UriSource="ms-appx:///Assets/highresCar.jpg"
                 DecodePixelWidth="300" DecodePixelHeight="200"/>
    </Image.Source>
</Image>
```

<span data-ttu-id="6533c-245">Als Einheiten für [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) und [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) werden standardmäßig physische Pixel verwendet.</span><span class="sxs-lookup"><span data-stu-id="6533c-245">The units for [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) are by default physical pixels.</span></span> <span data-ttu-id="6533c-246">Mit der [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545)-Eigenschaft kann dieses Verhalten geändert werden: Durch Festlegen von **DecodePixelType** auf **Logical** wird bei der Decodierungsgröße automatisch der aktuelle Skalierungsfaktor des Systems ähnlich wie andere XAML-Inhalte berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="6533c-246">The [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) property can be used to change this behavior: setting **DecodePixelType** to **Logical** results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</span></span> <span data-ttu-id="6533c-247">Daher ist es in der Regel sinnvoll, **DecodePixelType** auf **Logical** festzulegen, wenn beispielsweise **DecodePixelWidth** und **DecodePixelHeight** den Eigenschaften für Höhe und Breite des Bildsteuerelements entsprechen sollen, in dem das Bild angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-247">It would therefore be generally appropriate to set **DecodePixelType** to **Logical** if, for instance, you want **DecodePixelWidth** and **DecodePixelHeight** to match the Height and Width properties of the Image control the image will be displayed in.</span></span> <span data-ttu-id="6533c-248">Beim Standardverhalten mit Verwendung von physischen Pixeln müssen Sie selbst den aktuellen Skalierungsfaktor des Systems berücksichtigen; für den Fall, dass der Benutzer seine Anzeigeeinstellungen ändert, sollten Sie auf Benachrichtigungen über Skalierungsänderungen achten.</span><span class="sxs-lookup"><span data-stu-id="6533c-248">With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</span></span>

<span data-ttu-id="6533c-249">Wenn „DecodePixelWidth/Height“ explizit größer als die Bildanzeige auf dem Bildschirm festgelegt sind, belegt die App unnötigen zusätzlichen Arbeitsspeicher (bis zu 4 Byte pro Pixel), was bei großen Bildern deutlich ins Gewicht fällt.</span><span class="sxs-lookup"><span data-stu-id="6533c-249">If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</span></span> <span data-ttu-id="6533c-250">Zudem wird das Bild mit bilinearer Skalierung verkleinert und kann bei großen Skalierungsfaktoren unscharf dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-250">The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</span></span>

<span data-ttu-id="6533c-251">Wenn DecodePixelWidth/DecodePixelHeight explizit kleiner als die Bilddarstellung auf dem Bildschirm festgelegt werden, wird das Bild vergrößert und kann pixelig aussehen.</span><span class="sxs-lookup"><span data-stu-id="6533c-251">If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</span></span>

<span data-ttu-id="6533c-252">In einigen Fällen, in denen es nicht möglich ist, die passende Decodierungsgröße im Voraus zu bestimmen, sollten Sie die automatische Decodierung von XAML auf die richtige Größe nutzen. Dabei wird nach Möglichkeit versucht, das Bild in der passenden Größe zu decodieren, wenn keine explizite DecodePixelWidth/DecodePixelHeight angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-252">In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</span></span>

<span data-ttu-id="6533c-253">Es wird empfohlen, eine explizite Decodierungsgröße festzulegen, wenn Sie die Größe des Bildinhalts bereits vorab kennen.</span><span class="sxs-lookup"><span data-stu-id="6533c-253">You should set an explicit decode size if you know the size of the image content ahead of time.</span></span> <span data-ttu-id="6533c-254">Legen Sie gleichzeitig [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) auf **Logical** fest, wenn die angegebene Decodierungsgröße in Bezug auf andere XAML-Elementgrößen relativ ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-254">You should also in conjunction set [**DecodePixelType**](https://msdn.microsoft.com/library/windows/apps/Dn298545) to **Logical** if the supplied decode size is relative to other XAML element sizes.</span></span> <span data-ttu-id="6533c-255">Wenn Sie z.B. die Inhaltsgröße explizit mit Image.Width und Image.Height festlegen, legen Sie DecodePixelType auf DecodePixelType.Logical fest, um die gleichen logischen Pixeldimensionen wie ein Bildsteuerelement zu verwenden, und verwenden sie dann explizit BitmapImage.DecodePixelWidth und/oder BitmapImage.DecodePixelHeight, um die Größe des Bilds zu steuern und potenziell mehr Arbeitsspeicher einzusparen.</span><span class="sxs-lookup"><span data-stu-id="6533c-255">For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</span></span>

<span data-ttu-id="6533c-256">Beachten Sie, dass Image.Stretch beim Bestimmen der Größe des decodierten Inhalts berücksichtigt werden sollte.</span><span class="sxs-lookup"><span data-stu-id="6533c-256">Note that Image.Stretch should be considered when determining the size of the decoded content.</span></span>

### <a name="right-sized-decoding"></a><span data-ttu-id="6533c-257">Richtige Größe der Decodierung</span><span class="sxs-lookup"><span data-stu-id="6533c-257">Right-sized decoding</span></span>

<span data-ttu-id="6533c-258">Wenn Sie keine explizite Decodierungsgröße festlegen, versucht XAML, möglich viel Arbeitsspeicher zu sparen. Dabei wird das Bild auf die genaue Größe decodiert, in der es gemäß dem anfänglichen Layout der Seite angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-258">In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</span></span> <span data-ttu-id="6533c-259">Es wird empfohlen, die Anwendung so zu schreiben, dass dieses Feature nach Möglichkeit genutzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="6533c-259">You're advised to write your application in such a way as to make use of this feature when possible.</span></span> <span data-ttu-id="6533c-260">Dieses Feature wird deaktiviert, wenn eine der folgenden Bedingungen erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-260">This feature will be disabled if any of the following conditions are met.</span></span>

-   <span data-ttu-id="6533c-261">Das [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235)-Objekt wird mit der Live-XAML-Struktur verbunden, nachdem der Inhalt mit [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) oder [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="6533c-261">The [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) is connected to the live XAML tree after setting the content with [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) or [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx).</span></span>
-   <span data-ttu-id="6533c-262">Das Bild wird mit synchroner Decodierung wie [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) decodiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-262">The image is decoded using synchronous decoding such as [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255).</span></span>
-   <span data-ttu-id="6533c-263">Das Bild wird durch Festlegung von [**Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) auf 0 oder [**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) auf **Collapsed** für das Hostbildelement, den Pinsel oder ein beliebiges übergeordnetes Element ausgeblendet.</span><span class="sxs-lookup"><span data-stu-id="6533c-263">The image is hidden via setting [**Opacity**](/uwp/api/Windows.UI.Xaml.UIElement.Opacity) to 0 or [**Visibility**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.visibility) to **Collapsed** on the host image element or brush or any parent element.</span></span>
-   <span data-ttu-id="6533c-264">Das Bildsteuerelement bzw. der Pinsel verwendet für die [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968)-Aufzählung den Wert **None**.</span><span class="sxs-lookup"><span data-stu-id="6533c-264">The image control or brush uses a [**Stretch**](https://msdn.microsoft.com/library/windows/apps/BR242968) of **None**.</span></span>
-   <span data-ttu-id="6533c-265">Das Bild wird als [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) verwendet.</span><span class="sxs-lookup"><span data-stu-id="6533c-265">The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).</span></span>
-   `CacheMode="BitmapCache"` <span data-ttu-id="6533c-266">wird auf das Bildelement oder ein beliebiges übergeordnetes Element festgelegt.</span><span class="sxs-lookup"><span data-stu-id="6533c-266">is set on the image element or on any parent element.</span></span>
-   <span data-ttu-id="6533c-267">Der Bildpinsel ist nicht rechteckig (z. B. bei Anwendung auf eine Form oder auf Text).</span><span class="sxs-lookup"><span data-stu-id="6533c-267">The image brush is non-rectangular (such as when applied to a shape or to text).</span></span>

<span data-ttu-id="6533c-268">In den oben genannten Szenarien ist das Festlegen einer expliziten Decodierungsgröße die einzige Möglichkeit, um Arbeitsspeichereinsparungen zu erzielen.</span><span class="sxs-lookup"><span data-stu-id="6533c-268">In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</span></span>

<span data-ttu-id="6533c-269">Fügen Sie stets ein [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235)-Objekt an die Live-Struktur an, bevor Sie die Quelle festlegen.</span><span class="sxs-lookup"><span data-stu-id="6533c-269">You should always attach a [**BitmapImage**](https://msdn.microsoft.com/library/windows/apps/BR243235) to the live tree before setting the source.</span></span> <span data-ttu-id="6533c-270">Dies erfolgt jedes Mal automatisch, wenn ein Bildelement oder ein Pinsel in Markup angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-270">Any time an image element or brush is specified in markup, this will automatically be the case.</span></span> <span data-ttu-id="6533c-271">Beispiele finden Sie weiter unten im Abschnitt „Live-Struktur-Beispiele“.</span><span class="sxs-lookup"><span data-stu-id="6533c-271">Examples are provided below under the heading "Live tree examples".</span></span> <span data-ttu-id="6533c-272">Vermeiden Sie beim Festlegen einer Datenstromquelle stets die Verwendung von [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255), und verwenden Sie stattdessen [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522).</span><span class="sxs-lookup"><span data-stu-id="6533c-272">You should always avoid using [**SetSource**](https://msdn.microsoft.com/library/windows/apps/BR243255) and instead use [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when setting a stream source.</span></span> <span data-ttu-id="6533c-273">Zudem ist es sinnvoll, das Ausblenden von Bildinhalten (entweder durch eine Deckkraft von null oder die Sichtbarkeitseinstellung „Collapsed“) zu vermeiden, während Sie darauf warten, dass das [**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.imageopened.aspx)-Ereignis ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-273">And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the [**ImageOpened**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.imageopened.aspx) event to be raised.</span></span> <span data-ttu-id="6533c-274">Wägen Sie Ihre Entscheidung ab. Sie können in diesem Fall die Vorteile der automatischen Decodierung in der richtigen Größe nicht nutzen.</span><span class="sxs-lookup"><span data-stu-id="6533c-274">Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</span></span> <span data-ttu-id="6533c-275">Wenn Ihre App Bilder anfänglich ausblenden muss, sollte nach Möglichkeit auch die Decodierungsgröße explizit festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-275">If your app must hide image content initially then it should also set the decode size explicitly if possible.</span></span>

**<span data-ttu-id="6533c-276">Live-Struktur-Beispiele</span><span class="sxs-lookup"><span data-stu-id="6533c-276">Live tree examples</span></span>**

<span data-ttu-id="6533c-277">Beispiel 1 (gut): URI (Uniform Resource Identifier) in Markup angegeben.</span><span class="sxs-lookup"><span data-stu-id="6533c-277">Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</span></span>

```xaml
<Image x:Name="myImage" UriSource="Assets/cool-image.png"/>
```

<span data-ttu-id="6533c-278">Beispiel 2 – Markup: URI in CodeBehind angegeben.</span><span class="sxs-lookup"><span data-stu-id="6533c-278">Example 2 markup—URI specified in code-behind.</span></span>

```xaml
<Image x:Name="myImage"/>
```

<span data-ttu-id="6533c-279">Beispiel 2 – CodeBehind (gut): Verbinden des BitmapImage mit der Struktur, bevor dessen UriSource festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-279">Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</span></span>

```csharp
var bitmapImage = new BitmapImage();
myImage.Source = bitmapImage;
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
```

<span data-ttu-id="6533c-280">Beispiel 2 – CodeBehind (schlecht) – Festlegen der UriSource von BitmapImage, bevor es mit der Struktur verbunden.</span><span class="sxs-lookup"><span data-stu-id="6533c-280">Example 2 code-behind (bad)—setting the BitmapImage's UriSource before connecting it to the tree.</span></span>

```csharp
var bitmapImage = new BitmapImage();
bitmapImage.UriSource = new URI("ms-appx:///Assets/cool-image.png", UriKind.RelativeOrAbsolute);
myImage.Source = bitmapImage;
```

### <a name="caching-optimizations"></a><span data-ttu-id="6533c-281">Optimierungen der Zwischenspeicherung</span><span class="sxs-lookup"><span data-stu-id="6533c-281">Caching optimizations</span></span>

<span data-ttu-id="6533c-282">Optimierungen beim Zwischenspeichern gelten für Bilder, die [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) zum Laden von Inhalten aus einem App-Paket oder aus dem Internet verwenden.</span><span class="sxs-lookup"><span data-stu-id="6533c-282">Caching optimizations are in effect for images that use [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) to load content from an app package or from the web.</span></span> <span data-ttu-id="6533c-283">Der URI wird verwendet, um den zugrunde liegenden Inhalt eindeutig zu identifizieren. Intern sorgt er dafür, dass das XAML-Framework Inhalte nicht mehrmals herunterlädt oder decodiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-283">The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</span></span> <span data-ttu-id="6533c-284">Stattdessen werden die zwischengespeicherten Software- oder Hardwareressourcen verwendet, um Inhalte mehrmals anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="6533c-284">Instead, it will use the cached software or hardware resources to display the content multiple times.</span></span>

<span data-ttu-id="6533c-285">Eine Ausnahme von dieser Optimierung besteht, wenn das Bild mehrmals in unterschiedlichen Auflösungen angezeigt wird (was explizit oder über automatische Decodierung in der richtigen Größe angegeben werden kann).</span><span class="sxs-lookup"><span data-stu-id="6533c-285">The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</span></span> <span data-ttu-id="6533c-286">Jeder Eintrag im Zwischenspeicher speichert auch die Auflösung des Bilds, und wenn XAML kein Bild mit einem Quell-URI finden kann, der der erforderlichen Auflösung entspricht, wird eine neue Version in dieser Größe decodiert.</span><span class="sxs-lookup"><span data-stu-id="6533c-286">Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</span></span> <span data-ttu-id="6533c-287">Die codierten Bilddaten werden jedoch nicht erneut heruntergeladen.</span><span class="sxs-lookup"><span data-stu-id="6533c-287">It will not, however, download the encoded image data again.</span></span>

<span data-ttu-id="6533c-288">Aus diesem Grund sollten Sie [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) verwenden, wenn Sie Bilder aus einem App-Paket laden. Vermeiden Sie zudem die Verwendung eines Dateidatenstroms und von [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522), wenn diese nicht erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="6533c-288">Consequently, you should embrace using [**UriSource**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.bitmapimage.urisource.aspx) when loading images from an app package, and avoid using a file stream and [**SetSourceAsync**](https://msdn.microsoft.com/library/windows/apps/JJ191522) when it's not required.</span></span>

### <a name="images-in-virtualized-panels-listview-for-instance"></a><span data-ttu-id="6533c-289">Bilder in virtualisierten Panels (z. B. ListView)</span><span class="sxs-lookup"><span data-stu-id="6533c-289">Images in virtualized panels (ListView, for instance)</span></span>

<span data-ttu-id="6533c-290">Wenn ein Bild aus der Struktur entfernt wird (weil es von der App explizit entfernt wurde, oder weil es sich in einem modernen virtualisierten Panel befindet und implizit beim Bildlauf aus der Ansicht entfernt wurde), optimiert XAML die Speichernutzung, indem es die nicht mehr für das Bild benötigten Hardwareressourcen freigibt.</span><span class="sxs-lookup"><span data-stu-id="6533c-290">If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</span></span> <span data-ttu-id="6533c-291">Der Arbeitsspeicher wird nicht sofort freigegeben, sondern erst bei der Frameaktualisierung, die eine Sekunde nach Entfernung des Bildelements aus der Struktur stattfindet.</span><span class="sxs-lookup"><span data-stu-id="6533c-291">The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</span></span>

<span data-ttu-id="6533c-292">Folglich sollten Sie nach Möglichkeit moderne virtualisierte Panels zum Hosten von Listen mit Bildinhalten nutzen.</span><span class="sxs-lookup"><span data-stu-id="6533c-292">Consequently, you should strive to use modern virtualized panels to host lists of image content.</span></span>

### <a name="software-rasterized-images"></a><span data-ttu-id="6533c-293">Softwaregerasterte Bilder</span><span class="sxs-lookup"><span data-stu-id="6533c-293">Software-rasterized images</span></span>

<span data-ttu-id="6533c-294">Wenn ein Bild für einen nicht rechteckigen Pinsel oder ein [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) verwendet wird, verwendet das Bild einen Softwarerasterungspfad, bei dem Bilder gar nicht skaliert werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-294">When an image is used for a non-rectangular brush or for a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756), the image will use a software rasterization path, which will not scale images at all.</span></span> <span data-ttu-id="6533c-295">Zudem muss eine Kopie des Bilds sowohl im Arbeitsspeicher der Software als auch der Hardware gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-295">Additionally, it must store a copy of the image in both software and hardware memory.</span></span> <span data-ttu-id="6533c-296">Wenn z. B. ein Bild als Pinsel für eine Ellipse verwendet wird, wird das potenziell große Vollbild zweimal intern gespeichert.</span><span class="sxs-lookup"><span data-stu-id="6533c-296">For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</span></span> <span data-ttu-id="6533c-297">Bei Verwendung von **NineGrid** oder eines nicht rechteckigen Pinsels sollte die App die Bilder vorab auf die ungefähre Größe skalieren, in der sie gerendert werden.</span><span class="sxs-lookup"><span data-stu-id="6533c-297">When using **NineGrid** or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</span></span>

### <a name="background-thread-image-loading"></a><span data-ttu-id="6533c-298">Laden von Bildern in einem Hintergrundthread</span><span class="sxs-lookup"><span data-stu-id="6533c-298">Background thread image-loading</span></span>

<span data-ttu-id="6533c-299">XAML verfügt über eine interne Optimierung, mit der der Inhalt eines Bildes asynchron auf eine Oberfläche im Hardwarespeicher decodiert werden kann, ohne dass eine Zwischenoberfläche im Softwarespeicher benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="6533c-299">XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</span></span> <span data-ttu-id="6533c-300">Dies reduziert Spitzen bei der Speicherauslastung und Renderinglatenz.</span><span class="sxs-lookup"><span data-stu-id="6533c-300">This reduces peak memory usage and rendering latency.</span></span> <span data-ttu-id="6533c-301">Dieses Feature wird deaktiviert, wenn eine der folgenden Bedingungen erfüllt ist.</span><span class="sxs-lookup"><span data-stu-id="6533c-301">This feature will be disabled if any of the following conditions are met.</span></span>

-   <span data-ttu-id="6533c-302">Das Bild wird als [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756) verwendet.</span><span class="sxs-lookup"><span data-stu-id="6533c-302">The image is used as a [**NineGrid**](https://msdn.microsoft.com/library/windows/apps/BR242756).</span></span>
-   `CacheMode="BitmapCache"` <span data-ttu-id="6533c-303">wird auf das Bildelement oder ein beliebiges übergeordnetes Element festgelegt.</span><span class="sxs-lookup"><span data-stu-id="6533c-303">is set on the image element or on any parent element.</span></span>
-   <span data-ttu-id="6533c-304">Der Bildpinsel ist nicht rechteckig (z. B. bei Anwendung auf eine Form oder auf Text).</span><span class="sxs-lookup"><span data-stu-id="6533c-304">The image brush is non-rectangular (such as when applied to a shape or to text).</span></span>

### <a name="softwarebitmapsource"></a><span data-ttu-id="6533c-305">SoftwareBitmapSource</span><span class="sxs-lookup"><span data-stu-id="6533c-305">SoftwareBitmapSource</span></span>

<span data-ttu-id="6533c-306">Die [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854)-Klasse tauscht interoperable, nicht komprimierte Bilder zwischen unterschiedlichen WinRT-Namespaces aus, z. B. [**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176), Kamera-APIs und XAML.</span><span class="sxs-lookup"><span data-stu-id="6533c-306">The [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) class exchanges interoperable uncompressed images between different WinRT namespaces such as [**BitmapDecoder**](https://msdn.microsoft.com/library/windows/apps/BR226176), camera APIs, and XAML.</span></span> <span data-ttu-id="6533c-307">Diese Klasse vermeidet die zusätzliche Kopie, die in der Regel mit [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259) erforderlich wäre. Dadurch reduzieren sich Spitzenlasten im Speicher sowie die Quelle-zu-Bildschirm-Latenz.</span><span class="sxs-lookup"><span data-stu-id="6533c-307">This class obviates an extra copy that would typically be necessary with [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259), and that helps reduce peak memory and source-to-screen latency.</span></span>

<span data-ttu-id="6533c-308">Die [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358)-Klasse, die Quellinformationen bereitstellt, kann auch für ein benutzerdefiniertes [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675)-Objekt konfiguriert werden. Dadurch wird ein erneut ladbarer Sicherungsspeicher bereitgestellt, mit dem die App Arbeitsspeicher nach Bedarf neu zuordnen kann.</span><span class="sxs-lookup"><span data-stu-id="6533c-308">The [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) that supplies source information can also be configured to use a custom [**IWICBitmap**](https://msdn.microsoft.com/library/windows/desktop/Ee719675) to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</span></span> <span data-ttu-id="6533c-309">Dies ist ein erweiterter C++-Anwendungsfall.</span><span class="sxs-lookup"><span data-stu-id="6533c-309">This is an advanced C++ use case.</span></span>

<span data-ttu-id="6533c-310">Ihre App sollte [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) und [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) für die Interoperabilität mit anderen WinRT-APIs verwenden, die Bilder produzieren und nutzen.</span><span class="sxs-lookup"><span data-stu-id="6533c-310">Your app should use [**SoftwareBitmap**](https://msdn.microsoft.com/library/windows/apps/Dn887358) and [**SoftwareBitmapSource**](https://msdn.microsoft.com/library/windows/apps/Dn997854) to interoperate with other WinRT APIs that produce and consume images.</span></span> <span data-ttu-id="6533c-311">Zudem sollte die App beim Laden von nicht komprimierten Bilddaten anstelle von [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259) die **SoftwareBitmapSource**-Klasse verwenden.</span><span class="sxs-lookup"><span data-stu-id="6533c-311">And your app should use **SoftwareBitmapSource** when loading uncompressed image data instead of using [**WriteableBitmap**](https://msdn.microsoft.com/library/windows/apps/BR243259).</span></span>

### <a name="use-getthumbnailasync-for-thumbnails"></a><span data-ttu-id="6533c-312">Verwenden von „GetThumbnailAsync“ für Miniaturansichten</span><span class="sxs-lookup"><span data-stu-id="6533c-312">Use GetThumbnailAsync for thumbnails</span></span>

<span data-ttu-id="6533c-313">Ein Anwendungsfall für die Bildskalierung ist die Erstellung von Miniaturansichten.</span><span class="sxs-lookup"><span data-stu-id="6533c-313">One use case for scaling images is creating thumbnails.</span></span> <span data-ttu-id="6533c-314">Sie könnten kleine Bildversionen zwar auch mit [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) und [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) bereitstellen, aber die Universelle Windows-Plattform (UWP) bietet noch effizientere APIs zum Abrufen von Miniaturansichten.</span><span class="sxs-lookup"><span data-stu-id="6533c-314">Although you could use [**DecodePixelWidth**](https://msdn.microsoft.com/library/windows/apps/BR243243) and [**DecodePixelHeight**](https://msdn.microsoft.com/library/windows/apps/BR243241) to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</span></span> <span data-ttu-id="6533c-315">[**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) stellt die Miniaturansichten für Bilder bereit, bei denen das Dateisystem bereits zwischengespeichert wurde.</span><span class="sxs-lookup"><span data-stu-id="6533c-315">[**GetThumbnailAsync**](https://msdn.microsoft.com/library/windows/apps/BR227210) provides the thumbnails for images that have the file system already cached.</span></span> <span data-ttu-id="6533c-316">Dadurch erhalten Sie eine noch bessere Leistung als bei den XAML-APIs, da das Bild weder geöffnet noch decodiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="6533c-316">This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</span></span>

> [!div class="tabbedCodeSnippets"]
> ```csharp
> FileOpenPicker picker = new FileOpenPicker();
> picker.FileTypeFilter.Add(".bmp");
> picker.FileTypeFilter.Add(".jpg");
> picker.FileTypeFilter.Add(".jpeg");
> picker.FileTypeFilter.Add(".png");
> picker.SuggestedStartLocation = PickerLocationId.PicturesLibrary;
>
> StorageFile file = await picker.PickSingleFileAsync();
>
> StorageItemThumbnail fileThumbnail = await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64);
>
> BitmapImage bmp = new BitmapImage();
> bmp.SetSource(fileThumbnail);
>
> Image img = new Image();
> img.Source = bmp;
> ```
> ```vb
> Dim picker As New FileOpenPicker()
> picker.FileTypeFilter.Add(".bmp")
> picker.FileTypeFilter.Add(".jpg")
> picker.FileTypeFilter.Add(".jpeg")
> picker.FileTypeFilter.Add(".png")
> picker.SuggestedStartLocation = PickerLocationId.PicturesLibrary
>
> Dim file As StorageFile = Await picker.PickSingleFileAsync()
>
> Dim fileThumbnail As StorageItemThumbnail = Await file.GetThumbnailAsync(ThumbnailMode.SingleItem, 64)
>
> Dim bmp As New BitmapImage()
> bmp.SetSource(fileThumbnail)
>
> Dim img As New Image()
> img.Source = bmp
> ```

### <a name="decode-images-once"></a><span data-ttu-id="6533c-317">Einmaliges Decodieren von Bildern</span><span class="sxs-lookup"><span data-stu-id="6533c-317">Decode images once</span></span>

<span data-ttu-id="6533c-318">Damit Bilder nicht mehrmals decodiert werden, weisen Sie die [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760)-Eigenschaft von einem URI aus zu, anstatt Speicherstreams zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="6533c-318">To prevent images from being decoded more than once, assign the [**Image.Source**](https://msdn.microsoft.com/library/windows/apps/BR242760) property from an Uri rather than using memory streams.</span></span> <span data-ttu-id="6533c-319">Das XAML-Framework kann den gleichen URI an mehreren Orten einem einzelnen decodierten Bild zuordnen. Für mehrere Speicherstreams mit den gleichen Daten ist dies allerdings nicht möglich. Hier erstellt das Framework für jeden Speicherstream ein eigenes decodiertes Bild.</span><span class="sxs-lookup"><span data-stu-id="6533c-319">The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</span></span>
